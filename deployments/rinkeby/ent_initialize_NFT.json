{
  "address": "0x1F3F1C521d8a28867271421E996721A7B7BA1B36",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnerSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "prevOwner",
          "type": "address"
        }
      ],
      "name": "OwnerTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DEFAULT_ADMIN_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "minters",
          "type": "address[]"
        },
        {
          "internalType": "string",
          "name": "_contractURI",
          "type": "string"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x9c8f648589973d851958add38f5727a5cf969fd5cb7f5ea3ef5d1f1261e04b27",
  "receipt": {
    "to": null,
    "from": "0xAFe87013dc96edE1E116a288D80FcaA0eFFE5fe5",
    "contractAddress": "0x1F3F1C521d8a28867271421E996721A7B7BA1B36",
    "transactionIndex": 0,
    "gasUsed": "374273",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7855abd72d84c58b3246eb6568261fd7f76a4fb8cf84efd60cc5cdea47b52477",
    "transactionHash": "0x9c8f648589973d851958add38f5727a5cf969fd5cb7f5ea3ef5d1f1261e04b27",
    "logs": [],
    "blockNumber": 8362830,
    "cumulativeGasUsed": "374273",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "7dfea193bf8d74dddd4fadb38960c81e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.3+commit.8d00100c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"}],\"name\":\"OwnerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"minters\",\"type\":\"address[]\"},{\"internalType\":\"string\",\"name\":\"_contractURI\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"initialize(address[],string)\":{\"params\":{\"_contractURI\":\"The link to the initial contract level metadata.\",\"minters\":\"The addresses that should allowed to mint tokens.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"initialize(address[],string)\":{\"notice\":\"Initializes the TellerNFT.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"diamonds/domains/nft/entry/initialize.sol\":\"ent_initialize_NFT\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\",\"keccak256\":\"0x71e0d1cc75b67306382e055b789b6d3ffe34a9e2e55380d3c9895a36a42229e1\",\"license\":\"MIT\"},\"diamonds/contexts/ERC721/storage/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract sto_ERC721 {\\n    struct ERC721Storage {\\n        // Token name\\n        string name;\\n        // Token symbol\\n        string symbol;\\n        // Mapping from token ID to owner address\\n        mapping(uint256 => address) owners;\\n        // Mapping owner address to token count\\n        mapping(address => uint256) balances;\\n        // Mapping from token ID to approved address\\n        mapping(uint256 => address) tokenApprovals;\\n        // Mapping from owner to operator approvals\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n    }\\n\\n    function erc721Store() internal pure returns (ERC721Storage storage s) {\\n        bytes32 position = keccak256(\\\"teller_protocol.ERC721_token\\\");\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0d241ffafab867a1d0de6b7f2fbbf2c4cef4bd9e4c6f245748b63840502dd5e2\",\"license\":\"MIT\"},\"diamonds/contexts/access-control/data.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct RoleData {\\n    mapping(address => bool) members;\\n    bytes32 adminRole;\\n}\\n\\nabstract contract dat_AccessControl_v1 {\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    event OwnerSet(address indexed owner);\\n\\n    event OwnerTransferred(address indexed owner, address indexed prevOwner);\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n}\\n\\nabstract contract dat_AccessControl is dat_AccessControl_v1 {}\\n\",\"keccak256\":\"0x9709b886deef806c2e7b13219f12a7a2b5a83d68023291b0d1191872e0c9b6f2\",\"license\":\"MIT\"},\"diamonds/contexts/access-control/internal/grant-role.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"../data.sol\\\";\\nimport \\\"./has-role.sol\\\";\\n\\nabstract contract int_grantRole_AccessControl_v1 is\\n    dat_AccessControl_v1,\\n    int_hasRole_AccessControl_v1\\n{\\n    /**\\n     * @dev Should only use when circumventing admin checking. See {../entry/grant-role.sol}\\n     */\\n    function _grantRole(bytes32 role, address account) internal {\\n        if (_hasRole(role, account)) return;\\n        accessControlRolesStore().roles[role].members[account] = true;\\n        emit RoleGranted(role, account, msg.sender);\\n    }\\n}\\n\\nabstract contract int_grantRole_AccessControl is\\n    int_grantRole_AccessControl_v1\\n{}\\n\",\"keccak256\":\"0x425452b3d1bea0e3775cbc6b9d36bd0132d357dfcf556b6c1f2ee71b0fbdbf7d\",\"license\":\"MIT\"},\"diamonds/contexts/access-control/internal/has-role.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../storage/roles.sol\\\";\\n\\nabstract contract int_hasRole_AccessControl_v1 is sto_AccessControl_Roles {\\n    function _hasRole(bytes32 role, address account)\\n        internal\\n        view\\n        returns (bool hasRole_)\\n    {\\n        hasRole_ = accessControlRolesStore().roles[role].members[account];\\n    }\\n}\\n\",\"keccak256\":\"0x631c0c260f7de64c32a205405e3ec424a6b34aec27987ced91a0254fdabfb1a7\",\"license\":\"MIT\"},\"diamonds/contexts/access-control/storage/roles.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { RoleData } from \\\"../data.sol\\\";\\n\\nabstract contract sto_AccessControl_Roles {\\n    bytes32 internal constant POS =\\n        keccak256(\\\"teller_protocol.storage.access_control.roles\\\");\\n\\n    struct AccessControlRolesStorage {\\n        mapping(bytes32 => RoleData) roles;\\n    }\\n\\n    function accessControlRolesStore()\\n        internal\\n        pure\\n        returns (AccessControlRolesStorage storage s)\\n    {\\n        bytes32 position = POS;\\n\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf6ed7f621fbdc1dbfafd54e35097030415310a38798397f61b5b230a2e128768\",\"license\":\"MIT\"},\"diamonds/contexts/initializable/modifiers/initializer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../storage.sol\\\";\\n\\nabstract contract mod_initializer_Initializable_v1 is sto_Initializable {\\n    modifier initializer {\\n        require(\\n            !initializableStorage().initialized,\\n            \\\"Teller: already initialized\\\"\\n        );\\n        _;\\n    }\\n}\\n\\nabstract contract mod_initializer_Initializable is\\n    mod_initializer_Initializable_v1\\n{}\\n\",\"keccak256\":\"0xb5df70be12753280451b2d05a2b70dc2c5903019e3c482286203c78d20dfcf85\",\"license\":\"MIT\"},\"diamonds/contexts/initializable/storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract sto_Initializable {\\n    struct InitializableLayout {\\n        bool initialized;\\n    }\\n\\n    bytes32 internal constant INITIALIZABLE_STORAGE_POSITION =\\n        keccak256(abi.encode(\\\"teller_protocol.context.initializable.v1\\\"));\\n\\n    function initializableStorage()\\n        internal\\n        pure\\n        returns (InitializableLayout storage l_)\\n    {\\n        bytes32 position = INITIALIZABLE_STORAGE_POSITION;\\n\\n        assembly {\\n            l_.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7f86202d6ba773f1e2cc389b3d2565a1afa514b2239a2f94dd85525ecda9f71d\",\"license\":\"MIT\"},\"diamonds/domains/nft/entry/initialize.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"../../../contexts/ERC721/storage/ERC721.sol\\\";\\nimport {\\n    mod_initializer_Initializable\\n} from \\\"../../../contexts/initializable/modifiers/initializer.sol\\\";\\nimport {\\n    int_grantRole_AccessControl\\n} from \\\"../../../contexts/access-control/internal/grant-role.sol\\\";\\nimport { int_setContractURI_NFT } from \\\"../internal/set-contract-uri.sol\\\";\\nimport { MINTER } from \\\"../roles.sol\\\";\\n\\ncontract ent_initialize_NFT_v1 is\\n    sto_ERC721,\\n    mod_initializer_Initializable,\\n    int_grantRole_AccessControl,\\n    int_setContractURI_NFT\\n{\\n    /**\\n     * @notice Initializes the TellerNFT.\\n     * @param minters The addresses that should allowed to mint tokens.\\n     * @param _contractURI The link to the initial contract level metadata.\\n     */\\n    function initialize(address[] calldata minters, string memory _contractURI)\\n        external\\n        initializer\\n    {\\n        erc721Store().name = \\\"Teller NFT\\\";\\n        erc721Store().symbol = \\\"TNFT\\\";\\n\\n        for (uint256 i; i < minters.length; i++) {\\n            _grantRole(MINTER, minters[i]);\\n        }\\n\\n        _setContractURI(_contractURI);\\n    }\\n}\\n\\ncontract ent_initialize_NFT is ent_initialize_NFT_v1 {}\\n\",\"keccak256\":\"0xfb1ae10196a7d7fb8235f728166161e9fc4ccc1ce85350da5578f67bfd64da3a\",\"license\":\"MIT\"},\"diamonds/domains/nft/internal/set-contract-uri.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"../storage/token.sol\\\";\\n\\nabstract contract int_setContractURI_NFT_v1 is sto_Token {\\n    /**\\n     * @notice Sets the contract level metadata URI.\\n     * @param contractURI The link to the initial contract level metadata.\\n     */\\n    function _setContractURI(string memory contractURI) internal {\\n        tokenStore().contractURI = contractURI;\\n    }\\n}\\n\\nabstract contract int_setContractURI_NFT is int_setContractURI_NFT_v1 {}\\n\",\"keccak256\":\"0xee01c2b6e97889783e1a602ea9f75ab78372336a4be86aaef9e3dbcee3754452\",\"license\":\"MIT\"},\"diamonds/domains/nft/roles.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nbytes32 constant ADMIN = keccak256(\\\"ADMIN\\\");\\nbytes32 constant MINTER = keccak256(\\\"MINTER\\\");\\n\",\"keccak256\":\"0xa5fecccb2dd77a6b8af8615bc5ef2bfdd19492c67ad72dcc38bec4ceff07905c\",\"license\":\"MIT\"},\"diamonds/domains/nft/storage/token.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nabstract contract sto_Token {\\n    bytes32 internal constant POSITION = keccak256(\\\"teller_nft.token\\\");\\n\\n    struct TokenStorage {\\n        // It holds a set of token IDs for an owner address.\\n        mapping(address => EnumerableSet.UintSet) ownerTokenIDs;\\n        // Link to the contract metadata\\n        string contractURI;\\n    }\\n\\n    function tokenStore() internal pure returns (TokenStorage storage s) {\\n        bytes32 position = POSITION;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfeb61db52732fd6187c59fc5f88e09c24c118a96520b912bb9f743996b1f2536\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506105ce806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80633233efe51461003b578063a217fddf14610050575b600080fd5b61004e610049366004610420565b61006a565b005b610058600081565b60405190815260200160405180910390f35b6100726101ee565b5460ff16156100c75760405162461bcd60e51b815260206004820152601b60248201527f54656c6c65723a20616c726561647920696e697469616c697a65640000000000604482015260640160405180910390fd5b60408051808201909152600a81526915195b1b195c8813919560b21b60208201527f1e91dbccf5488299bd4adcb044f4c3df902739c02f1f78276dd4194ac6a8d99d81516101189260200190610359565b50604080518082019091526004808252631513919560e21b6020909201918252610163917f1e91dbccf5488299bd4adcb044f4c3df902739c02f1f78276dd4194ac6a8d99e91610359565b5060005b828110156101df576101cd7ff0887ba65ee2024ea881d91b74c2450ef19e1557f03bed3ea9f16b037cbe2dc98585848181106101b357634e487b7160e01b600052603260045260246000fd5b90506020020160208101906101c891906103f2565b610261565b806101d78161055b565b915050610167565b506101e98161032b565b505050565b6000806040516020016102439060208082526028908201527f74656c6c65725f70726f746f636f6c2e636f6e746578742e696e697469616c696040820152677a61626c652e763160c01b606082015260800190565b60408051601f19818403018152919052805160209091012092915050565b60008281527f337c29a31b05a860fb532911919dbe85ab303a7465176333f1deb496e9fdd19e602090815260408083206001600160a01b038516845290915290205460ff16156102b057610327565b60008281527f337c29a31b05a860fb532911919dbe85ab303a7465176333f1deb496e9fdd19e602090815260408083206001600160a01b0385168085529252808320805460ff1916600117905551339285917f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d9190a45b5050565b8051610327907f7d831add1cfdac9c9a7c42498fe0e1d396f2a23a5826619aec75af6873a588859060208401905b82805461036590610520565b90600052602060002090601f01602090048101928261038757600085556103cd565b82601f106103a057805160ff19168380011785556103cd565b828001600101855582156103cd579182015b828111156103cd5782518255916020019190600101906103b2565b506103d99291506103dd565b5090565b5b808211156103d957600081556001016103de565b600060208284031215610403578081fd5b81356001600160a01b0381168114610419578182fd5b9392505050565b600080600060408486031215610434578182fd5b833567ffffffffffffffff8082111561044b578384fd5b818601915086601f83011261045e578384fd5b81358181111561046c578485fd5b602088818360051b8601011115610481578586fd5b80840196508195508088013593508284111561049b578485fd5b838801935088601f8501126104ae578485fd5b83359150828211156104c2576104c2610582565b604051601f8301601f19908116603f011681019084821181831017156104ea576104ea610582565b816040528381528a83858801011115610501578687fd5b8383870184830137868385830101528096505050505050509250925092565b600181811c9082168061053457607f821691505b6020821081141561055557634e487b7160e01b600052602260045260246000fd5b50919050565b600060001982141561057b57634e487b7160e01b81526011600452602481fd5b5060010190565b634e487b7160e01b600052604160045260246000fdfea26469706673582212206d9c36a2712dcda928402b6aa1227c0aad26936b8fe39fe2230460b1ceac4d0d64736f6c63430008030033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80633233efe51461003b578063a217fddf14610050575b600080fd5b61004e610049366004610420565b61006a565b005b610058600081565b60405190815260200160405180910390f35b6100726101ee565b5460ff16156100c75760405162461bcd60e51b815260206004820152601b60248201527f54656c6c65723a20616c726561647920696e697469616c697a65640000000000604482015260640160405180910390fd5b60408051808201909152600a81526915195b1b195c8813919560b21b60208201527f1e91dbccf5488299bd4adcb044f4c3df902739c02f1f78276dd4194ac6a8d99d81516101189260200190610359565b50604080518082019091526004808252631513919560e21b6020909201918252610163917f1e91dbccf5488299bd4adcb044f4c3df902739c02f1f78276dd4194ac6a8d99e91610359565b5060005b828110156101df576101cd7ff0887ba65ee2024ea881d91b74c2450ef19e1557f03bed3ea9f16b037cbe2dc98585848181106101b357634e487b7160e01b600052603260045260246000fd5b90506020020160208101906101c891906103f2565b610261565b806101d78161055b565b915050610167565b506101e98161032b565b505050565b6000806040516020016102439060208082526028908201527f74656c6c65725f70726f746f636f6c2e636f6e746578742e696e697469616c696040820152677a61626c652e763160c01b606082015260800190565b60408051601f19818403018152919052805160209091012092915050565b60008281527f337c29a31b05a860fb532911919dbe85ab303a7465176333f1deb496e9fdd19e602090815260408083206001600160a01b038516845290915290205460ff16156102b057610327565b60008281527f337c29a31b05a860fb532911919dbe85ab303a7465176333f1deb496e9fdd19e602090815260408083206001600160a01b0385168085529252808320805460ff1916600117905551339285917f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d9190a45b5050565b8051610327907f7d831add1cfdac9c9a7c42498fe0e1d396f2a23a5826619aec75af6873a588859060208401905b82805461036590610520565b90600052602060002090601f01602090048101928261038757600085556103cd565b82601f106103a057805160ff19168380011785556103cd565b828001600101855582156103cd579182015b828111156103cd5782518255916020019190600101906103b2565b506103d99291506103dd565b5090565b5b808211156103d957600081556001016103de565b600060208284031215610403578081fd5b81356001600160a01b0381168114610419578182fd5b9392505050565b600080600060408486031215610434578182fd5b833567ffffffffffffffff8082111561044b578384fd5b818601915086601f83011261045e578384fd5b81358181111561046c578485fd5b602088818360051b8601011115610481578586fd5b80840196508195508088013593508284111561049b578485fd5b838801935088601f8501126104ae578485fd5b83359150828211156104c2576104c2610582565b604051601f8301601f19908116603f011681019084821181831017156104ea576104ea610582565b816040528381528a83858801011115610501578687fd5b8383870184830137868385830101528096505050505050509250925092565b600181811c9082168061053457607f821691505b6020821081141561055557634e487b7160e01b600052602260045260246000fd5b50919050565b600060001982141561057b57634e487b7160e01b81526011600452602481fd5b5060010190565b634e487b7160e01b600052604160045260246000fdfea26469706673582212206d9c36a2712dcda928402b6aa1227c0aad26936b8fe39fe2230460b1ceac4d0d64736f6c63430008030033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "initialize(address[],string)": {
        "params": {
          "_contractURI": "The link to the initial contract level metadata.",
          "minters": "The addresses that should allowed to mint tokens."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "initialize(address[],string)": {
        "notice": "Initializes the TellerNFT."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
