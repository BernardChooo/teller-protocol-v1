{
  "address": "0xc5AAB6EEfe50F4002A8c327b02839e055F9a82C7",
  "abi": [
    {
      "inputs": [],
      "name": "baseURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "contractURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x333bc4ad524c9988cb1fa35d8b277b0c941e2609f3d172c506505e217e58a42e",
  "receipt": {
    "to": null,
    "from": "0xAFe87013dc96edE1E116a288D80FcaA0eFFE5fe5",
    "contractAddress": "0xc5AAB6EEfe50F4002A8c327b02839e055F9a82C7",
    "transactionIndex": 0,
    "gasUsed": "332308",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x73432507832c8930c7868c4c06df5b31e46f610e0b514698a0c3fba4a42722bc",
    "transactionHash": "0x333bc4ad524c9988cb1fa35d8b277b0c941e2609f3d172c506505e217e58a42e",
    "logs": [],
    "blockNumber": 8363324,
    "cumulativeGasUsed": "332308",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "333984a3094be515f0fdf2f8a4c5c108",
  "metadata": "{\"compiler\":{\"version\":\"0.8.3+commit.8d00100c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"baseURI()\":{\"notice\":\"Base URI for computing {tokenURI}. See {IERC721Metadata-_baseURI}\"},\"tokenURI(uint256)\":{\"notice\":\"See {IERC721Metadata-tokenURI}.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"diamonds/domains/nft/external/metadata.sol\":\"ext_metadata_NFT\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x62d306ff0499a11913bc60b5939eec619509b5c67b30e86ebf8b8bda0b7a7fee\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\",\"keccak256\":\"0x456e9b3a2bfe189b5249857f624f4139e59331db518483b456c4e587a20552e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2526b7c6a366fc211bbc176078ab02b83833e7682abcc5b3bed9d700b34e2a3e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\",\"keccak256\":\"0x71e0d1cc75b67306382e055b789b6d3ffe34a9e2e55380d3c9895a36a42229e1\",\"license\":\"MIT\"},\"diamonds/contexts/ERC721/external/metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"../storage/ERC721.sol\\\";\\nimport { int_exists_ERC721_v1 } from \\\"../internal/exists.sol\\\";\\nimport { int_metadata_ERC721_v1 } from \\\"../internal/metadata.sol\\\";\\n\\ncontract ext_metadata_ERC721_v1 is\\n    sto_ERC721,\\n    int_exists_ERC721_v1,\\n    int_metadata_ERC721_v1\\n{\\n    /**\\n     * @notice Base URI for computing {tokenURI}. See {IERC721Metadata-_baseURI}\\n     */\\n    function baseURI() external view virtual returns (string memory) {\\n        return _baseURI();\\n    }\\n\\n    /**\\n     * @notice See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId)\\n        external\\n        view\\n        virtual\\n        returns (string memory)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"ERC721Metadata: URI query for nonexistent token\\\"\\n        );\\n\\n        string memory base = _baseURI();\\n        return\\n            bytes(base).length > 0\\n                ? string(abi.encodePacked(base, _tokenURI(tokenId)))\\n                : \\\"\\\";\\n    }\\n}\\n\",\"keccak256\":\"0x94a9d11256c97015970ba50a3bd6806bb9a342a51079db5732383a2ef8ee69a7\",\"license\":\"MIT\"},\"diamonds/contexts/ERC721/internal/exists.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"../storage/ERC721.sol\\\";\\n\\nabstract contract int_exists_ERC721_v1 is sto_ERC721 {\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return erc721Store().owners[tokenId] != address(0);\\n    }\\n}\\n\",\"keccak256\":\"0x5290c03ebf2f1acdc8416f3bdcc640537d636020a5960e11375f6ace8051653d\",\"license\":\"MIT\"},\"diamonds/contexts/ERC721/internal/metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../storage/ERC721.sol\\\";\\n\\nabstract contract int_metadata_ERC721_v1 is sto_ERC721 {\\n    using Strings for uint256;\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\\n     * in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Token URI for computing {tokenURI}. Will be appended to {_baseURI}.\\n     */\\n    function _tokenURI(uint256 tokenId)\\n        internal\\n        view\\n        virtual\\n        returns (string memory)\\n    {\\n        return tokenId.toString();\\n    }\\n}\\n\",\"keccak256\":\"0x2038c4ba40a8fc07579b3c6ba71b92a022bb5224183114c6d020d796636f4476\",\"license\":\"MIT\"},\"diamonds/contexts/ERC721/storage/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract sto_ERC721 {\\n    struct ERC721Storage {\\n        // Token name\\n        string name;\\n        // Token symbol\\n        string symbol;\\n        // Mapping from token ID to owner address\\n        mapping(uint256 => address) owners;\\n        // Mapping owner address to token count\\n        mapping(address => uint256) balances;\\n        // Mapping from token ID to approved address\\n        mapping(uint256 => address) tokenApprovals;\\n        // Mapping from owner to operator approvals\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n    }\\n\\n    function erc721Store() internal pure returns (ERC721Storage storage s) {\\n        bytes32 position = keccak256(\\\"teller_protocol.ERC721_token\\\");\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa7e97bf0b2a7cb6a50dbf0ec070901b154b8e4c745ebcec9e2b398852992a0c5\",\"license\":\"MIT\"},\"diamonds/domains/nft/data/tier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct Tier {\\n    uint256 baseLoanSize;\\n    string[] hashes;\\n    address contributionAsset;\\n    uint256 contributionSize;\\n    uint8 contributionMultiplier;\\n}\\n\",\"keccak256\":\"0x20ae7b004b8ab4b7b31b62265c4cee1e8851223c333c2e603d8d3f90a43c1f70\",\"license\":\"MIT\"},\"diamonds/domains/nft/external/metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"../storage/token.sol\\\";\\nimport \\\"../storage/tier.sol\\\";\\nimport \\\"../../../contexts/ERC721/storage/ERC721.sol\\\";\\nimport {\\n    ext_metadata_ERC721_v1,\\n    int_metadata_ERC721_v1\\n} from \\\"../../../contexts/ERC721/external/metadata.sol\\\";\\nimport { int_metadata_NFT_v1 } from \\\"../internal/metadata.sol\\\";\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @notice NFT contract inherits this instead of the ERC721 one so the internal methods get overridden.\\n */\\ncontract ext_metadata_NFT_v1 is\\n    sto_Token,\\n    sto_Tier,\\n    sto_ERC721,\\n    ext_metadata_ERC721_v1,\\n    int_metadata_NFT_v1\\n{\\n    using SafeMath for uint256;\\n\\n    function contractURI() external view returns (string memory) {\\n        return tokenStore().contractURI;\\n    }\\n\\n    /**\\n     * @notice The base URI path where the token media is hosted.\\n     * @dev Base URI for computing {tokenURI}.\\n     */\\n    function _baseURI()\\n        internal\\n        view\\n        override(int_metadata_ERC721_v1, int_metadata_NFT_v1)\\n        returns (string memory)\\n    {\\n        return int_metadata_NFT_v1._baseURI();\\n    }\\n\\n    /**\\n     * @notice It returns the hash to use for the token URI.\\n     */\\n    function _tokenURI(uint256 tokenId)\\n        internal\\n        view\\n        override(int_metadata_ERC721_v1, int_metadata_NFT_v1)\\n        returns (string memory)\\n    {\\n        return int_metadata_NFT_v1._tokenURI(tokenId);\\n    }\\n}\\n\\ncontract ext_metadata_NFT is ext_metadata_NFT_v1 {}\\n\",\"keccak256\":\"0x252758f819df86e1d69e304394d2559a90d9fc236b62493501b9f72878e42adf\",\"license\":\"MIT\"},\"diamonds/domains/nft/internal/metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"../storage/token.sol\\\";\\nimport \\\"../storage/tier.sol\\\";\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nabstract contract int_metadata_NFT_v1 is sto_Token, sto_Tier {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @notice The base URI path where the token media is hosted.\\n     * @dev Base URI for computing {tokenURI}.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"https://gateway.pinata.cloud/ipfs/\\\";\\n    }\\n\\n    /**\\n     * @notice It returns the hash to use for the token URI.\\n     */\\n    function _tokenURI(uint256 tokenId)\\n        internal\\n        view\\n        virtual\\n        returns (string memory)\\n    {\\n        string[] storage tierImageHashes =\\n            tierStore().tiers[tierStore().tokenTierMap[tokenId]].hashes;\\n        return tierImageHashes[tokenId.mod(tierImageHashes.length)];\\n    }\\n\\n    /**\\n     * @dev Sets the URI for the contract metadata.\\n     */\\n    function _setContractURI(string memory uri) internal {\\n        tokenStore().contractURI = uri;\\n    }\\n}\\n\",\"keccak256\":\"0xeea675e7bd45b866df810687552112a838b602cece0e253f31d4bf4531fe0d43\",\"license\":\"MIT\"},\"diamonds/domains/nft/storage/tier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport { Tier } from \\\"../data/tier.sol\\\";\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\ncontract sto_Tier {\\n    struct TierStorage {\\n        // It holds the total number of tiers.\\n        Counters.Counter tierCounter;\\n        // It holds the total number of tokens minted.\\n        Counters.Counter tokenCounter;\\n        // It holds the information about a tier.\\n        mapping(uint256 => Tier) tiers;\\n        // It holds which tier a token ID is in.\\n        mapping(uint256 => uint256) tokenTierMap;\\n    }\\n\\n    function tierStore() internal pure returns (TierStorage storage s) {\\n        bytes32 POSITION = keccak256(\\\"teller_nft.tier\\\");\\n\\n        assembly {\\n            s.slot := POSITION\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0bd9fa6301739e952131db77bd7c8114df6ece29286ff4e69957d92bbf46ba97\",\"license\":\"MIT\"},\"diamonds/domains/nft/storage/token.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ncontract sto_Token {\\n    bytes32 internal constant POSITION = keccak256(\\\"teller_nft.token\\\");\\n\\n    struct TokenStorage {\\n        // It holds a set of token IDs for an owner address.\\n        mapping(address => EnumerableSet.UintSet) ownerTokenIDs;\\n        // Link to the contract metadata\\n        string contractURI;\\n    }\\n\\n    function tokenStore() internal pure returns (TokenStorage storage s) {\\n        bytes32 position = POSITION;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2f193dd2123d5092c95ba64c9d1d75dc076987f4f5ab75241e1e003e4c59570f\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061050c806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80636c0360eb14610046578063c87b56dd14610064578063e8a3d48514610077575b600080fd5b61004e61007f565b60405161005b91906103f6565b60405180910390f35b61004e6100723660046103af565b61008e565b61004e61018c565b6060610089610240565b905090565b60008181527f1e91dbccf5488299bd4adcb044f4c3df902739c02f1f78276dd4194ac6a8d99f60205260409020546060906001600160a01b03166101305760405162461bcd60e51b815260206004820152602f60248201527f4552433732314d657461646174613a2055524920717565727920666f72206e6f60448201526e3732bc34b9ba32b73a103a37b5b2b760891b606482015260840160405180910390fd5b600061013a610240565b9050600081511161015a5760405180602001604052806000815250610185565b806101648461024a565b6040516020016101759291906103c7565b6040516020818303038152906040525b9392505050565b60607f7d831add1cfdac9c9a7c42498fe0e1d396f2a23a5826619aec75af6873a5888460010180546101bd90610459565b80601f01602080910402602001604051908101604052809291908181526020018280546101e990610459565b80156102365780601f1061020b57610100808354040283529160200191610236565b820191906000526020600020905b81548152906001019060200180831161021957829003601f168201915b5050505050905090565b606061008961025b565b60606102558261027b565b92915050565b60606040518060600160405280602281526020016104b560229139905090565b60008181527f0a84207e1143ff19b71979feb4ec3b9e9ab20a9f584206f464503fa07b113fc4602090815260408083205483527f0a84207e1143ff19b71979feb4ec3b9e9ab20a9f584206f464503fa07b113fc3909152902060010180546060919081906102ea9085906103a3565b8154811061030857634e487b7160e01b600052603260045260246000fd5b90600052602060002001805461031d90610459565b80601f016020809104026020016040519081016040528092919081815260200182805461034990610459565b80156103965780601f1061036b57610100808354040283529160200191610396565b820191906000526020600020905b81548152906001019060200180831161037957829003601f168201915b5050505050915050919050565b60006101858284610494565b6000602082840312156103c0578081fd5b5035919050565b600083516103d9818460208801610429565b8351908301906103ed818360208801610429565b01949350505050565b6000602082528251806020840152610415816040850160208701610429565b601f01601f19169190910160400192915050565b60005b8381101561044457818101518382015260200161042c565b83811115610453576000848401525b50505050565b600181811c9082168061046d57607f821691505b6020821081141561048e57634e487b7160e01b600052602260045260246000fd5b50919050565b6000826104af57634e487b7160e01b81526012600452602481fd5b50069056fe68747470733a2f2f676174657761792e70696e6174612e636c6f75642f697066732fa2646970667358221220cac044c68ce4949db5a7316dd4d148dd499fd2e6d282967a74e4db24da07b5fa64736f6c63430008030033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80636c0360eb14610046578063c87b56dd14610064578063e8a3d48514610077575b600080fd5b61004e61007f565b60405161005b91906103f6565b60405180910390f35b61004e6100723660046103af565b61008e565b61004e61018c565b6060610089610240565b905090565b60008181527f1e91dbccf5488299bd4adcb044f4c3df902739c02f1f78276dd4194ac6a8d99f60205260409020546060906001600160a01b03166101305760405162461bcd60e51b815260206004820152602f60248201527f4552433732314d657461646174613a2055524920717565727920666f72206e6f60448201526e3732bc34b9ba32b73a103a37b5b2b760891b606482015260840160405180910390fd5b600061013a610240565b9050600081511161015a5760405180602001604052806000815250610185565b806101648461024a565b6040516020016101759291906103c7565b6040516020818303038152906040525b9392505050565b60607f7d831add1cfdac9c9a7c42498fe0e1d396f2a23a5826619aec75af6873a5888460010180546101bd90610459565b80601f01602080910402602001604051908101604052809291908181526020018280546101e990610459565b80156102365780601f1061020b57610100808354040283529160200191610236565b820191906000526020600020905b81548152906001019060200180831161021957829003601f168201915b5050505050905090565b606061008961025b565b60606102558261027b565b92915050565b60606040518060600160405280602281526020016104b560229139905090565b60008181527f0a84207e1143ff19b71979feb4ec3b9e9ab20a9f584206f464503fa07b113fc4602090815260408083205483527f0a84207e1143ff19b71979feb4ec3b9e9ab20a9f584206f464503fa07b113fc3909152902060010180546060919081906102ea9085906103a3565b8154811061030857634e487b7160e01b600052603260045260246000fd5b90600052602060002001805461031d90610459565b80601f016020809104026020016040519081016040528092919081815260200182805461034990610459565b80156103965780601f1061036b57610100808354040283529160200191610396565b820191906000526020600020905b81548152906001019060200180831161037957829003601f168201915b5050505050915050919050565b60006101858284610494565b6000602082840312156103c0578081fd5b5035919050565b600083516103d9818460208801610429565b8351908301906103ed818360208801610429565b01949350505050565b6000602082528251806020840152610415816040850160208701610429565b601f01601f19169190910160400192915050565b60005b8381101561044457818101518382015260200161042c565b83811115610453576000848401525b50505050565b600181811c9082168061046d57607f821691505b6020821081141561048e57634e487b7160e01b600052602260045260246000fd5b50919050565b6000826104af57634e487b7160e01b81526012600452602481fd5b50069056fe68747470733a2f2f676174657761792e70696e6174612e636c6f75642f697066732fa2646970667358221220cac044c68ce4949db5a7316dd4d148dd499fd2e6d282967a74e4db24da07b5fa64736f6c63430008030033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "baseURI()": {
        "notice": "Base URI for computing {tokenURI}. See {IERC721Metadata-_baseURI}"
      },
      "tokenURI(uint256)": {
        "notice": "See {IERC721Metadata-tokenURI}."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
