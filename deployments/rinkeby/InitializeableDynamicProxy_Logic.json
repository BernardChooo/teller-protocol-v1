{
  "address": "0xC3777063E7d5B845F18c8aeb77075bccc0734D0b",
  "abi": [
    {
      "payable": true,
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "implementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "implementationStored",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "address",
          "name": "aLogicRegistryAddress",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "aLogicName",
          "type": "bytes32"
        },
        {
          "internalType": "bool",
          "name": "isStrictDynamic",
          "type": "bool"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "logicName",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "logicRegistry",
      "outputs": [
        {
          "internalType": "contract LogicVersionsRegistryInterface",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "strictDynamic",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "upgradeProxyTo",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x23e24c670a021dfd990ea39e4215af97203e01cd04c9852a6e06dee7a92aaf47",
  "receipt": {
    "to": null,
    "from": "0xAFe87013dc96edE1E116a288D80FcaA0eFFE5fe5",
    "contractAddress": "0xC3777063E7d5B845F18c8aeb77075bccc0734D0b",
    "transactionIndex": 1,
    "gasUsed": "332068",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb88085d06f918ef629331341e7c98b8123f8940c60fb6937caa10a5b61429d69",
    "transactionHash": "0x23e24c670a021dfd990ea39e4215af97203e01cd04c9852a6e06dee7a92aaf47",
    "logs": [],
    "blockNumber": 8298727,
    "cumulativeGasUsed": "414041",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "3790d34ca1d72794863015ffe08f35de",
  "metadata": "{\"compiler\":{\"version\":\"0.5.17+commit.d19bba13\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementationStored\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"aLogicRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"aLogicName\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isStrictDynamic\",\"type\":\"bool\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicName\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicRegistry\",\"outputs\":[{\"internalType\":\"contract LogicVersionsRegistryInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strictDynamic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeProxyTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"develop@teller.finance\",\"methods\":{\"implementation()\":{\"return\":\"Address of the current implementation\"},\"initialize(address,bytes32,bool)\":{\"params\":{\"aLogicName\":\"the settings contract address.\",\"aLogicRegistryAddress\":\"the settings contract address.\",\"isStrictDynamic\":\"Boolean indicating if the proxy must check the registry for a new implementation.\"}}}},\"userdoc\":{\"methods\":{\"implementation()\":{\"notice\":\"Returns the current implementation.\"},\"initialize(address,bytes32,bool)\":{\"notice\":\"It initializes a new dynamic proxy given a logic registry contract and a logic name.\"}},\"notice\":\"It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.It extends BaseUpgradeable to get access to the settings.\"}},\"settings\":{\"compilationTarget\":{\"contracts/base/proxies/InitializeableDynamicProxy.sol\":\"InitializeableDynamicProxy\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":true,\"yulDetails\":{\"stackAllocation\":true}},\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0x640b6dee7a4b830bdfd52b5031a07fc2b12209f5b2e29e5d364a7d37f69d8076\"},\"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\":{\"content\":\"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x1a8e5072509c5ea7365eb1d48030b9be865140c8fb779968da0a459a0e174a11\"},\"@openzeppelin/upgrades/contracts/upgradeability/Proxy.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Proxy\\n * @dev Implements delegation of calls to other contracts, with proper\\n * forwarding of return values and bubbling of failures.\\n * It defines a fallback function that delegates all calls to the address\\n * returned by the abstract _implementation() internal function.\\n */\\ncontract Proxy {\\n  /**\\n   * @dev Fallback function.\\n   * Implemented entirely in `_fallback`.\\n   */\\n  function () payable external {\\n    _fallback();\\n  }\\n\\n  /**\\n   * @return The Address of the implementation.\\n   */\\n  function _implementation() internal view returns (address);\\n\\n  /**\\n   * @dev Delegates execution to an implementation contract.\\n   * This is a low level function that doesn't return to its internal call site.\\n   * It will return to the external caller whatever the implementation returns.\\n   * @param implementation Address to delegate.\\n   */\\n  function _delegate(address implementation) internal {\\n    assembly {\\n      // Copy msg.data. We take full control of memory in this inline assembly\\n      // block because it will not return to Solidity code. We overwrite the\\n      // Solidity scratch pad at memory position 0.\\n      calldatacopy(0, 0, calldatasize)\\n\\n      // Call the implementation.\\n      // out and outsize are 0 because we don't know the size yet.\\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\\n\\n      // Copy the returned data.\\n      returndatacopy(0, 0, returndatasize)\\n\\n      switch result\\n      // delegatecall returns 0 on error.\\n      case 0 { revert(0, returndatasize) }\\n      default { return(0, returndatasize) }\\n    }\\n  }\\n\\n  /**\\n   * @dev Function that is run as the first thing in the fallback function.\\n   * Can be redefined in derived contracts to add functionality.\\n   * Redefinitions must call super._willFallback().\\n   */\\n  function _willFallback() internal {\\n  }\\n\\n  /**\\n   * @dev fallback implementation.\\n   * Extracted to enable manual triggering.\\n   */\\n  function _fallback() internal {\\n    _willFallback();\\n    _delegate(_implementation());\\n  }\\n}\\n\",\"keccak256\":\"0xd8074ae5fa7ee6384ca8196a896612fb044bbf4ff4b7336d03cd97845000ac21\"},\"contracts/base/proxies/BaseDynamicProxy.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Contracts\\nimport \\\"./BaseProxy.sol\\\";\\nimport \\\"../upgradeable/DynamicUpgradeable.sol\\\";\\n\\n/**\\n    @notice It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.\\n    @notice It extends BaseUpgradeable to get access to the settings.\\n\\n    @author develop@teller.finance\\n */\\ncontract BaseDynamicProxy is BaseProxy, DynamicUpgradeable {\\n\\n}\\n\",\"keccak256\":\"0x7f04dd04250770ed0b2f126834a7dcf47c7da6564aa95662893d70ba85c284ba\"},\"contracts/base/proxies/BaseProxy.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n// Interfaces\\nimport \\\"../../interfaces/IBaseProxy.sol\\\";\\n\\n// Contracts\\nimport \\\"@openzeppelin/upgrades/contracts/upgradeability/Proxy.sol\\\";\\n\\n/**\\n    @notice It is the base Proxy contract for all other Proxy contracts.\\n    @dev It makes the current logic implementation address publicly available.\\n\\n    @author develop@teller.finance\\n */\\ncontract BaseProxy is IBaseProxy, Proxy {\\n    /**\\n        @notice Returns the current implementation.\\n        @return Address of the current implementation\\n     */\\n    function implementation() external view returns (address) {\\n        return _implementation();\\n    }\\n}\\n\",\"keccak256\":\"0xb8665af9a3b96a6adfa849e2d8e32d095542ccd3889249134e20fc69c4c0da51\"},\"contracts/base/proxies/InitializeableDynamicProxy.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Contracts\\nimport \\\"./BaseDynamicProxy.sol\\\";\\n\\n// Interfaces\\nimport \\\"../../interfaces/IInitializeableDynamicProxy.sol\\\";\\n\\n/**\\n    @notice It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.\\n    @notice It extends BaseUpgradeable to get access to the settings.\\n\\n    @author develop@teller.finance\\n */\\ncontract InitializeableDynamicProxy is\\n    IInitializeableDynamicProxy,\\n    BaseDynamicProxy\\n{\\n    /**\\n        @notice It initializes a new dynamic proxy given a logic registry contract and a logic name.\\n        @param aLogicRegistryAddress the settings contract address.\\n        @param aLogicName the settings contract address.\\n        @param isStrictDynamic Boolean indicating if the proxy must check the registry for a new implementation.\\n     */\\n    function initialize(\\n        address aLogicRegistryAddress,\\n        bytes32 aLogicName,\\n        bool isStrictDynamic\\n    ) public {\\n        require(address(logicRegistry) == address(0), \\\"PROXY_ALREADY_INIT\\\");\\n        logicRegistry = LogicVersionsRegistryInterface(aLogicRegistryAddress);\\n        logicName = aLogicName;\\n        strictDynamic = isStrictDynamic;\\n        _updateImplementationStored();\\n    }\\n}\\n\",\"keccak256\":\"0xedb838fb87d06461dbf642027ba47a8cd9c7418f30b48f626ed789c8810d9c38\"},\"contracts/base/upgradeable/DynamicUpgradeable.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Contracts\\nimport \\\"./DynamicUpgradeableStorage.sol\\\";\\n\\n/*****************************************************************************************************/\\n/**                                             WARNING                                             **/\\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\\n/**  ---------------------------------------------------------------------------------------------  **/\\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\\n/**  contract that this contract inherits from                                                      **/\\n/**                                                                                                 **/\\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\\n/**  more information.                                                                              **/\\n/*****************************************************************************************************/\\n/**\\n * @notice This contract is used define the DynamicUpgradeable contracts logic.\\n *\\n * @author develop@teller.finance\\n */\\ncontract DynamicUpgradeable is DynamicUpgradeableStorage {\\n    /* External Functions */\\n\\n    function upgradeProxyTo(address newImplementation) public {\\n        require(msg.sender == address(logicRegistry), \\\"MUST_BE_LOGIC_REGISTRY\\\");\\n        implementationStored = newImplementation;\\n        _implementationBlockUpdated = block.number;\\n    }\\n\\n    /* Internal Functions **/\\n\\n    /**\\n     * @notice Returns the current implementation used by the proxy to delegate a call to.\\n     * @return address of the current implementation\\n     */\\n    function _implementation() internal view returns (address) {\\n        return implementationStored;\\n    }\\n\\n    /**\\n     * @notice Updates the current implementation logic address for the stored logic name.\\n     * @dev It uses the LogicVersionsRegistry contract to get the logic address or the cached address if valid.\\n     * @dev It caches the current logic address for the proxy to reduce gas on subsequent calls within the same block.\\n     */\\n    function _updateImplementationStored() internal {\\n        (, , address currentLogic) = logicRegistry.getLogicVersion(logicName);\\n\\n        if (implementationStored != currentLogic) {\\n            implementationStored = currentLogic;\\n        }\\n        _implementationBlockUpdated = block.number;\\n    }\\n\\n    /**\\n     * @notice It is called by the OZ proxy contract before calling the internal _implementation() function.\\n     */\\n    function _willFallback() internal {\\n        if (strictDynamic && _implementationBlockUpdated + 50 <= block.number) {\\n            _updateImplementationStored();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x187d73536e18c3cb563599aba5523ec746c8e507c2b49ca3df23a6db4657ff0b\"},\"contracts/base/upgradeable/DynamicUpgradeableStorage.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Interfaces\\nimport \\\"../../interfaces/LogicVersionsRegistryInterface.sol\\\";\\n\\n/*****************************************************************************************************/\\n/**                                             WARNING                                             **/\\n/**                        THIS CONTRACT IS A NON UPGRADEABLE STORAGE CONTRACT!                     **/\\n/**  ---------------------------------------------------------------------------------------------  **/\\n/**  Do NOT change the order of, PREPEND, or APPEND any storage variables to this or new versions   **/\\n/**  of this contract as this will cause a ripple affect to the storage slots of all child          **/\\n/**  contracts that inherit from this contract to be overwritten on the deployed proxy contract!!   **/\\n/**                                                                                                 **/\\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\\n/**  more information.                                                                              **/\\n/*****************************************************************************************************/\\n/**\\n    @notice This contract is used define the storage variables for all DynamicUpgradeable contracts.\\n\\n    @author develop@teller.finance\\n */\\ncontract DynamicUpgradeableStorage {\\n    /**\\n     * @notice It returns the logic registry that is used to determine the implementation logic for this proxy.\\n     * @dev See LogicVersionsRegistry contract.\\n     * @return LogicVersionsRegistryInterface\\n     */\\n    LogicVersionsRegistryInterface public logicRegistry;\\n\\n    /**\\n     * @notice It represent the logic name (key) used for this proxy.\\n     * @dev It is used by LogicVersionsRegistry to get the logic address for the given logic name.\\n     * @dev It must NOT change over time.\\n     * @return bytes32 the logic name.\\n     */\\n    bytes32 public logicName;\\n\\n    /**\\n     * @param strictDynamic Boolean indicating if the proxy must check the registry for a new implementation.\\n     */\\n    bool public strictDynamic;\\n\\n    /**\\n     * @notice It stores the last known logic address locally to reduce gas costs.\\n     */\\n    address public implementationStored;\\n\\n    /**\\n     * @notice It is the block number which the last time the proxy implementation was checked.\\n     */\\n    uint256 internal _implementationBlockUpdated;\\n}\\n\",\"keccak256\":\"0x41d7840d94fac9d313772d0add8654db2e256515070b7e1c516e1bf6819bc448\"},\"contracts/interfaces/IBaseProxy.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\ninterface IBaseProxy {\\n    /**\\n        @notice Returns the current implementation.\\n        @return Address of the current implementation\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x9417b725bfe3861872e23a0000c0bf76df18962b161b0b498e21904b44c23f8c\"},\"contracts/interfaces/IInitializeableDynamicProxy.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\ninterface IInitializeableDynamicProxy {\\n    /**\\n        @notice It initializes a new dynamic proxy given a logic registry contract and a logic name.\\n        @param aLogicRegistryAddress the settings contract address.\\n        @param aLogicName the settings contract address.\\n        @param isStrictDynamic Boolean indicating if the proxy must check the registry for a new implementation.\\n     */\\n    function initialize(\\n        address aLogicRegistryAddress,\\n        bytes32 aLogicName,\\n        bool isStrictDynamic\\n    ) external;\\n}\\n\",\"keccak256\":\"0x3cdaee3ca02bad63cc51dbef3ecb71a7e5a52fb36f172dace66f6334ede888e3\"},\"contracts/interfaces/LogicVersionsRegistryInterface.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Commons\\nimport \\\"../util/LogicVersionLib.sol\\\";\\nimport \\\"../util/TellerCommon.sol\\\";\\n\\n/**\\n    @notice It defines all the functions to manage the logic contract versions.\\n\\n    @author develop@teller.finance\\n */\\ninterface LogicVersionsRegistryInterface {\\n    /**\\n        @notice This event is emitted when a new logic version is created.\\n        @param logicName new logic name.\\n        @param logic address where the logic is.\\n        @param version initial version for the logic address.\\n     */\\n    event LogicVersionCreated(\\n        bytes32 indexed logicName,\\n        address indexed logic,\\n        uint256 version\\n    );\\n\\n    /**\\n        @notice This event is emitted when a logic version is rollbacked.\\n        @param logicName the logic name.\\n        @param oldLogic the old logic address.\\n        @param newLogic the new (or previous) logic address.\\n        @param oldVersion the old version.\\n        @param newVersion the new (previous) version.\\n     */\\n    event LogicVersionRollbacked(\\n        bytes32 indexed logicName,\\n        address oldLogic,\\n        address newLogic,\\n        uint256 oldVersion,\\n        uint256 newVersion\\n    );\\n\\n    /**\\n        @notice This event is emitted when a new logic version is upgraded.\\n        @param logicName new logic name.\\n        @param oldLogic the old logic address.\\n        @param newLogic the new logic address.\\n        @param oldVersion the old version.\\n        @param newVersion the new version.\\n     */\\n    event LogicVersionUpgraded(\\n        bytes32 indexed logicName,\\n        address oldLogic,\\n        address newLogic,\\n        uint256 oldVersion,\\n        uint256 newVersion\\n    );\\n\\n    /** External Functions */\\n\\n    /**\\n        @notice It creates multiple logic versions.\\n        @param newLogicVersions lists of the new logic versions to create.\\n     */\\n    function createLogicVersions(\\n        TellerCommon.CreateLogicVersionRequest[] calldata newLogicVersions\\n    ) external;\\n\\n    /**\\n        @notice It upgrades multiple logic addresses.\\n        @param newLogicVersions lists of the new logic versions to create.\\n     */\\n    function upgradeLogicVersions(\\n        TellerCommon.UpgradeLogicVersionRequest[] calldata newLogicVersions\\n    ) external;\\n\\n    /**\\n        @notice It upgrades a logic version given a logic name.\\n        @param logicName logic name to upgrade.\\n        @param newLogic the new logic address to set.\\n        @param proxy The (optional) DynamicUpgradeable proxy address to attempt to directly upgrade.\\n     */\\n    function upgradeLogicVersion(\\n        bytes32 logicName,\\n        address newLogic,\\n        address proxy\\n    ) external;\\n\\n    /**\\n        @notice It rollbacks a logic to a previous version.\\n        @param logicName logic name to rollback.\\n        @param previousVersion the previous version to be used.\\n     */\\n    function rollbackLogicVersion(bytes32 logicName, uint256 previousVersion)\\n        external;\\n\\n    /**\\n        @notice It gets the current logic version for a given logic name.\\n        @param logicName to get.\\n        @return the current logic version.\\n     */\\n    function getLogicVersion(bytes32 logicName)\\n        external\\n        view\\n        returns (\\n            uint256 currentVersion,\\n            uint256 latestVersion,\\n            address logic\\n        );\\n\\n    /**\\n        @notice It tests whether a logic name is already configured.\\n        @param logicName logic name to test.\\n        @return true if the logic version is already configured. Otherwise it returns false.\\n     */\\n    function hasLogicVersion(bytes32 logicName) external view returns (bool);\\n\\n    /**\\n        @notice It initializes this logic versions registry contract instance.\\n        @param aOwner address of the owner of the registry.\\n        @param initialLogicVersions lists of the new logic versions to create.\\n     */\\n    function initialize(\\n        address aOwner,\\n        TellerCommon.CreateLogicVersionRequest[] calldata initialLogicVersions\\n    ) external;\\n}\\n\",\"keccak256\":\"0x7e5eca5bb178277eefa1b09e8a53741fbdddf486ad9805f040ef87aa5b3d0fb0\"},\"contracts/util/LogicVersionLib.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n    @notice This library manages the functions for the logic version struct.\\n\\n    @author develop@teller.finance\\n */\\nlibrary LogicVersionLib {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    /**\\n        @notice It stores all the versions for a given logic.\\n        @param currentVersion the current version.\\n        @param latestVersion the latest version.\\n        @param versions mapping version to logic address.\\n        @param exists boolean to test whether this logic version exists or not.\\n     */\\n    struct LogicVersion {\\n        uint256 currentVersion;\\n        uint256 latestVersion;\\n        mapping(uint256 => address) versions;\\n        bool exists;\\n    }\\n\\n    /**\\n        @notice It creates a new logic version.\\n        @param self the current logic version instance.\\n        @param logic initial logic address.\\n     */\\n    function initialize(LogicVersion storage self, address logic) internal {\\n        requireNotExists(self);\\n        require(logic.isContract(), \\\"LOGIC_MUST_BE_CONTRACT\\\");\\n        self.currentVersion = 0;\\n        self.latestVersion = 0;\\n        self.versions[self.currentVersion] = logic;\\n        self.exists = true;\\n    }\\n\\n    /**\\n        @notice It rollbacks a logic to a previous version.\\n        @param self the current logic version instance.\\n        @param previousVersion the previous version to be used.\\n     */\\n    function rollback(LogicVersion storage self, uint256 previousVersion)\\n        internal\\n        returns (\\n            uint256 currentVersion,\\n            address previousLogic,\\n            address newLogic\\n        )\\n    {\\n        requireExists(self);\\n        require(\\n            self.currentVersion != previousVersion,\\n            \\\"CURRENT_VERSION_MUST_BE_DIFF\\\"\\n        );\\n        require(\\n            self.latestVersion >= previousVersion,\\n            \\\"VERSION_MUST_BE_LTE_LATEST\\\"\\n        );\\n        currentVersion = self.currentVersion;\\n        previousLogic = self.versions[self.currentVersion];\\n        newLogic = self.versions[previousVersion];\\n\\n        self.currentVersion = previousVersion;\\n    }\\n\\n    /**\\n        @notice Checks whether the current logic version exists or not.\\n        @dev It throws a require error if the logic version already exists.\\n        @param self the current logic version.\\n     */\\n    function requireNotExists(LogicVersion storage self) internal view {\\n        require(!self.exists, \\\"LOGIC_ALREADY_EXISTS\\\");\\n    }\\n\\n    /**\\n        @notice Checks whether the current logic version exists or not.\\n        @dev It throws a require error if the current logic version doesn't exist.\\n        @param self the current logic version.\\n     */\\n    function requireExists(LogicVersion storage self) internal view {\\n        require(self.exists, \\\"LOGIC_NOT_EXISTS\\\");\\n    }\\n\\n    /**\\n        @notice It upgrades a logic version.\\n        @dev It throws a require error if:\\n            - The new logic is equal to the current logic.\\n        @param self the current logic version.\\n        @param newLogic the new logic to set in the logic version.\\n        @return oldLogic the old logic address.\\n        @return oldVersion the old version.\\n        @return newVersion the new version.\\n     */\\n    function upgrade(LogicVersion storage self, address newLogic)\\n        internal\\n        returns (\\n            address oldLogic,\\n            uint256 oldVersion,\\n            uint256 newVersion\\n        )\\n    {\\n        requireExists(self);\\n        require(\\n            self.versions[self.currentVersion] != newLogic,\\n            \\\"NEW_LOGIC_REQUIRED\\\"\\n        );\\n        require(newLogic.isContract(), \\\"LOGIC_MUST_BE_CONTRACT\\\");\\n        oldLogic = self.versions[self.currentVersion];\\n        oldVersion = self.currentVersion;\\n        newVersion = self.latestVersion.add(1);\\n\\n        self.currentVersion = newVersion;\\n        self.latestVersion = newVersion;\\n        self.versions[newVersion] = newLogic;\\n    }\\n}\\n\",\"keccak256\":\"0x51867a2eb496907d3017725a79ab887bf562eb13c6238e88d721348a1902c3d6\"},\"contracts/util/NumbersLib.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Utility library for uint256 numbers\\n *\\n * @author develop@teller.finance\\n */\\nlibrary NumbersLib {\\n    using SafeMath for uint256;\\n\\n    // It represents 100% with 2 decimal places.\\n    function ONE_HUNDRED_PERCENT() internal pure returns (uint256) {\\n        return 10000;\\n    }\\n\\n    /**\\n        @notice Returns the positive difference value of a number to another number\\n        @param self The number to return the difference value for\\n        @param other The other number to calucualte the difference against\\n        @return uint256 The difference value\\n     */\\n    function diff(uint256 self, uint256 other) internal pure returns (uint256) {\\n        return other > self ? other.sub(self) : self.sub(other);\\n    }\\n\\n    /**\\n        @notice Returns the positive percentage difference of a value to 100%\\n        @param self The number to return the percentage difference for\\n        @return uint256 The percentage difference value\\n     */\\n    function diffOneHundredPercent(uint256 self) internal pure returns (uint256) {\\n        return diff(self, ONE_HUNDRED_PERCENT());\\n    }\\n\\n    /**\\n     * @notice Returns a percentage value of a number.\\n     * @param self The number to get a percentage of.\\n     * @param percentage The percentage value to calculate with 2 decimal places (10000 = 100%).\\n     */\\n    function percent(uint256 self, uint256 percentage) internal pure returns (uint256) {\\n        return self.mul(percentage).div(ONE_HUNDRED_PERCENT());\\n    }\\n\\n    function percent(int256 self, uint256 percentage) internal pure returns (int256) {\\n        return (self * int256(percentage)) / int256(ONE_HUNDRED_PERCENT());\\n    }\\n\\n    function abs(int256 self) internal pure returns (uint256) {\\n        return self >= 0 ? uint256(self) : uint256(-1 * self);\\n    }\\n\\n    /**\\n     * @notice Returns a ratio of 2 numbers.\\n     * @param self The number to get a ratio of.\\n     * @param num The number to calculate the ratio for.\\n     * @return Ratio of 2 numbers with 2 decimal places (10000 = 100%).\\n     */\\n    function ratioOf(uint256 self, uint256 num) internal pure returns (uint256) {\\n        return self.mul(ONE_HUNDRED_PERCENT()).div(num);\\n    }\\n}\\n\",\"keccak256\":\"0xaa858071cda31070104f3ad479213c5fa4d898568823c98b18de60cb1c097c21\"},\"contracts/util/NumbersList.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"./NumbersLib.sol\\\";\\n\\n/**\\n * @dev Utility library of inline functions on NumbersList.Values\\n *\\n * @author develop@teller.finance\\n */\\nlibrary NumbersList {\\n    using SafeMath for uint256;\\n    using NumbersLib for uint256;\\n\\n    // Holds values to calculate the threshold of a list of numbers\\n    struct Values {\\n        uint256 count; // The total number of numbers added\\n        uint256 max; // The maximum number that was added\\n        uint256 min; // The minimum number that was added\\n        uint256 sum; // The total sum of the numbers that were added\\n    }\\n\\n    /**\\n     * @dev Add to the sum while keeping track of min and max values\\n     * @param self The Value this function was called on\\n     * @param newValue Number to increment sum by\\n     */\\n    function addValue(Values memory self, uint256 newValue) internal pure {\\n        if (self.max < newValue) {\\n            self.max = newValue;\\n        }\\n        if (self.min > newValue || self.count == 0) {\\n            self.min = newValue;\\n        }\\n        self.sum = self.sum.add(newValue);\\n        self.count = self.count.add(1);\\n    }\\n\\n    /**\\n     * @param self The Value this function was called on\\n     * @return the number of times the sum has updated\\n     */\\n    function valuesCount(Values memory self) internal pure returns (uint256) {\\n        return self.count;\\n    }\\n\\n    /**\\n     * @dev Checks if the sum has been changed\\n     * @param self The Value this function was called on\\n     * @return boolean\\n     */\\n    function isEmpty(Values memory self) internal pure returns (bool) {\\n        return valuesCount(self) == 0;\\n    }\\n\\n    /**\\n     * @param self The Value this function was called on\\n     * @return the average number that was used to calculate the sum\\n     */\\n    function getAverage(Values memory self) internal pure returns (uint256) {\\n        return isEmpty(self) ? 0 : self.sum.div(valuesCount(self));\\n    }\\n\\n    /**\\n     * @dev Checks if the min and max numbers are within the acceptable tolerance\\n     * @param self The Value this function was called on\\n     * @param tolerancePercentage Acceptable tolerance percentage as a whole number\\n     * The percentage should be entered with 2 decimal places. e.g. 2.5% should be entered as 250.\\n     * @return boolean\\n     */\\n    function isWithinTolerance(Values memory self, uint256 tolerancePercentage)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (isEmpty(self)) {\\n            return false;\\n        }\\n        uint256 average = getAverage(self);\\n        uint256 toleranceAmount = average.percent(tolerancePercentage);\\n\\n        uint256 minTolerance = average.sub(toleranceAmount);\\n        if (self.min < minTolerance) {\\n            return false;\\n        }\\n\\n        uint256 maxTolerance = average.add(toleranceAmount);\\n        if (self.max > maxTolerance) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x983a4fe98db91ca209b4908b7ff552f5a3ccd4e449db7b92387f5ce752908adb\"},\"contracts/util/TellerCommon.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./NumbersList.sol\\\";\\n\\n/**\\n * @dev Library of structs common across the Teller protocol\\n *\\n * @author develop@teller.finance\\n */\\nlibrary TellerCommon {\\n    enum LoanStatus { NonExistent, TermsSet, Active, Closed }\\n\\n    /**\\n        @notice Represents a user signature\\n        @param v The recovery identifier represented by the last byte of a ECDSA signature as an int\\n        @param r The random point x-coordinate of the signature respresented by the first 32 bytes of the generated ECDSA signature\\n        @param s The signature proof represented by the second 32 bytes of the generated ECDSA signature\\n     */\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /**\\n        @notice Borrower request object to take out a loan\\n        @param borrower The wallet address of the borrower\\n        @param recipient The address where funds will be sent, only applicable in over collateralized loans\\n        @param consensusAddress The address of the Teller loan consensus contract to which the request should be sent\\n        @param requestNonce The nonce of the borrower wallet address required for authentication\\n        @param amount The amount of tokens requested by the borrower for the loan\\n        @param duration The length of time in seconds that the loan has been requested for\\n        @param requestTime The timestamp at which the loan was requested\\n     */\\n    struct LoanRequest {\\n        address payable borrower;\\n        address recipient;\\n        address consensusAddress;\\n        uint256 requestNonce;\\n        uint256 amount;\\n        uint256 duration;\\n        uint256 requestTime;\\n    }\\n\\n    /**\\n        @notice Borrower response object to take out a loan\\n        @param signer The wallet address of the signer validating the interest request of the lender\\n        @param consensusAddress The address of the Teller loan consensus contract to which the request should be sent\\n        @param responseTime The timestamp at which the response was sent\\n        @param interestRate The signed interest rate generated by the signer's Credit Risk Algorithm (CRA)\\n        @param collateralRatio The ratio of collateral to loan amount that is generated by the signer's Credit Risk Algorithm (CRA)\\n        @param maxLoanAmount The largest amount of tokens that can be taken out in the loan by the borrower\\n        @param signature The signature generated by the signer in the format of the above Signature struct\\n     */\\n    struct LoanResponse {\\n        address signer;\\n        address consensusAddress;\\n        uint256 responseTime;\\n        uint256 interestRate;\\n        uint256 collateralRatio;\\n        uint256 maxLoanAmount;\\n        Signature signature;\\n    }\\n\\n    /**\\n        @notice Represents loan terms based on consensus values\\n        @param interestRate The consensus value for the interest rate based on all the loan responses from the signers\\n        @param collateralRatio The consensus value for the ratio of collateral to loan amount required for the loan, based on all the loan responses from the signers\\n        @param maxLoanAmount The consensus value for the largest amount of tokens that can be taken out in the loan, based on all the loan responses from the signers\\n     */\\n    struct AccruedLoanTerms {\\n        NumbersList.Values interestRate;\\n        NumbersList.Values collateralRatio;\\n        NumbersList.Values maxLoanAmount;\\n    }\\n\\n    /**\\n        @notice Represents the terms of a loan based on the consensus of a LoanRequest\\n        @param borrower The wallet address of the borrower\\n        @param recipient The address where funds will be sent, only applicable in over collateralized loans\\n        @param interestRate The consensus interest rate calculated based on all signer loan responses\\n        @param collateralRatio The consensus ratio of collateral to loan amount calculated based on all signer loan responses\\n        @param maxLoanAmount The consensus largest amount of tokens that can be taken out in the loan by the borrower, calculated based on all signer loan responses\\n        @param duration The consensus length of loan time, calculated based on all signer loan responses\\n     */\\n    struct LoanTerms {\\n        address payable borrower;\\n        address recipient;\\n        uint256 interestRate;\\n        uint256 collateralRatio;\\n        uint256 maxLoanAmount;\\n        uint256 duration;\\n    }\\n\\n    /**\\n        @notice Data per borrow as struct\\n        @param id The id of the loan for internal tracking\\n        @param loanTerms The loan terms returned by the signers\\n        @param termsExpiry The timestamp at which the loan terms expire, after which if the loan is not yet active, cannot be taken out\\n        @param loanStartTime The timestamp at which the loan became active\\n        @param collateral The total amount of collateral deposited by the borrower to secure the loan\\n        @param lastCollateralIn The amount of collateral that was last deposited by the borrower to keep the loan active\\n        @param principalOwed The total amount of the loan taken out by the borrower, reduces on loan repayments\\n        @param interestOwed The total interest owed by the borrower for the loan, reduces on loan repayments\\n        @param borrowedAmount The total amount of the loan size taken out\\n        @param escrow The address of the escrow contract that holds the funds taken out in the loan on behalf of the borrower\\n        @param status The status of the loan currently based on the LoanStatus enum - NonExistent, TermsSet, Active, Closed\\n        @param liquidated Flag marking if the loan has been liquidated or not\\n     */\\n    struct Loan {\\n        uint256 id;\\n        LoanTerms loanTerms;\\n        uint256 termsExpiry;\\n        uint256 loanStartTime;\\n        uint256 collateral;\\n        uint256 lastCollateralIn;\\n        uint256 principalOwed;\\n        uint256 interestOwed;\\n        uint256 borrowedAmount;\\n        address escrow;\\n        LoanStatus status;\\n        bool liquidated;\\n    }\\n\\n    /**\\n        @notice This struct defines the dapp address and data to execute in the callDapp function.\\n        @dev It is executed using a delegatecall in the Escrow contract.\\n        @param exists Flag marking whether the dapp is a Teller registered address\\n        @param unsecured Flag marking if the loan allowed to be used in the dapp is a secured, or unsecured loan\\n     */\\n    struct Dapp {\\n        bool exists;\\n        bool unsecured;\\n    }\\n\\n    /**\\n        @notice This struct defines the dapp address and data to execute in the callDapp function.\\n        @dev It is executed using a delegatecall in the Escrow contract.\\n        @param location The proxy contract address for the dapp that will be used by the Escrow contract delegatecall\\n        @param data The encoded function signature with parameters for the dapp method in bytes that will be sent in the Escrow delegatecall\\n     */\\n    struct DappData {\\n        address location;\\n        bytes data;\\n    }\\n\\n    /**\\n        @notice This struct defines a market in the platform.\\n        @dev It is used by the MarketFactory contract.\\n        @param loans The address for the Teller LoanManager contract that is being used for a market\\n        @param lendingPool The address for the Teller Lending Pool contract that is being used for a market\\n        @param loanTermsConsensus The address for the Teller Loan Terms Consensus contract that is being used for a market\\n        @param exists Flag marking if the market is defined on the platform or not\\n     */\\n    struct Market {\\n        address loans;\\n        address lendingPool;\\n        address loanTermsConsensus;\\n        bool exists;\\n    }\\n\\n    /**\\n        @notice This struct is used to register new logic versions.\\n        @param logic The address for the new contract holding the logic.\\n        @param logicName The name for the logic to be stored as.\\n     */\\n    struct CreateLogicVersionRequest {\\n        address logic;\\n        bytes32 logicName;\\n    }\\n\\n    /**\\n        @notice This struct is used to upgrade logic versions.\\n        @param logic The new logic address to upgrade proxy to.\\n        @param logicName The name for the logic to be stored as.\\n        @param proxy The (optional) DynamicUpgradeable proxy address to attempt to directly upgrade.\\n     */\\n    struct UpgradeLogicVersionRequest {\\n        address logic;\\n        bytes32 logicName;\\n        address proxy;\\n    }\\n}\\n\",\"keccak256\":\"0x15adc0f2cf2cb637c3821da7710fa609e05ae973629bb78e3747b3814324222b\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061050c806100206000396000f3fe6080604052600436106100705760003560e01c806355dbd8eb1161004e57806355dbd8eb146100dc5780635c60da1b146100fc578063e154e9a414610111578063e72fcb601461013357610070565b80632c26486d1461007a57806337c3eedc146100a55780634f8654bc146100c7575b610078610153565b005b34801561008657600080fd5b5061008f61016d565b60405161009c919061044c565b60405180910390f35b3480156100b157600080fd5b506100ba610173565b60405161009c919061042d565b3480156100d357600080fd5b506100ba610182565b3480156100e857600080fd5b506100786100f7366004610398565b610196565b34801561010857600080fd5b506100ba6101f5565b34801561011d57600080fd5b50610126610204565b60405161009c9190610441565b34801561013f57600080fd5b5061007861014e3660046103bb565b61020d565b61015b610271565b61016b610166610295565b6102a9565b565b60015481565b6000546001600160a01b031681565b60025461010090046001600160a01b031681565b6000546001600160a01b031633146101c95760405162461bcd60e51b81526004016101c090610481565b60405180910390fd5b600280546001600160a01b0390921661010002610100600160a81b031990921691909117905543600355565b60006101ff610295565b905090565b60025460ff1681565b6000546001600160a01b0316156102365760405162461bcd60e51b81526004016101c090610455565b600080546001600160a01b0319166001600160a01b03851617905560018290556002805460ff191682151517905561026c6102cd565b505050565b60025460ff16801561028857504360035460320111155b1561016b5761016b6102cd565b60025461010090046001600160a01b031690565b3660008037600080366000845af43d6000803e8080156102c8573d6000f35b3d6000fd5b60008054600154604051638b51f58b60e01b81526001600160a01b0390921691638b51f58b916102ff9160040161044c565b60606040518083038186803b15801561031757600080fd5b505afa15801561032b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525061034f9190810190610400565b6002549093506001600160a01b038085166101009092041614915061039190505760028054610100600160a81b0319166101006001600160a01b038416021790555b5043600355565b6000602082840312156103a9578081fd5b81356103b4816104b1565b9392505050565b6000806000606084860312156103cf578182fd5b83356103da816104b1565b925060208401359150604084013580151581146103f5578182fd5b809150509250925092565b600080600060608486031215610414578283fd5b835192506020840151915060408401516103f5816104b1565b6001600160a01b0391909116815260200190565b901515815260200190565b90815260200190565b602080825260129082015271141493d61657d053149150511657d253925560721b604082015260600190565b6020808252601690820152754d5553545f42455f4c4f4749435f524547495354525960501b604082015260600190565b6001600160a01b03811681146104c657600080fd5b5056fea365627a7a7231582077afba55674a3f600bb17b9b8debfcb68d093bee51c8f9e0eeed98915b75fb266c6578706572696d656e74616cf564736f6c63430005110040",
  "deployedBytecode": "0x6080604052600436106100705760003560e01c806355dbd8eb1161004e57806355dbd8eb146100dc5780635c60da1b146100fc578063e154e9a414610111578063e72fcb601461013357610070565b80632c26486d1461007a57806337c3eedc146100a55780634f8654bc146100c7575b610078610153565b005b34801561008657600080fd5b5061008f61016d565b60405161009c919061044c565b60405180910390f35b3480156100b157600080fd5b506100ba610173565b60405161009c919061042d565b3480156100d357600080fd5b506100ba610182565b3480156100e857600080fd5b506100786100f7366004610398565b610196565b34801561010857600080fd5b506100ba6101f5565b34801561011d57600080fd5b50610126610204565b60405161009c9190610441565b34801561013f57600080fd5b5061007861014e3660046103bb565b61020d565b61015b610271565b61016b610166610295565b6102a9565b565b60015481565b6000546001600160a01b031681565b60025461010090046001600160a01b031681565b6000546001600160a01b031633146101c95760405162461bcd60e51b81526004016101c090610481565b60405180910390fd5b600280546001600160a01b0390921661010002610100600160a81b031990921691909117905543600355565b60006101ff610295565b905090565b60025460ff1681565b6000546001600160a01b0316156102365760405162461bcd60e51b81526004016101c090610455565b600080546001600160a01b0319166001600160a01b03851617905560018290556002805460ff191682151517905561026c6102cd565b505050565b60025460ff16801561028857504360035460320111155b1561016b5761016b6102cd565b60025461010090046001600160a01b031690565b3660008037600080366000845af43d6000803e8080156102c8573d6000f35b3d6000fd5b60008054600154604051638b51f58b60e01b81526001600160a01b0390921691638b51f58b916102ff9160040161044c565b60606040518083038186803b15801561031757600080fd5b505afa15801561032b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525061034f9190810190610400565b6002549093506001600160a01b038085166101009092041614915061039190505760028054610100600160a81b0319166101006001600160a01b038416021790555b5043600355565b6000602082840312156103a9578081fd5b81356103b4816104b1565b9392505050565b6000806000606084860312156103cf578182fd5b83356103da816104b1565b925060208401359150604084013580151581146103f5578182fd5b809150509250925092565b600080600060608486031215610414578283fd5b835192506020840151915060408401516103f5816104b1565b6001600160a01b0391909116815260200190565b901515815260200190565b90815260200190565b602080825260129082015271141493d61657d053149150511657d253925560721b604082015260600190565b6020808252601690820152754d5553545f42455f4c4f4749435f524547495354525960501b604082015260600190565b6001600160a01b03811681146104c657600080fd5b5056fea365627a7a7231582077afba55674a3f600bb17b9b8debfcb68d093bee51c8f9e0eeed98915b75fb266c6578706572696d656e74616cf564736f6c63430005110040",
  "devdoc": {
    "author": "develop@teller.finance",
    "methods": {
      "implementation()": {
        "return": "Address of the current implementation"
      },
      "initialize(address,bytes32,bool)": {
        "params": {
          "aLogicName": "the settings contract address.",
          "aLogicRegistryAddress": "the settings contract address.",
          "isStrictDynamic": "Boolean indicating if the proxy must check the registry for a new implementation."
        }
      }
    }
  },
  "userdoc": {
    "methods": {
      "implementation()": {
        "notice": "Returns the current implementation."
      },
      "initialize(address,bytes32,bool)": {
        "notice": "It initializes a new dynamic proxy given a logic registry contract and a logic name."
      }
    },
    "notice": "It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.It extends BaseUpgradeable to get access to the settings."
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11226,
        "contract": "contracts/base/proxies/InitializeableDynamicProxy.sol:InitializeableDynamicProxy",
        "label": "logicRegistry",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(LogicVersionsRegistryInterface)11867"
      },
      {
        "astId": 11228,
        "contract": "contracts/base/proxies/InitializeableDynamicProxy.sol:InitializeableDynamicProxy",
        "label": "logicName",
        "offset": 0,
        "slot": "1",
        "type": "t_bytes32"
      },
      {
        "astId": 11230,
        "contract": "contracts/base/proxies/InitializeableDynamicProxy.sol:InitializeableDynamicProxy",
        "label": "strictDynamic",
        "offset": 0,
        "slot": "2",
        "type": "t_bool"
      },
      {
        "astId": 11232,
        "contract": "contracts/base/proxies/InitializeableDynamicProxy.sol:InitializeableDynamicProxy",
        "label": "implementationStored",
        "offset": 1,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 11234,
        "contract": "contracts/base/proxies/InitializeableDynamicProxy.sol:InitializeableDynamicProxy",
        "label": "_implementationBlockUpdated",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(LogicVersionsRegistryInterface)11867": {
        "encoding": "inplace",
        "label": "contract LogicVersionsRegistryInterface",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}
