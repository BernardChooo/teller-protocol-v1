{
  "language": "Solidity",
  "sources": {
    "contracts/base/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n// Commons\n\n// Interfaces\nimport \"../interfaces/SettingsInterface.sol\";\n\n// Contracts\nimport \"./upgradeable/DynamicUpgradeable.sol\";\nimport \"./BaseStorage.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\n/**  contract that this contract inherits from                                                      **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract is used as a base contract for most most of the contracts in the platform.\n    @notice It allows contracts to have access to the platform settings, and common modifiers.\n\n    @author develop@teller.finance.\n */\ncontract Base is DynamicUpgradeable, BaseStorage {\n    using AddressLib for address;\n    using Address for address;\n\n    /** Modifiers */\n\n    /**\n          @notice Checks if sender has a pauser role\n          @dev Throws an error if the sender has not a pauser role.\n       */\n    modifier onlyPauser() virtual {\n        settings.requirePauserRole(msg.sender);\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        settings.requireAuthorization(msg.sender);\n        _;\n    }\n\n    /**\n    @notice Checks whether the platform is paused or not.\n    @dev It throws a require error if platform is paused.\n */\n    modifier whenNotPaused() virtual {\n        require(!_isPaused(), \"PLATFORM_IS_PAUSED\");\n        _;\n    }\n\n    /**\n        @notice Checks whether a specific lending pool address is paused or not.\n        @dev It throws a require error if the lending pool is paused.\n        @param lendingPoolAddress lending pool address to check.\n     */\n    modifier whenLendingPoolNotPaused(address lendingPoolAddress) {\n        require(!_isPoolPaused(lendingPoolAddress), \"LENDING_POOL_IS_PAUSED\");\n        _;\n    }\n\n    /* Constructor */\n\n    /** External Functions */\n\n    /** Internal functions */\n\n    /**\n        @notice It initializes the current contract instance setting the required parameters.\n        @param settingsAddress settings contract address.\n     */\n    function _initialize(address settingsAddress) internal {\n        settingsAddress.requireNotEmpty(\"SETTINGS_MUST_BE_PROVIDED\");\n\n        settings = SettingsInterface(settingsAddress);\n    }\n\n    /**\n        @notice Checks if a specific lending pool address is paused or not.\n        @param poolAddress lending pool address to check.\n        @return true if the lending pool address is  paused. Otherwise it returns false.\n     */\n    function _isPoolPaused(address poolAddress) internal view returns (bool) {\n        return settings.lendingPoolPaused(poolAddress);\n    }\n\n    /**\n        @notice Checks if the platform is paused or not.\n        @return true if platform is paused. Otherwise it returns false.\n     */\n    function _isPaused() internal view returns (bool) {\n        return settings.isPaused();\n    }\n\n    /** Private functions */\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/SettingsInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"../util/PlatformSettingsLib.sol\";\n\n// Interfaces\nimport \"./IDappRegistry.sol\";\nimport \"./IPriceAggregator.sol\";\nimport \"./AssetSettingsInterface.sol\";\nimport \"./IMarketFactory.sol\";\n\n/**\n    @notice This interface defines all function to manage the platform configuration.\n\n    @author develop@teller.finance\n */\ninterface SettingsInterface {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    /**\n        @notice This event is emitted when a new platform setting is created.\n        @param settingName new setting name.\n        @param sender address that created it.\n        @param value value for the new setting.\n     */\n    event PlatformSettingCreated(\n        bytes32 indexed settingName,\n        address indexed sender,\n        uint256 value,\n        uint256 minValue,\n        uint256 maxValue\n    );\n\n    /**\n        @notice This event is emitted when a current platform setting is removed.\n        @param settingName setting name removed.\n        @param sender address that removed it.\n     */\n    event PlatformSettingRemoved(\n        bytes32 indexed settingName,\n        uint256 lastValue,\n        address indexed sender\n    );\n\n    /**\n        @notice This event is emitted when a platform setting is updated.\n        @param settingName settings name updated.\n        @param sender address that updated it.\n        @param oldValue old value for the setting.\n        @param newValue new value for the setting.\n     */\n    event PlatformSettingUpdated(\n        bytes32 indexed settingName,\n        address indexed sender,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n        @notice This event is emitted when a lending pool is paused.\n        @param account address that paused the lending pool.\n        @param lendingPoolAddress lending pool address which was paused.\n     */\n    event LendingPoolPaused(\n        address indexed account,\n        address indexed lendingPoolAddress\n    );\n\n    /**\n        @notice This event is emitted when a lending pool is unpaused.\n        @param account address that paused the lending pool.\n        @param lendingPoolAddress lending pool address which was unpaused.\n     */\n    event LendingPoolUnpaused(\n        address indexed account,\n        address indexed lendingPoolAddress\n    );\n\n    /**\n        @notice This event is emitted when the platform restriction is switched\n        @param restriction Boolean representing the state of the restriction\n        @param pauser address of the pauser flipping the switch\n    */\n    event PlatformRestricted(bool restriction, address indexed pauser);\n\n    /**\n        @notice This event is emitted when an address is given authorization\n        @param user The address being authorized\n        @param pauser address of the pauser adding the address\n    */\n    event AuthorizationGranted(address indexed user, address indexed pauser);\n\n    /**\n        @notice This event is emitted when an address has authorization revoked\n        @param user The address being revoked\n        @param pauser address of the pauser removing the address\n    */\n    event AuthorizationRevoked(address indexed user, address indexed pauser);\n\n    /**\n        @notice It creates a new platform setting given a setting name, value, min and max values.\n        @param settingName setting name to create.\n        @param value the initial value for the given setting name.\n        @param minValue the min value for the setting.\n        @param maxValue the max value for the setting.\n     */\n    function createPlatformSetting(\n        bytes32 settingName,\n        uint256 value,\n        uint256 minValue,\n        uint256 maxValue\n    ) external;\n\n    function assetSettings() external view returns (AssetSettingsInterface);\n\n    /**\n     * @notice It holds the address of a deployed InitializeableDynamicProxy contract.\n     * @dev It is used to deploy a new proxy contract with minimal gas cost using the logic in the Factory contract.\n     */\n    function initDynamicProxyLogic() external view returns (address);\n\n    /**\n        @notice It updates an existent platform setting given a setting name.\n        @notice It only allows to update the value (not the min or max values).\n        @notice In case you need to update the min or max values, you need to remove it, and create it again.\n        @param settingName setting name to update.\n        @param newValue the new value to set.\n     */\n    function updatePlatformSetting(bytes32 settingName, uint256 newValue)\n        external;\n\n    /**\n        @notice Removes a current platform setting given a setting name.\n        @param settingName to remove.\n     */\n    function removePlatformSetting(bytes32 settingName) external;\n\n    /**\n        @notice It gets the current \"RequiredSubmissionsPercentage\" setting's value\n        @return value the current value.\n     */\n    function getRequiredSubmissionsPercentageValue()\n        external\n        view\n        returns (uint256 value);\n\n    /**\n        @notice It gets the current \"MaximumTolerance\" setting's value\n        @return value the current value.\n     */\n    function getMaximumToleranceValue() external view returns (uint256 value);\n\n    /**\n        @notice It gets the current \"ResponseExpiryLength\" setting's value\n        @return value the current value.\n     */\n    function getResponseExpiryLengthValue()\n        external\n        view\n        returns (uint256 value);\n\n    /**\n        @notice It gets the current \"SafetyInterval\" setting's value\n        @return value the current value.\n     */\n    function getSafetyIntervalValue() external view returns (uint256 value);\n\n    /**\n        @notice It gets the current \"TermsExpiryTime\" setting's value\n        @return value the current value.\n     */\n    function getTermsExpiryTimeValue() external view returns (uint256 value);\n\n    /**\n        @notice It gets the current \"LiquidateEthPrice\" setting's value\n        @return value the current value.\n     */\n    function getLiquidateEthPriceValue() external view returns (uint256 value);\n\n    /**\n        @notice It gets the current \"MaximumLoanDuration\" setting's value\n        @return value the current value.\n     */\n    function getMaximumLoanDurationValue()\n        external\n        view\n        returns (uint256 value);\n\n    /**\n        @notice It gets the current \"RequestLoanTermsRateLimit\" setting's value\n        @return value the current value.\n     */\n    function getRequestLoanTermsRateLimitValue()\n        external\n        view\n        returns (uint256 value);\n\n    /**\n        @notice It gets the current \"CollateralBuffer\" setting's value\n        @return value the current value.\n     */\n    function getCollateralBufferValue() external view returns (uint256 value);\n\n    /**\n        @notice It gets the current \"OverCollateralizedBuffer\" setting's value\n        @return value the current value.\n     */\n    function getOverCollateralizedBufferValue()\n        external\n        view\n        returns (uint256 value);\n\n    /**\n     * @notice It returns the address of the UniswapV2Router.\n     */\n    function getUniswapV2RouterAddress() external view returns (address);\n\n    /**\n        @notice It tests whether a setting name is already configured.\n        @param settingName setting name to test.\n        @return true if the setting is already configured. Otherwise it returns false.\n     */\n    function hasPlatformSetting(bytes32 settingName)\n        external\n        view\n        returns (bool);\n\n    /**\n        @notice It gets whether the platform is paused or not.\n        @return true if platform is paused. Otherwise it returns false.\n     */\n    function isPaused() external view returns (bool);\n\n    /**\n        @notice It gets whether a lending pool is paused or not.\n        @param lendingPoolAddress lending pool address to test.\n        @return true if the lending pool is paused. Otherwise it returns false.\n     */\n    function lendingPoolPaused(address lendingPoolAddress)\n        external\n        view\n        returns (bool);\n\n    /**\n        @notice It pauses a specific lending pool.\n        @param lendingPoolAddress lending pool address to pause.\n     */\n    function pauseLendingPool(address lendingPoolAddress) external;\n\n    /**\n        @notice It unpauses a specific lending pool.\n        @param lendingPoolAddress lending pool address to unpause.\n     */\n    function unpauseLendingPool(address lendingPoolAddress) external;\n\n    function platformSettings(bytes32)\n        external\n        view\n        returns (PlatformSettingsLib.PlatformSetting memory);\n\n    /**\n        @notice Tests whether an account has the pauser role.\n        @param account account to test.\n        @return true if account has the pauser role. Otherwise it returns false.\n     */\n    function isPauser(address account) external view returns (bool);\n\n    /**\n        @notice Requires an account to have the pauser role.\n        @param account account to test.\n     */\n    function requirePauserRole(address account) external view;\n\n    /**\n        @notice Restricts the use of the Teller protocol to authorized wallet addresses only\n        @param restriction Bool turning the resitriction on or off\n     */\n    function restrictPlatform(bool restriction) external;\n\n    /**\n        @notice Adds a wallet address to the list of authorized wallets\n        @param addressToAdd The wallet address of the user being authorized\n     */\n    function addAuthorizedAddress(address addressToAdd) external;\n\n    /**\n        @notice Adds a list of wallet addresses to the list of authorized wallets\n        @param addressesToAdd The list of wallet addresses being authorized\n     */\n    function addAuthorizedAddressList(address[] calldata addressesToAdd)\n        external;\n\n    function addEscrowAuthorized(address escrowAddress) external;\n\n    /**\n        @notice Returns whether the platform is restricted or not\n        @return bool True if the platform is restricted, false if not\n     */\n    function isPlatformRestricted() external view returns (bool);\n\n    /**\n        @notice Tests whether an account has authorization\n        @param account The account address to check for\n        @return True if account has authorization, false if it does not\n     */\n    function hasAuthorization(address account) external view returns (bool);\n\n    /**\n        @notice Requires an account to have platform authorization.\n        @param account account to test.\n     */\n    function requireAuthorization(address account) external view;\n\n    /**\n        @notice Removes a wallet address from the list of authorized wallets\n        @param addressToRemove The wallet address of the user being unauthorized\n     */\n    function removeAuthorizedAddress(address addressToRemove) external;\n\n    /**\n        @notice It is the global instance of the DappRegistry contract.\n     */\n    function dappRegistry() external view returns (IDappRegistry);\n\n    /**\n        @notice It is the global instance of the PriceAggregator contract.\n     */\n    function priceAggregator() external view returns (IPriceAggregator);\n\n    /**\n        @notice It is the global instance of the MarketFactory contract.\n     */\n    function marketFactory() external view returns (IMarketFactory);\n\n    /**\n        @notice Gets the cToken address for a given asset address.\n        @param assetAddress token address.\n        @return the cToken address for a given asset address.\n     */\n    function getCTokenAddress(address assetAddress)\n        external\n        view\n        returns (address);\n\n    /**\n        @notice It initializes this settings contract instance.\n        @param wethTokenAddress canonical WETH token address.\n        @param cethTokenAddress compound CETH token address.\n        @param initDynamicProxyAddress Address of a deployed InitializeableDynamicProxy contract.\n        @param uniswapV2RouterAddress Address of the UniswapV2Router instance to use for the platform.\n     */\n    function initialize(\n        address wethTokenAddress,\n        address cethTokenAddress,\n        address initDynamicProxyAddress,\n        address uniswapV2RouterAddress\n    ) external;\n\n    /**\n        @notice It gets the ETH address used in the platform.\n        @return the ETH address used in the platform.\n     */\n    function ETH_ADDRESS() external view returns (address);\n\n    /**\n        @notice It gets the canonical WETH address used in the platform.\n        @return the canonical WETH address used in the platform.\n     */\n    function WETH_ADDRESS() external view returns (address);\n\n    /**\n        @notice It gets the canonical CETH address used in the platform.\n        @return the canonical CETH address used in the platform.\n     */\n    function CETH_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/base/upgradeable/DynamicUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"./DynamicUpgradeableStorage.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\n/**  contract that this contract inherits from                                                      **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract is used define the DynamicUpgradeable contracts logic.\n *\n * @author develop@teller.finance\n */\ncontract DynamicUpgradeable is DynamicUpgradeableStorage {\n    /* Modifiers */\n\n    /**\n     * @notice It checks if the proxy's implementation cache is invalidated and should be updated.\n     * @dev Any external, non-view function should use this modifier.\n     * @dev This modifier should be the very FIRST modifier for functions.\n     */\n    modifier updateImpIfNeeded() {\n        if (_cacheInvalidated()) {\n            _updateImplementationStored();\n        }\n        _;\n    }\n\n    /* External Functions */\n\n    /**\n     * @notice It updates a proxy's cached implementation address.\n     * @notice It must only be called by the LogicVersionsRegistry for non strict DynamicProxy\n     */\n    function upgradeProxyTo(address newImplementation) public {\n        require(msg.sender == address(logicRegistry), \"MUST_BE_LOGIC_REGISTRY\");\n        implementationStored = newImplementation;\n        _implementationBlockUpdated = block.number;\n    }\n\n    /* Internal Functions **/\n\n    /**\n     * @notice Returns the current implementation used by the proxy to delegate a call to.\n     * @return address of the current implementation\n     */\n    function _implementation() internal view virtual returns (address) {\n        if (_cacheInvalidated()) {\n            (, , address currentLogic) =\n                logicRegistry.getLogicVersion(logicName);\n            return currentLogic;\n        }\n        return implementationStored;\n    }\n\n    /**\n     * @notice Updates the current implementation logic address for the stored logic name.\n     * @dev It uses the LogicVersionsRegistry contract to get the logic address or the cached address if valid.\n     * @dev It caches the current logic address for the proxy to reduce gas on subsequent calls within the same block.\n     */\n    function _updateImplementationStored() public {\n        (, , address currentLogic) = logicRegistry.getLogicVersion(logicName);\n\n        if (implementationStored != currentLogic) {\n            implementationStored = currentLogic;\n        }\n        _implementationBlockUpdated = block.number;\n    }\n\n    /**\n     * @notice It checks if the current cached address implementation is marked as invalidated.\n     * @notice It is marked invalidated if the proxy is strict dynamic and last update was >= 50 blocks ago.\n     * @return bool True if the cached implementation address is invalid.\n     */\n    function _cacheInvalidated() internal view returns (bool) {\n        return strictDynamic && _implementationBlockUpdated + 1 <= block.number;\n    }\n}\n"
    },
    "contracts/base/BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Interfaces\nimport \"../interfaces/SettingsInterface.sol\";\n\n// Contracts\nimport \"./upgradeable/DynamicUpgradeableStorage.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                        THIS CONTRACT IS A NON UPGRADEABLE STORAGE CONTRACT!                     **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of, PREPEND, or APPEND any storage variables to this or new versions   **/\n/**  of this contract as this will cause a ripple affect to the storage slots of all child          **/\n/**  contracts that inherit from this contract to be overwritten on the deployed proxy contract!!   **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract is used as the base storage contract for most of the contracts in the platform.\n * @notice It allows contracts to have access to the platform settings instance.\n *\n * @author develop@teller.finance.\n */\nabstract contract BaseStorage {\n    /**\n     * @notice It holds the platform Settings instance.\n     */\n    SettingsInterface public settings;\n\n    /**\n     * @dev This allocates additional storage slots in the event that additional state variables are added.\n     */\n    uint256[10] internal __gap;\n}\n"
    },
    "contracts/util/PlatformSettingsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    @notice Utility library of inline functions on the PlatformSetting struct.\n\n    @author develop@teller.finance\n */\nlibrary PlatformSettingsLib {\n    /**\n        It defines a platform settings. It includes: value, min, and max values.\n     */\n    struct PlatformSetting {\n        uint256 value;\n        uint256 min;\n        uint256 max;\n        bool exists;\n    }\n\n    /**\n        @notice It creates a new platform setting given a name, min and max values.\n        @param value initial value for the setting.\n        @param min min value allowed for the setting.\n        @param max max value allowed for the setting.\n     */\n    function initialize(\n        PlatformSetting storage self,\n        uint256 value,\n        uint256 min,\n        uint256 max\n    ) internal {\n        requireNotExists(self);\n        require(value >= min, \"VALUE_MUST_BE_GTE_MIN_VALUE\");\n        require(value <= max, \"VALUE_MUST_BE_LTE_MAX_VALUE\");\n        self.value = value;\n        self.min = min;\n        self.max = max;\n        self.exists = true;\n    }\n\n    /**\n        @notice Checks whether the current platform setting exists or not.\n        @dev It throws a require error if the platform setting already exists.\n        @param self the current platform setting.\n     */\n    function requireNotExists(PlatformSetting storage self) internal view {\n        require(!self.exists, \"PLATFORM_SETTING_ALREADY_EXISTS\");\n    }\n\n    /**\n        @notice Checks whether the current platform setting exists or not.\n        @dev It throws a require error if the current platform setting doesn't exist.\n        @param self the current platform setting.\n     */\n    function requireExists(PlatformSetting storage self) internal view {\n        require(self.exists, \"PLATFORM_SETTING_NOT_EXISTS\");\n    }\n\n    /**\n        @notice It updates a current platform setting.\n        @dev It throws a require error if:\n            - The new value is equal to the current value.\n            - The new value is not lower than the max value.\n            - The new value is not greater than the min value\n        @param self the current platform setting.\n        @param newValue the new value to set in the platform setting.\n     */\n    function update(PlatformSetting storage self, uint256 newValue)\n        internal\n        returns (uint256 oldValue)\n    {\n        requireExists(self);\n        require(self.value != newValue, \"NEW_VALUE_REQUIRED\");\n        require(newValue >= self.min, \"NEW_VALUE_MUST_BE_GTE_MIN_VALUE\");\n        require(newValue <= self.max, \"NEW_VALUE_MUST_BE_LTE_MAX_VALUE\");\n        oldValue = self.value;\n        self.value = newValue;\n    }\n\n    /**\n        @notice It removes a current platform setting.\n        @param self the current platform setting to remove.\n     */\n    function remove(PlatformSetting storage self) internal {\n        requireExists(self);\n        self.value = 0;\n        self.min = 0;\n        self.max = 0;\n        self.exists = false;\n    }\n}\n"
    },
    "contracts/interfaces/IDappRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../util/TellerCommon.sol\";\n\n/**\n    @notice This interface defines the functions to manage the Escrow contracts associated to borrowers and loans.\n\n    @author develop@teller.finance\n */\ninterface IDappRegistry {\n    /**\n        @notice It gets a dapp configuration based on its contract address.\n        @param dapp dapp address.\n        @return the dapp details.\n     */\n    function dapps(address dapp)\n        external\n        view\n        returns (TellerCommon.Dapp memory);\n\n    /**\n        @notice It adds a new dapp to the factory.\n        @param dapp address to add in this factory.\n        @param unsecured boolean to describe if the dapp is allowed to be used with unsecured loans.\n     */\n    function addDapp(address dapp, bool unsecured) external;\n\n    /**\n        @notice It updates a dapp configuration.\n        @param dapp address to add in this factory.\n        @param unsecured boolean that describes if the dapp can be used by with an unsecured loan.\n     */\n    function updateDapp(address dapp, bool unsecured) external;\n\n    /**\n        @notice It removes a current dapp from the factory.\n        @param dapp address to remove.\n     */\n    function removeDapp(address dapp) external;\n\n    /**\n        @notice Gets all the dapps in the factory.\n        @return an array of dapps (addresses).\n     */\n    function getDapps() external view returns (address[] memory);\n\n    /**\n        @notice It initializes this escrow contract factory instance.\n     */\n    function initialize() external;\n\n    /**\n        @notice This event is emitted when a new Escrow contract is created.\n        @param borrower address associated to the new escrow.\n        @param loansAddress loan manager contract address.\n        @param loanID loan id associated to the borrower and escrow contract.\n        @param escrowAddress the new escrow contract address.\n     */\n    event EscrowCreated(\n        address indexed borrower,\n        address indexed loansAddress,\n        uint256 indexed loanID,\n        address escrowAddress\n    );\n\n    /**\n        @notice This event is emitted when a new dapp is added to the factory.\n        @param sender address.\n        @param dapp address added to the factory.\n        @param unsecured boolean that describes if the dapp can be used by with an unsecured loan.\n     */\n    event NewDappAdded(\n        address indexed sender,\n        address indexed dapp,\n        bool unsecured\n    );\n\n    /**\n        @notice This event is emitted when a dapp is updated.\n        @param sender address.\n        @param dapp address of dapp contract.\n        @param unsecured boolean that describes if the dapp can be used by with an unsecured loan.\n     */\n    event DappUpdated(\n        address indexed sender,\n        address indexed dapp,\n        bool unsecured\n    );\n\n    /**\n        @notice This event is emitted when a current dapp is removed from the factory.\n        @param sender address.\n        @param dapp address removed from the factory.\n     */\n    event DappRemoved(address indexed sender, address indexed dapp);\n}\n"
    },
    "contracts/interfaces/IPriceAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Interfaces\nimport \"@chainlink/contracts/src/v0.5/interfaces/AggregatorV2V3Interface.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract is used to fetch and calculate prices and values from one token to another through Chainlink Aggregators.\n    @dev It tries to find an aggregator using the token addresses supplied. If unable, it uses ETH as a pass through asset to construct a path conversion.\n\n    @author develop@teller.finance\n */\ninterface IPriceAggregator {\n    /**\n        @notice It grabs the Chainlink Aggregator contract address for the token pair if it is supported.\n        @param src Source token address.\n        @param dst Destination token address.\n        @return AggregatorV2V3Interface The Chainlink Aggregator address.\n        @return bool whether or not the values from the Aggregator should be considered inverted.\n     */\n    function aggregatorFor(address src, address dst)\n        external\n        view\n        returns (AggregatorV2V3Interface, bool);\n\n    function isTokenSupported(address tokenAddress)\n        external\n        view\n        returns (bool);\n\n    /**\n        @notice It calculates the value of a token amount into another.\n        @param src Source token address.\n        @param dst Destination token address.\n        @param srcAmount Amount of the source token to convert into the destination token.\n        @return uint256 Value of the source token amount in destination tokens.\n     */\n    function valueFor(\n        address src,\n        address dst,\n        uint256 srcAmount\n    ) external view returns (uint256);\n\n    /**\n        @notice It returns the price of the token pair as given from the Chainlink Aggregator.\n        @dev It tries to use ETH as a pass through asset if the direct pair is not supported.\n        @param src Source token address.\n        @param dst Destination token address.\n        @return uint256 The latest answer as given from Chainlink.\n     */\n    function latestAnswerFor(address src, address dst)\n        external\n        view\n        returns (int256);\n\n    /**\n        @notice It allows for additional Chainlink Aggregators to be supported.\n        @param src Source token address.\n        @param dst Destination token address.\n     */\n    function add(\n        address src,\n        address dst,\n        address aggregator\n    ) external;\n\n    /**\n        @notice It removes support for a Chainlink Aggregator pair.\n        @param src Source token address.\n        @param dst Destination token address.\n     */\n    function remove(address src, address dst) external;\n\n    /**\n        @notice It removes support for a Chainlink Aggregator.\n        @param tokenAddress Token to remove all markets for.\n     */\n    function remove(address tokenAddress) external;\n\n    function initialize() external;\n}\n"
    },
    "contracts/interfaces/AssetSettingsInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../util/CacheLib.sol\";\n\n/**\n    @notice This interface defines all function to manage the asset settings on the platform.\n\n    @author develop@teller.finance\n */\ninterface AssetSettingsInterface {\n    /**\n        @notice This event is emitted when a new asset settings is created.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to create the settings.\n        @param cTokenAddress cToken address to configure for the asset.\n        @param maxLoanAmount max loan amount to configure for the asset.\n     */\n    event AssetSettingsCreated(\n        address indexed sender,\n        address indexed assetAddress,\n        address cTokenAddress,\n        uint256 maxLoanAmount\n    );\n\n    /**\n        @notice This event is emitted when an asset settings is removed.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to remove the settings.\n     */\n    event AssetSettingsRemoved(\n        address indexed sender,\n        address indexed assetAddress\n    );\n\n    /**\n        @notice This event is emitted when an asset settings (address type) is updated.\n        @param assetSettingName asset setting name updated.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to update the asset settings.\n        @param oldValue old value used for the asset setting.\n        @param newValue the value updated.\n     */\n    event AssetSettingsAddressUpdated(\n        bytes32 indexed assetSettingName,\n        address indexed sender,\n        address indexed assetAddress,\n        address oldValue,\n        address newValue\n    );\n\n    /**\n        @notice This event is emitted when an asset settings (uint256 type) is updated.\n        @param assetSettingName asset setting name updated.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to update the asset settings.\n        @param oldValue old value used for the asset setting.\n        @param newValue the value updated.\n     */\n    event AssetSettingsUintUpdated(\n        bytes32 indexed assetSettingName,\n        address indexed sender,\n        address indexed assetAddress,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n        @notice It creates an asset with the given parameters.\n        @param assetAddress asset address used to create the new setting.\n        @param cTokenAddress cToken address used to configure the asset setting.\n        @param maxLoanAmount the initial max loan amount.\n        @param maxTVLAmount the initial max total value locked amount.\n        @param maxDebtRatio the initial max debt ratio amount.\n    */\n    function createAssetSetting(\n        address assetAddress,\n        address cTokenAddress,\n        uint256 maxLoanAmount,\n        uint256 maxTVLAmount,\n        uint256 maxDebtRatio\n    ) external;\n\n    /**\n     * @notice It checks if the settings have been initialized for an asset address.\n     */\n    function isInitialized(address assetAddress)\n        external\n        view\n        virtual\n        returns (bool);\n\n    /**\n        @notice It updates the cToken address associted with an asset.\n        @param assetAddress asset address to configure.\n        @param cTokenAddress the new cToken address to configure.\n     */\n    function updateCTokenAddress(address assetAddress, address cTokenAddress)\n        external;\n\n    /**\n        @notice It returns the cToken address associted with an asset.\n        @param assetAddress asset address to get the associated cToken for.\n        @return The associated cToken address\n     */\n    function getCTokenAddress(address assetAddress)\n        external\n        view\n        returns (address);\n\n    /**\n        @notice It updates the yearn vault address associted with an asset.\n        @param assetAddress asset address to configure.\n        @param yVaultAddress the new yVault address to configure.\n     */\n    function updateYVaultAddressSetting(\n        address assetAddress,\n        address yVaultAddress\n    ) external;\n\n    /**\n        @notice It returns the yearn vault address associted with an asset.\n        @param assetAddress asset address to get the associated yearn vault address for.\n        @return The address of the yearn vault.\n     */\n    function getYVaultAddress(address assetAddress)\n        external\n        view\n        returns (address);\n\n    /**\n     @notice It updates the aToken address associated with an asset.\n     @param assetAddress asset address to configure.\n     @param aTokenAddress the new aToken address to configure.\n     */\n    function updateATokenAddress(address assetAddress, address aTokenAddress)\n        external;\n\n    /**\n      @notice It returns the aToken address associated with an asset.\n      @param assetAddress asset address to get the associated aToken for.\n      @return The associated aToken address\n      */\n    function getATokenAddress(address assetAddress)\n        external\n        view\n        returns (address);\n\n    /**\n      @notice It updates the pool together prize pool address associated with an asset.\n      @param assetAddress asset address to configure.\n      @param prizePoolAddress the new aToken address to configure.\n      */\n    function updatePrizePoolAddress(\n        address assetAddress,\n        address prizePoolAddress\n    ) external;\n\n    /**\n      @notice It returns the pool together prize pool address associated with an asset.\n      @param assetAddress asset address to get the associated aToken for.\n      @return The associated prize pool address\n      */\n    function getPrizePoolAddress(address assetAddress)\n        external\n        view\n        returns (address);\n\n    /**\n        @notice It updates the max loan amount for a given asset.\n        @param assetAddress asset address used to update the max loan amount.\n        @param newMaxLoanAmount the new max loan amount to set.\n     */\n    function updateMaxLoanAmount(address assetAddress, uint256 newMaxLoanAmount)\n        external;\n\n    /**\n        @notice Returns the max loan amount for a given asset.\n        @param assetAddress asset address to retrieve the max loan amount.\n     */\n    function getMaxLoanAmount(address assetAddress)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @notice Tests whether a given amount is greater than the current max loan amount.\n        @param assetAddress asset address used to return the max loan amount setting.\n        @param amount the loan amount to check.\n        @return true if the given amount is greater than the current max loan amount. Otherwise it returns false.\n     */\n    function exceedsMaxLoanAmount(address assetAddress, uint256 amount)\n        external\n        view\n        returns (bool);\n\n    /**\n        @notice It updates the max total vaule locked amount for a given asset.\n        @param assetAddress asset address used to update the max loan amount.\n        @param newMaxTVLAmount the new max total vault locked amount to set.\n     */\n    function updateMaxTVL(address assetAddress, uint256 newMaxTVLAmount)\n        external;\n\n    /**\n        @notice Returns the max total value locked amount for a given asset.\n        @param assetAddress asset address to retrieve the max total value locked amount.\n     */\n    function getMaxTVLAmount(address assetAddress)\n        external\n        view\n        returns (uint256);\n\n    /**\n    @notice It updates the max debt ratio for a given asset.\n    @dev The ratio value has 2 decimal places. I.e 100 = 1%\n    @param assetAddress asset address used to update the max debt ratio.\n    @param newMaxDebtRatio the new max debt ratio to set.\n    */\n    function updateMaxDebtRatio(address assetAddress, uint256 newMaxDebtRatio)\n        external;\n\n    /**\n    @notice Returns the max debt ratio for a given asset.\n    @dev The ratio value has 2 decimal places. I.e 100 = 1%\n    @param assetAddress asset address to retrieve the max debt ratio.\n    */\n    function getMaxDebtRatio(address assetAddress)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @notice It removes a configuration for a given asset on the platform.\n        @param assetAddress asset address to remove.\n     */\n    function removeAsset(address assetAddress) external;\n\n    function initialize() external;\n}\n"
    },
    "contracts/interfaces/IMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../util/TellerCommon.sol\";\nimport \"./IMarketRegistry.sol\";\n\n/**\n    @notice\n\n    @author develop@teller.finance\n */\n\ninterface IMarketFactory {\n    /** External Functions */\n\n    function marketRegistry() external returns (IMarketRegistry);\n\n    function createMarket(address lendingToken, address collateralToken)\n        external;\n\n    function initialize() external;\n\n    /** Events */\n\n    event NewMarketCreated(\n        address indexed sender,\n        address indexed lendingToken,\n        address indexed collateralToken,\n        address loans,\n        address lendingPool\n    );\n}\n"
    },
    "contracts/util/TellerCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./NumbersList.sol\";\n\n/**\n * @dev Library of structs common across the Teller protocol\n *\n * @author develop@teller.finance\n */\nlibrary TellerCommon {\n    enum LoanStatus { NonExistent, TermsSet, Active, Closed }\n\n    /**\n        @notice Represents a user signature\n        @param v The recovery identifier represented by the last byte of a ECDSA signature as an int\n        @param r The random point x-coordinate of the signature respresented by the first 32 bytes of the generated ECDSA signature\n        @param s The signature proof represented by the second 32 bytes of the generated ECDSA signature\n     */\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /**\n        @notice Borrower request object to take out a loan\n        @param borrower The wallet address of the borrower\n        @param recipient The address where funds will be sent, only applicable in over collateralized loans\n        @param consensusAddress The address of the Teller loan consensus contract to which the request should be sent\n        @param requestNonce The nonce of the borrower wallet address required for authentication\n        @param amount The amount of tokens requested by the borrower for the loan\n        @param duration The length of time in seconds that the loan has been requested for\n        @param requestTime The timestamp at which the loan was requested\n     */\n    struct LoanRequest {\n        address payable borrower;\n        address recipient;\n        address consensusAddress;\n        uint256 requestNonce;\n        uint256 amount;\n        uint256 duration;\n        uint256 requestTime;\n    }\n\n    /**\n        @notice Borrower response object to take out a loan\n        @param signer The wallet address of the signer validating the interest request of the lender\n        @param consensusAddress The address of the Teller loan consensus contract to which the request should be sent\n        @param responseTime The timestamp at which the response was sent\n        @param interestRate The signed interest rate generated by the signer's Credit Risk Algorithm (CRA)\n        @param collateralRatio The ratio of collateral to loan amount that is generated by the signer's Credit Risk Algorithm (CRA)\n        @param maxLoanAmount The largest amount of tokens that can be taken out in the loan by the borrower\n        @param signature The signature generated by the signer in the format of the above Signature struct\n     */\n    struct LoanResponse {\n        address signer;\n        address consensusAddress;\n        uint256 responseTime;\n        uint256 interestRate;\n        uint256 collateralRatio;\n        uint256 maxLoanAmount;\n        Signature signature;\n    }\n\n    /**\n        @notice Represents loan terms based on consensus values\n        @param interestRate The consensus value for the interest rate based on all the loan responses from the signers\n        @param collateralRatio The consensus value for the ratio of collateral to loan amount required for the loan, based on all the loan responses from the signers\n        @param maxLoanAmount The consensus value for the largest amount of tokens that can be taken out in the loan, based on all the loan responses from the signers\n     */\n    struct AccruedLoanTerms {\n        NumbersList.Values interestRate;\n        NumbersList.Values collateralRatio;\n        NumbersList.Values maxLoanAmount;\n    }\n\n    /**\n        @notice Represents the terms of a loan based on the consensus of a LoanRequest\n        @param borrower The wallet address of the borrower\n        @param recipient The address where funds will be sent, only applicable in over collateralized loans\n        @param interestRate The consensus interest rate calculated based on all signer loan responses\n        @param collateralRatio The consensus ratio of collateral to loan amount calculated based on all signer loan responses\n        @param maxLoanAmount The consensus largest amount of tokens that can be taken out in the loan by the borrower, calculated based on all signer loan responses\n        @param duration The consensus length of loan time, calculated based on all signer loan responses\n     */\n    struct LoanTerms {\n        address payable borrower;\n        address recipient;\n        uint256 interestRate;\n        uint256 collateralRatio;\n        uint256 maxLoanAmount;\n        uint256 duration;\n    }\n\n    /**\n        @notice Data per borrow as struct\n        @param id The id of the loan for internal tracking\n        @param loanTerms The loan terms returned by the signers\n        @param termsExpiry The timestamp at which the loan terms expire, after which if the loan is not yet active, cannot be taken out\n        @param loanStartTime The timestamp at which the loan became active\n        @param collateral The total amount of collateral deposited by the borrower to secure the loan\n        @param lastCollateralIn The amount of collateral that was last deposited by the borrower to keep the loan active\n        @param principalOwed The total amount of the loan taken out by the borrower, reduces on loan repayments\n        @param interestOwed The total interest owed by the borrower for the loan, reduces on loan repayments\n        @param borrowedAmount The total amount of the loan size taken out\n        @param escrow The address of the escrow contract that holds the funds taken out in the loan on behalf of the borrower\n        @param status The status of the loan currently based on the LoanStatus enum - NonExistent, TermsSet, Active, Closed\n        @param liquidated Flag marking if the loan has been liquidated or not\n     */\n    struct Loan {\n        uint256 id;\n        LoanTerms loanTerms;\n        uint256 termsExpiry;\n        uint256 loanStartTime;\n        uint256 collateral;\n        uint256 lastCollateralIn;\n        uint256 principalOwed;\n        uint256 interestOwed;\n        uint256 borrowedAmount;\n        address escrow;\n        LoanStatus status;\n        bool liquidated;\n    }\n\n    /**\n        @notice This struct defines the dapp address and data to execute in the callDapp function.\n        @dev It is executed using a delegatecall in the Escrow contract.\n        @param exists Flag marking whether the dapp is a Teller registered address\n        @param unsecured Flag marking if the loan allowed to be used in the dapp is a secured, or unsecured loan\n     */\n    struct Dapp {\n        bool exists;\n        bool unsecured;\n    }\n\n    /**\n        @notice This struct defines the dapp address and data to execute in the callDapp function.\n        @dev It is executed using a delegatecall in the Escrow contract.\n        @param location The proxy contract address for the dapp that will be used by the Escrow contract delegatecall\n        @param data The encoded function signature with parameters for the dapp method in bytes that will be sent in the Escrow delegatecall\n     */\n    struct DappData {\n        address location;\n        bytes data;\n    }\n\n    /**\n        @notice This struct defines a market in the platform.\n        @dev It is used by the MarketFactory contract.\n        @param loans The address for the Teller LoanManager contract that is being used for a market\n        @param lendingPool The address for the Teller Lending Pool contract that is being used for a market\n        @param loanTermsConsensus The address for the Teller Loan Terms Consensus contract that is being used for a market\n        @param exists Flag marking if the market is defined on the platform or not\n     */\n    struct Market {\n        address loans;\n        address lendingPool;\n        address loanTermsConsensus;\n        bool exists;\n    }\n\n    /**\n        @notice This struct is used to register new logic versions.\n        @param logic The address for the new contract holding the logic.\n        @param logicName The name for the logic to be stored as.\n     */\n    struct CreateLogicVersionRequest {\n        address logic;\n        bytes32 logicName;\n    }\n\n    /**\n        @notice This struct is used to upgrade logic versions.\n        @param logic The new logic address to upgrade proxy to.\n        @param logicName The name for the logic to be stored as.\n        @param proxy The (optional) DynamicUpgradeable proxy address to attempt to directly upgrade.\n     */\n    struct UpgradeLogicVersionRequest {\n        address logic;\n        bytes32 logicName;\n        address proxy;\n    }\n}\n"
    },
    "contracts/util/NumbersList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./NumbersLib.sol\";\n\n/**\n * @dev Utility library of inline functions on NumbersList.Values\n *\n * @author develop@teller.finance\n */\nlibrary NumbersList {\n    using SafeMath for uint256;\n    using NumbersLib for uint256;\n\n    // Holds values to calculate the threshold of a list of numbers\n    struct Values {\n        uint256 count; // The total number of numbers added\n        uint256 max; // The maximum number that was added\n        uint256 min; // The minimum number that was added\n        uint256 sum; // The total sum of the numbers that were added\n    }\n\n    /**\n     * @dev Add to the sum while keeping track of min and max values\n     * @param self The Value this function was called on\n     * @param newValue Number to increment sum by\n     */\n    function addValue(Values memory self, uint256 newValue) internal pure {\n        if (self.max < newValue) {\n            self.max = newValue;\n        }\n        if (self.min > newValue || self.count == 0) {\n            self.min = newValue;\n        }\n        self.sum = self.sum.add(newValue);\n        self.count = self.count.add(1);\n    }\n\n    /**\n     * @param self The Value this function was called on\n     * @return the number of times the sum has updated\n     */\n    function valuesCount(Values memory self) internal pure returns (uint256) {\n        return self.count;\n    }\n\n    /**\n     * @dev Checks if the sum has been changed\n     * @param self The Value this function was called on\n     * @return boolean\n     */\n    function isEmpty(Values memory self) internal pure returns (bool) {\n        return valuesCount(self) == 0;\n    }\n\n    /**\n     * @param self The Value this function was called on\n     * @return the average number that was used to calculate the sum\n     */\n    function getAverage(Values memory self) internal pure returns (uint256) {\n        return isEmpty(self) ? 0 : self.sum.div(valuesCount(self));\n    }\n\n    /**\n     * @dev Checks if the min and max numbers are within the acceptable tolerance\n     * @param self The Value this function was called on\n     * @param tolerancePercentage Acceptable tolerance percentage as a whole number\n     * The percentage should be entered with 2 decimal places. e.g. 2.5% should be entered as 250.\n     * @return boolean\n     */\n    function isWithinTolerance(Values memory self, uint256 tolerancePercentage)\n        internal\n        pure\n        returns (bool)\n    {\n        if (isEmpty(self)) {\n            return false;\n        }\n        uint256 average = getAverage(self);\n        uint256 toleranceAmount = average.percent(tolerancePercentage);\n\n        uint256 minTolerance = average.sub(toleranceAmount);\n        if (self.min < minTolerance) {\n            return false;\n        }\n\n        uint256 maxTolerance = average.add(toleranceAmount);\n        if (self.max > maxTolerance) {\n            return false;\n        }\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/util/NumbersLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @dev Utility library for uint256 numbers\n *\n * @author develop@teller.finance\n */\nlibrary NumbersLib {\n    using SafeMath for uint256;\n\n    /**\n        @dev It represents 100% with 2 decimal places.\n     */\n    function ONE_HUNDRED_PERCENT() internal pure returns (uint256) {\n        return 10000;\n    }\n\n    /**\n        @notice Returns the positive difference value of a number to another number\n        @param self The number to return the difference value for\n        @param other The other number to calucualte the difference against\n        @return uint256 The difference value\n     */\n    function diff(uint256 self, uint256 other) internal pure returns (uint256) {\n        return other > self ? other.sub(self) : self.sub(other);\n    }\n\n    /**\n        @notice Returns the positive percentage difference of a value to 100%\n        @param self The number to return the percentage difference for\n        @return uint256 The percentage difference value\n     */\n    function diffOneHundredPercent(uint256 self)\n        internal\n        pure\n        returns (uint256)\n    {\n        return diff(self, ONE_HUNDRED_PERCENT());\n    }\n\n    /**\n     * @notice Returns a percentage value of a number.\n     * @param self The number to get a percentage of.\n     * @param percentage The percentage value to calculate with 2 decimal places (10000 = 100%).\n     */\n    function percent(uint256 self, uint256 percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        return self.mul(percentage).div(ONE_HUNDRED_PERCENT());\n    }\n\n    function percent(int256 self, uint256 percentage)\n        internal\n        pure\n        returns (int256)\n    {\n        return (self * int256(percentage)) / int256(ONE_HUNDRED_PERCENT());\n    }\n\n    function abs(int256 self) internal pure returns (uint256) {\n        return self >= 0 ? uint256(self) : uint256(-1 * self);\n    }\n\n    /**\n     * @notice Returns a ratio of 2 numbers.\n     * @param self The number to get a ratio of.\n     * @param num The number to calculate the ratio for.\n     * @return Ratio of 2 numbers with 2 decimal places (10000 = 100%).\n     */\n    function ratioOf(uint256 self, uint256 num)\n        internal\n        pure\n        returns (uint256)\n    {\n        return self.mul(ONE_HUNDRED_PERCENT()).div(num);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.5/interfaces/AggregatorV2V3Interface.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\n/**\n * @title The V2 & V3 Aggregator Interface\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\n * and v0.5 AggregatorV3Interface.sol.\n */\ninterface AggregatorV2V3Interface {\n  //\n  // V2 Interface:\n  //\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n\n  //\n  // V3 Interface:\n  //\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "@chainlink/contracts/src/v0.5/interfaces/AggregatorInterface.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.5/interfaces/AggregatorV3Interface.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/util/CacheLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    @notice Utility library of inline functions on the Cache struct.\n\n    @author develop@teller.finance\n */\nlibrary CacheLib {\n    enum CacheType { Address, Uint, Int, Byte, Bool }\n\n    /**\n        @notice This struct manages the cache of the library instance.\n        @param addresses A mapping of address values mapped to cache keys in bytes.\n        @param uints A mapping of uint values mapped to cache keys names in bytes.\n        @param ints A mapping of int values mapped to cache keys names in bytes.\n        @param bites A mapping of bytes values mapped to cache keys names in bytes.\n        @param bools A mapping of bool values mapped to cache keys names in bytes.\n     */\n\n    struct Cache {\n        // Mapping of cache keys names to address values.\n        mapping(bytes32 => address) addresses;\n        // Mapping of cache keys names to uint256 values.\n        mapping(bytes32 => uint256) uints;\n        // Mapping of cache keys names to int256 values.\n        mapping(bytes32 => int256) ints;\n        // Mapping of cache keys names to bytes32 values.\n        mapping(bytes32 => bytes32) bites;\n        // Mapping of cache keys names to bool values.\n        mapping(bytes32 => bool) bools;\n    }\n\n    /**\n        @notice The constant for the initialization check\n     */\n    //   bytes32 private constant INITIALIZED = keccak256(\"Initialized\");\n\n    /**\n        @notice Initializes the cache instance.\n        @param self The current cache\n     */\n    function initialize(Cache storage self) internal {\n        requireNotExists(self);\n        self.bools[keccak256(\"Initialized\")] = true;\n    }\n\n    /**\n        @notice Checks whether the current cache does not, throwing an error if it does.\n        @param self The current cache\n     */\n    function requireNotExists(Cache storage self) internal view {\n        require(!exists(self), \"CACHE_ALREADY_EXISTS\");\n    }\n\n    /**\n        @notice Checks whether the current cache exists, throwing an error if the cache does not.\n        @param self The current cache\n     */\n    function requireExists(Cache storage self) internal view {\n        require(exists(self), \"CACHE_DOES_NOT_EXIST\");\n    }\n\n    /**\n        @notice Tests whether the current cache exists or not.\n        @param self The current cache.\n        @return bool True if the cache exists.\n     */\n    function exists(Cache storage self) internal view returns (bool) {\n        return self.bools[keccak256(\"Initialized\")];\n    }\n\n    /**\n        @notice Updates the address value for a given key name.\n        @param self The current cache\n        @param key The key for which the address value is being updated.\n        @param newAddress The new address being set.\n     */\n    function updateAddress(\n        Cache storage self,\n        bytes32 key,\n        address newAddress\n    ) internal {\n        requireExists(self);\n        require(self.addresses[key] != newAddress, \"NEW_ADDRESS_REQUIRED\");\n        self.addresses[key] = newAddress;\n    }\n\n    /**\n        @notice Updates the uint value for a given key name.\n        @param self The current cache\n        @param key The key for which the uint value is being updated.\n        @param newValue The new value being set.\n     */\n    function updateUint(\n        Cache storage self,\n        bytes32 key,\n        uint256 newValue\n    ) internal {\n        requireExists(self);\n        require(self.uints[key] != newValue, \"NEW_UINT_REQUIRED\");\n        self.uints[key] = newValue;\n    }\n\n    /**\n        @notice Tests whether a given uint value is greater than the current stored value for a given key.\n        @param self The current cache\n        @param key The key for which the uint value is being updated.\n        @param amount The value being tested.\n        @return bool True if the value exceed the stored value.\n     */\n    function exceedsUint(\n        Cache storage self,\n        bytes32 key,\n        uint256 amount\n    ) internal view returns (bool) {\n        requireExists(self);\n        return amount > self.uints[key];\n    }\n\n    /**\n        @notice Updates the int value for a given key name.\n        @param self The current cache\n        @param key The key for which the int value is being updated.\n        @param newValue The new value being set.\n     */\n    function updateInt(\n        Cache storage self,\n        bytes32 key,\n        int256 newValue\n    ) internal {\n        requireExists(self);\n        require(self.ints[key] != newValue, \"NEW_INT_REQUIRED\");\n        self.ints[key] = newValue;\n    }\n\n    /**\n        @notice Updates the bytes value for a given key name.\n        @param self The current cache\n        @param key The key for which the bytes value is being updated.\n        @param newBites The new value being set.\n     */\n    function updateBites(\n        Cache storage self,\n        bytes32 key,\n        bytes32 newBites\n    ) internal {\n        requireExists(self);\n        require(self.bites[key] != newBites, \"NEW_BYTES_REQUIRED\");\n        self.bites[key] = newBites;\n    }\n\n    /**\n        @notice Updates the bool value for a given key name.\n        @param self The current cache\n        @param key The key for which the bool value is being updated.\n        @param newBool The new value being set.\n     */\n    function updateBool(\n        Cache storage self,\n        bytes32 key,\n        bool newBool\n    ) internal {\n        requireExists(self);\n        require(self.bools[key] != newBool, \"NEW_BOOLEAN_REQUIRED\");\n        self.bools[key] = newBool;\n    }\n\n    /**\n     */\n    function clearCache(\n        Cache storage self,\n        bytes32[5] memory keysToClear,\n        CacheType[5] memory keyTypes\n    ) internal {\n        requireExists(self);\n        require(\n            keysToClear.length == keyTypes.length,\n            \"ARRAY_LENGTHS_MISMATCH\"\n        );\n        for (uint256 i; i <= keysToClear.length; i++) {\n            if (keyTypes[i] == CacheType.Address) {\n                delete self.addresses[keysToClear[i]];\n            } else if (keyTypes[i] == CacheType.Uint) {\n                delete self.uints[keysToClear[i]];\n            } else if (keyTypes[i] == CacheType.Int) {\n                delete self.ints[keysToClear[i]];\n            } else if (keyTypes[i] == CacheType.Byte) {\n                delete self.bites[keysToClear[i]];\n            } else if (keyTypes[i] == CacheType.Bool) {\n                delete self.bools[keysToClear[i]];\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IMarketRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Utils\nimport \"../util/AddressArrayLib.sol\";\n\n// Interfaces\nimport \"./LendingPoolInterface.sol\";\nimport \"./loans/ILoanManager.sol\";\n\n/**\n    @notice It defines all the functions for the TToken registry\n\n    @author develop@teller.finance\n */\n\ninterface IMarketRegistry {\n    /**\n        @notice It fetches an array of collateral tokens that a given lending token supports.\n        @param lendingTokenAddress a token that the protocol lends.\n        @return an array of collateral tokens supported by the lending token market.\n     */\n    function getMarkets(address lendingTokenAddress)\n        external\n        view\n        returns (address[] memory);\n\n    /**\n        @notice It maps a lending token to the associated LendingPool contract.\n        @param lendingTokenAddress the lending token used in a LendingPool.\n        @return the LendingPool contract for the given token.\n     */\n    function lendingPools(address lendingTokenAddress)\n        external\n        view\n        returns (address);\n\n    /**\n        @notice It maps a lending token and collateral token to the associated LoanManager contract.\n        @param lendingTokenAddress a token the protocol lends out.\n        @param collateralTokenAddress a token that is used as collateral.\n        @return the Loans contract for the given token pair.\n     */\n    function loanManagers(\n        address lendingTokenAddress,\n        address collateralTokenAddress\n    ) external view returns (address);\n\n    /**\n        @notice It represents a mapping to identify a LendingPool's LoanManager contract address.\n        @param lendingPoolAddress a LendingPool contract.\n        @param loanManagerAddress a Loans contract.\n        @return true if the Loans contract address is registered to the LendingPool contract.\n     */\n    function loanManagerRegistry(\n        address lendingPoolAddress,\n        address loanManagerAddress\n    ) external view returns (bool);\n\n    /**\n        @notice It registers a new market with a LendingPool and Loans contract pair.\n        @param lendingPoolAddress a lending pool contract used to borrow assets.\n        @param loanManagerAddress a loan manager contract that stores all the relevant loans info and functionality.\n     */\n    function registerMarket(\n        address lendingPoolAddress,\n        address loanManagerAddress\n    ) external;\n\n    /**\n        @notice It checks if a market already exists.\n        @param lendingTokenAddress The lending token address.\n        @param collateralTokenAddress The collateral token address.\n     */\n    function marketExists(\n        address lendingTokenAddress,\n        address collateralTokenAddress\n    ) external view virtual returns (bool);\n\n    /**\n     * @notice It initializes the MarketRegistry contract by setting the owner of the caller.\n     * @dev This contract is constructed and initialized by the MarketFactory.\n     */\n    function initialize() external;\n}\n"
    },
    "contracts/util/AddressArrayLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AddressLib.sol\";\n\n/**\n    @notice Utility library of inline functions on the address arrays.\n\n    @author develop@teller.finance\n */\nlibrary AddressArrayLib {\n    using AddressLib for address;\n\n    struct AddressArray {\n        address[] array;\n        mapping(address => uint256) indices;\n    }\n\n    function length(AddressArray storage self) internal view returns (uint256) {\n        return self.array.length;\n    }\n\n    /**\n      @notice It adds an address value to the array.\n      @param self current array.\n      @param newItem new item to add.\n      @return index the item was added to.\n    */\n    function add(address[] storage self, address newItem)\n        internal\n        returns (uint256)\n    {\n        newItem.requireNotEmpty(\"EMPTY_ADDRESS_NOT_ALLOWED\");\n        self.push(newItem);\n        return self.length - 1;\n    }\n\n    function add(AddressArray storage self, address addr)\n        internal\n        returns (uint256 index)\n    {\n        addr.requireNotEmpty(\"EMPTY_ADDRESS_NOT_ALLOWED\");\n        (bool found, ) = getIndex(self, addr);\n        require(!found, \"ADDRESS_EXISTS\");\n        self.array.push(addr);\n        index = length(self) - 1;\n        self.indices[addr] = index;\n    }\n\n    /**\n      @notice It removes the value at the given index in an array.\n      @param self the current array.\n      @param index remove an item in a specific index.\n    */\n    function removeAt(address[] storage self, uint256 index) internal {\n        if (index >= self.length) return;\n\n        if (index != self.length - 1) {\n            self[index] = self[self.length - 1];\n        }\n\n        self.pop();\n    }\n\n    function remove(AddressArray storage self, uint256 index) internal {\n        removeAt(self.array, index);\n    }\n\n    function remove(AddressArray storage self, address addr) internal {\n        (bool found, uint256 index) = getIndex(self, addr);\n\n        if (!found) return;\n\n        removeAt(self.array, index);\n    }\n\n    /**\n      @notice It gets the index for a given item.\n      @param self the current array.\n      @param item to get the index.\n      @return found true if the item was found. Otherwise it returns false.\n      @return indexAt the current index for a given item.\n    */\n    function getIndex(address[] storage self, address item)\n        internal\n        view\n        returns (bool found, uint256 indexAt)\n    {\n        for (indexAt = 0; indexAt < self.length; indexAt++) {\n            found = self[indexAt] == item;\n            if (found) {\n                return (found, indexAt);\n            }\n        }\n        return (found, indexAt);\n    }\n\n    function getIndex(AddressArray storage self, address addr)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        if (self.array.length > 0) {\n            index = self.indices[addr];\n            found = self.array[index] == addr;\n        }\n    }\n\n    /**\n      @notice It removes an address value from the array.\n      @param self the current array.\n      @param item the item to remove.\n    */\n    function remove(address[] storage self, address item) internal {\n        (bool found, uint256 indexAt) = getIndex(self, item);\n        if (!found) return;\n\n        removeAt(self, indexAt);\n    }\n}\n"
    },
    "contracts/interfaces/LendingPoolInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Utils\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// Interfaces\nimport \"./IMarketRegistry.sol\";\nimport \"./ITToken.sol\";\nimport \"../providers/uniswap/IUniswapV2Router02.sol\";\nimport \"../providers/compound/CErc20Interface.sol\";\n\n/**\n    @notice This interface defines the functions for a lending pool that holds all of the tokens\n    that lenders transfer into the protocol.\n\n    @author develop@teller.finance\n */\ninterface LendingPoolInterface {\n    /**\n        @notice It allows users to deposit tokens into the pool.\n        @dev the user must call ERC20.approve function previously.\n        @param amount of tokens to deposit in the pool.\n    */\n    function deposit(uint256 amount) external;\n\n    /**\n        @notice It allows any tToken holder to burn their tToken tokens and withdraw their tokens.\n        @param amount of tokens to withdraw.\n        @dev It throws a require error if the contract hasn't enough tokens balance.\n        @dev It throws a require error if the holder hasn't enough tToken balance.\n     */\n    function withdraw(uint256 amount) external;\n\n    /**\n        @notice It allows a borrower repaying their loan.\n        @dev This function can be called ONLY by the LoanManager contract.\n        @dev It requires a ERC20.approve call before calling it.\n        @dev It throws a require error if borrower called ERC20.approve function before calling it.\n        @param principalAmount amount of tokens towards the principal.\n        @param interestAmount amount of tokens towards the interest.\n        @param borrower address that is repaying the loan.\n     */\n    function repay(\n        uint256 principalAmount,\n        uint256 interestAmount,\n        address borrower\n    ) external;\n\n    /**\n        @notice Once the loan is created, it transfers the amount of tokens to the borrower.\n        @param amount of tokens to transfer.\n        @param borrower address which will receive the tokens.\n        @dev This function only can be invoked by the LoanManager implementation.\n        @dev It throws a require error if current ERC20 balance isn't enough to transfer the tokens.\n     */\n    function createLoan(uint256 amount, address borrower) external;\n\n    /**\n        @notice It gets the lending token address.\n        @return the ERC20 lending token address.\n    */\n    function lendingToken() external view returns (ERC20);\n\n    /**\n        @notice It initializes the contract state variables.\n        @param aMarketRegistry the MarketRegistry contract.\n        @param aLendingToken The underlying token that is used for lending.\n        @param aTToken the Teller token to link to the lending pool.\n        @param settingsAddress Settings contract address.\n        @dev It throws a require error if the contract is already initialized.\n     */\n    function initialize(\n        IMarketRegistry aMarketRegistry,\n        address aLendingToken,\n        address aTToken,\n        address settingsAddress\n    ) external;\n\n    /**\n        @notice It gets the cToken address.\n        @return the cToken address.\n    */\n    function cToken() external view returns (CErc20Interface);\n\n    function compound() external view returns (IComptroller);\n\n    function comp() external view returns (ERC20);\n\n    /**\n        @notice It gets the tToken address.\n        @return the tToken address.\n    */\n    function tToken() external view returns (ITToken);\n\n    /**\n        @notice It returns the balance of underlying tokens a lender owns with the amount\n        of TTokens owned and the current exchange rate.\n        @return a lender's balance of the underlying token in the pool.\n     */\n    function balanceOfUnderlying(address lender) external returns (uint256);\n\n    /**\n        @notice Returns the total amount of interest earned by a lender.\n        @dev This value includes already claimed + unclaimed interest earned.\n        @return total interest earned by lender.\n     */\n    function getLenderInterestEarned(address lender) external returns (uint256);\n\n    /**\n        @notice Returns the amount of claimable interest a lender has earned.\n        @return claimable interest value.\n     */\n    function getClaimableInterestEarned(address lender)\n        external\n        returns (uint256);\n\n    /**\n        @notice Returns the total amount of interest the pool has earned from repaying loans.\n        @return total interest earned from loans.\n     */\n    function totalInterestEarned() external view returns (uint256);\n\n    /**\n        @notice It calculates the market state values across all markets.\n        @notice It returns values that represent the global state across all markets.\n        @return totalSupplied\n        @return totalBorrowed\n        @return totalRepaid\n        @return totalOnLoan\n     */\n    function getMarketState()\n        external\n        view\n        returns (\n            uint256 totalSupplied,\n            uint256 totalBorrowed,\n            uint256 totalRepaid,\n            uint256 totalOnLoan\n        );\n\n    /**\n        @notice It gets the debt-to-supply (DtS) ratio for a given market, including a new loan amount.\n        @notice The formula to calculate DtS ratio (including a new loan amount) is:\n\n            DtS = (SUM(total borrowed) - SUM(total repaid) + NewLoanAmount) / SUM(total supplied)\n\n        @notice The value has 2 decimal places.\n            Example:\n                100 => 1%\n        @param loanAmount a new loan amount to consider in the ratio.\n        @return the debt-to-supply ratio value.\n     */\n    function getDebtRatioFor(uint256 loanAmount)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @notice This event is emitted when an user deposits tokens into the pool.\n        @param sender address.\n        @param amount of tokens.\n     */\n    event TokenDeposited(\n        address indexed sender,\n        uint256 amount,\n        uint256 tTokenAmount\n    );\n\n    /**\n        @notice This event is emitted when an user withdraws tokens from the pool.\n        @param sender address that withdrew the tokens.\n        @param amount of tokens.\n     */\n    event TokenWithdrawn(\n        address indexed sender,\n        uint256 amount,\n        uint256 tTokenAmount\n    );\n\n    /**\n        @notice This event is emitted when an borrower repaid a loan.\n        @param borrower address.\n        @param amount of tokens.\n     */\n    event TokenRepaid(address indexed borrower, uint256 amount);\n\n    /**\n        @notice This event is emitted when an lender withdraws interests.\n        @param lender address.\n        @param amount of tokens.\n     */\n    event InterestWithdrawn(address indexed lender, uint256 amount);\n\n    /**\n        @notice This event is emitted when the interest validator is updated.\n        @param sender account that sends the transaction.\n        @param oldInterestValidator the old validator address.\n        @param newInterestValidator the new validator address.\n     */\n    event InterestValidatorUpdated(\n        address indexed sender,\n        address indexed oldInterestValidator,\n        address indexed newInterestValidator\n    );\n}\n"
    },
    "contracts/interfaces/loans/ILoanManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Commons\nimport \"../../util/TellerCommon.sol\";\n\n// Interfaces\nimport \"../SettingsInterface.sol\";\nimport \"./ILoanData.sol\";\n\n/**\n * @notice This interface defines the functions to work with the Teller loans protocol\n *\n * @author develop@teller.finance\n */\ninterface ILoanManager {\n    /**\n     * @notice Deposit collateral for a loan, unless it isn't allowed\n     * @param borrower Account address of the borrower\n     * @param loanID ID of loan from which collateral was withdrawn\n     * @param amount Amount to be deposited as collateral\n     */\n    function depositCollateral(\n        address borrower,\n        uint256 loanID,\n        uint256 amount\n    ) external payable;\n\n    /**\n     * @notice Withdraw collateral from a loan, unless this isn't allowed\n     * @param amount The amount of collateral token or ether the caller is hoping to withdraw\n     * @param loanID The ID of the loan the collateral is for\n     */\n    function withdrawCollateral(uint256 amount, uint256 loanID) external;\n\n    /**\n     * @notice Create a loan with specified terms, if allowed\n     * @param request Struct of the protocol loan request\n     * @param responses List of structs of the protocol loan responses\n     * @param collateralAmount Amount of collateral for the loan\n     */\n    function createLoanWithTerms(\n        TellerCommon.LoanRequest calldata request,\n        TellerCommon.LoanResponse[] calldata responses,\n        uint256 collateralAmount\n    ) external payable;\n\n    /**\n     * @notice Take out a loan, if allowed\n     * @param loanID The ID of the loan to be taken out\n     * @param amountBorrow Amount of tokens to be taken out in the loan\n     */\n    function takeOutLoan(uint256 loanID, uint256 amountBorrow) external;\n\n    /**\n     * @notice Make a payment to a specified loan\n     * @param amount The amount of tokens to pay back to the loan\n     * @param loanID The ID of the loan the payment is for\n     */\n    function repay(uint256 amount, uint256 loanID) external;\n\n    /**\n     * @notice Liquidate a loan if has is expired or under collateralized\n     * @param loanID The ID of the loan to be liquidated\n     */\n    function liquidateLoan(uint256 loanID) external;\n\n    /**\n        @notice It adds a new account as a signer.\n        @param account address to add.\n        @dev The sender must be the owner.\n        @dev It throws a require error if the sender is not the owner.\n     */\n    function addSigner(address account) external;\n\n    /**\n        @notice It adds a list of account as signers.\n        @param accounts addresses to add.\n        @dev The sender must be the owner.\n        @dev It throws a require error if the sender is not the owner.\n     */\n    function addSigners(address[] calldata accounts) external;\n\n    /**\n     *  @notice It calls the LogicVersionRegistry to update the stored logic address for LoanData.\n     */\n    function updateLoanDataLogic() external;\n\n    /**\n     *  @notice It calls the LogicVersionRegistry to update the stored logic address for LoanTermsConsensus.\n     */\n    function updateLoanTermsConsensusLogic() external;\n\n    /**\n     * @notice Initializes the current contract instance setting the required parameters, if allowed\n     * @param lendingPoolAddress Contract address of the lending pool\n     * @param settingsAddress Contract address for the configuration of the platform\n     * @param collateralTokenAddress Contract address for the collateral token\n     * @param initDynamicProxyLogicAddress Address of a deployed InitializableDynamicProxy contract.\n     */\n    function initialize(\n        address lendingPoolAddress,\n        address settingsAddress,\n        address collateralTokenAddress,\n        address initDynamicProxyLogicAddress\n    ) external;\n\n    /**\n     * @notice This event is emitted when collateral has been deposited for the loan\n     * @param loanID ID of the loan for which collateral was deposited\n     * @param borrower Account address of the borrower\n     * @param depositAmount Amount of collateral deposited\n     */\n    event CollateralDeposited(\n        uint256 indexed loanID,\n        address indexed borrower,\n        uint256 depositAmount\n    );\n\n    /**\n     * @notice This event is emitted when collateral has been withdrawn\n     * @param loanID ID of loan from which collateral was withdrawn\n     * @param borrower Account address of the borrower\n     * @param recipient Account address of the recipient\n     * @param amount Value of collateral withdrawn\n     */\n    event CollateralWithdrawn(\n        uint256 indexed loanID,\n        address indexed borrower,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    /**\n     * @notice This event is emitted when loan terms have been successfully set\n     * @param loanID ID of loan from which collateral was withdrawn\n     * @param borrower Account address of the borrower\n     * @param recipient Account address of the recipient\n     */\n    event LoanTermsSet(\n        uint256 indexed loanID,\n        address indexed borrower,\n        address indexed recipient,\n        uint256 nonce\n    );\n\n    /**\n     * @notice This event is emitted when a loan has been successfully taken out\n     * @param loanID ID of loan from which collateral was withdrawn\n     * @param borrower Account address of the borrower\n     * @param escrow Escrow address associated to this loan\n     * @param amountBorrowed Total amount taken out in the loan\n     */\n    event LoanTakenOut(\n        uint256 indexed loanID,\n        address indexed borrower,\n        address indexed escrow,\n        uint256 amountBorrowed\n    );\n\n    /**\n     * @notice This event is emitted when a loan has been successfully repaid\n     * @param loanID ID of loan from which collateral was withdrawn\n     * @param borrower Account address of the borrower\n     * @param amountPaid Amount of the loan paid back\n     * @param payer Account address of the payer\n     * @param totalOwed Total amount of the loan to be repaid\n     */\n    event LoanRepaid(\n        uint256 indexed loanID,\n        address indexed borrower,\n        uint256 amountPaid,\n        address payer,\n        uint256 totalOwed\n    );\n\n    /**\n     * @notice This event is emitted when a loan has been successfully liquidated\n     * @param loanID ID of loan from which collateral was withdrawn\n     * @param borrower Account address of the borrower\n     * @param liquidator Account address of the liquidator\n     * @param collateralOut Collateral that is sent to the liquidator\n     * @param tokensIn Percentage of the collateral price paid by the liquidator to the lending pool\n     */\n    event LoanLiquidated(\n        uint256 indexed loanID,\n        address indexed borrower,\n        address liquidator,\n        int256 collateralOut,\n        uint256 tokensIn\n    );\n}\n"
    },
    "contracts/util/AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Utility library of inline functions on addresses\n *\n * @author develop@teller.finance\n */\nlibrary AddressLib {\n    address public constant ADDRESS_EMPTY = address(0x0);\n\n    /**\n     * @dev Checks if this address is all 0s\n     * @param self The address this function was called on\n     * @return boolean\n     */\n    function isEmpty(address self) internal pure returns (bool) {\n        return self == ADDRESS_EMPTY;\n    }\n\n    /**\n     * @dev Checks if this address is the same as another address\n     * @param self The address this function was called on\n     * @param other Address to check against itself\n     * @return boolean\n     */\n    function isEqualTo(address self, address other)\n        internal\n        pure\n        returns (bool)\n    {\n        return self == other;\n    }\n\n    /**\n     * @dev Checks if this address is different to another address\n     * @param self The address this function was called on\n     * @param other Address to check against itself\n     * @return boolean\n     */\n    function isNotEqualTo(address self, address other)\n        internal\n        pure\n        returns (bool)\n    {\n        return self != other;\n    }\n\n    /**\n     * @dev Checks if this address is not all 0s\n     * @param self The address this function was called on\n     * @return boolean\n     */\n    function isNotEmpty(address self) internal pure returns (bool) {\n        return self != ADDRESS_EMPTY;\n    }\n\n    /**\n     * @dev Throws an error if address is all 0s\n     * @param self The address this function was called on\n     * @param message Error message if address is all 0s\n     */\n    function requireNotEmpty(address self, string memory message)\n        internal\n        pure\n    {\n        require(isNotEmpty(self), message);\n    }\n\n    /**\n     * @dev Throws an error if address is not the same as another address\n     * @param self The address this function was called on\n     * @param other The address to check against itself\n     * @param message Error message if addresses are not the same\n     */\n    function requireEqualTo(\n        address self,\n        address other,\n        string memory message\n    ) internal pure {\n        require(isEqualTo(self, other), message);\n    }\n\n    /**\n     * @dev Throws an error if address is the same as another address\n     * @param self The address this function was called on\n     * @param other The address to check against itself\n     * @param message Error message if addresses are the same\n     */\n    function requireNotEqualTo(\n        address self,\n        address other,\n        string memory message\n    ) internal pure {\n        require(isNotEqualTo(self, other), message);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overloaded;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/interfaces/ITToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Interfaces\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./LendingPoolInterface.sol\";\n\n/**\n    @notice This contract acts as an interface for the Teller token (TToken).\n\n    @author develop@teller.finance\n */\nabstract contract ITToken {\n    /**\n     * @notice The LendingPool linked to this Teller Token.\n     */\n    function lendingPool() external view virtual returns (LendingPoolInterface);\n\n    /**\n     * @notice The token that is the underlying assets for this Teller token.\n     */\n    function underlying() external view virtual returns (ERC20);\n\n    /**\n     * @notice Increase account supply of specified token amount.\n     * @param account The account to mint tokens to.\n     * @param amount The amount of tokens to mint.\n     */\n    function mint(address account, uint256 amount) external virtual;\n\n    /**\n     * @notice Reduce account supply of specified token amount.\n     * @param account The account to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function burn(address account, uint256 amount) external virtual;\n\n    /**\n     * @param lendingPoolAddress the address of the lending pool this token is linked to. It is only used to add it as a minter.\n     */\n    function initialize(address lendingPoolAddress) external virtual;\n}\n"
    },
    "contracts/providers/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    @notice This interface defines the different functions available for a UniswapV2Router.\n    @author develop@teller.finance\n */\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    /**\n        @notice It returns the address of the canonical WETH address;\n    */\n    function WETH() external pure returns (address);\n\n    /**\n        @notice Swaps an exact amount of input tokens for as many output tokens as possible, along the route determined by the path. The first element of path is the input token, the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).\n        @param amountIn The amount of input tokens to send.\n        @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n        @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.\n        @param to Recipient of the output tokens.\n        @param deadline Unix timestamp after which the transaction will revert.\n        @return amounts The input token amount and all subsequent output token amounts.\n        @dev msg.sender should have already given the router an allowance of at least amountIn on the input token.\n     */\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    /**\n        @notice Swaps an exact amount of tokens for as much ETH as possible, along the route determined by the path. The first element of path is the input token, the last must be WETH, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).\n        @param amountIn The amount of input tokens to send.\n        @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n        @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.\n        @param to Recipient of the ETH.\n        @param deadline Unix timestamp after which the transaction will revert.\n        @return amounts The input token amount and all subsequent output token amounts.\n        @dev If the to address is a smart contract, it must have the ability to receive ETH.\n     */\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    /**\n        @notice Swaps an exact amount of ETH for as many output tokens as possible, along the route determined by the path. The first element of path must be WETH, the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).\n        @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n        @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.\n        @param to Recipient of the output tokens.\n        @param deadline Unix timestamp after which the transaction will revert.\n        @return amounts The input token amount and all subsequent output token amounts.\n     */\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/providers/compound/CErc20Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IComptroller.sol\";\n\ninterface CErc20Interface {\n    /*** User Interface ***/\n\n    /**\n        @notice The mint function transfers an asset into the protocol, which begins accumulating interest based on the current Supply Rate for the asset. The user receives a quantity of cTokens equal to the underlying tokens supplied, divided by the current Exchange Rate.\n        @param mintAmount The amount of the asset to be supplied, in units of the underlying asset.\n        @return 0 on success, otherwise an Error code\n        @dev msg.sender The account which shall supply the asset, and own the minted cTokens.\n        @dev Before supplying an asset, users must first approve the cToken to access their token balance.\n     */\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    /**\n        @notice The redeem function converts a specified quantity of cTokens into the underlying asset, and returns them to the user. The amount of underlying tokens received is equal to the quantity of cTokens redeemed, multiplied by the current Exchange Rate. The amount redeemed must be less than the user's Account Liquidity and the market's available liquidity.\n        @param redeemTokens The number of cTokens to be redeemed.\n        @return 0 on success, otherwise an Error code\n        @dev msg.sender The account to which redeemed funds shall be transferred.\n     */\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    /**\n        @notice The redeem underlying function converts cTokens into a specified quantity of the underlying asset, and returns them to the user. The amount of cTokens redeemed is equal to the quantity of underlying tokens received, divided by the current Exchange Rate. The amount redeemed must be less than the user's Account Liquidity and the market's available liquidity.\n        @param redeemAmount The amount of underlying to be redeemed.\n        @return 0 on success, otherwise an Error code\n        @dev msg.sender The account to which redeemed funds shall be transferred.\n     */\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    /**\n        @notice The borrow function transfers an asset from the protocol to the user, and creates a borrow balance which begins accumulating interest based on the Borrow Rate for the asset. The amount borrowed must be less than the user's Account Liquidity and the market's available liquidity.\n        @param borrowAmount The amount of the underlying asset to be borrowed.\n        @return 0 on success, otherwise an Error code\n        @dev msg.sender The account to which borrowed funds shall be transferred.\n     */\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    /**\n        @notice The repay function transfers an asset into the protocol, reducing the user's borrow balance.\n        @param repayAmount The amount of the underlying borrowed asset to be repaid. A value of -1 (i.e. 2^256 - 1) can be used to repay the full amount.\n        @return 0 on success, otherwise an Error code\n        @dev msg.sender The account which borrowed the asset, and shall repay the borrow.\n        @dev Before repaying an asset, users must first approve the cToken to access their token balance.\n     */\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    /**\n        @notice The repay function transfers an asset into the protocol, reducing the target user's borrow balance.\n        @param borrower The account which borrowed the asset to be repaid.\n        @param repayAmount The amount of the underlying borrowed asset to be repaid. A value of -1 (i.e. 2^256 - 1) can be used to repay the full amount.\n        @return 0 on success, otherwise an Error code\n        @dev msg.sender The account which shall repay the borrow.\n        @dev Before repaying an asset, users must first approve the cToken to access their token balance.\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256);\n\n    /*** Admin Functions ***/\n\n    function _addReserves(uint256 addAmount) external returns (uint256);\n\n    /** End Admin Functions */\n\n    function underlying() external view returns (address);\n\n    /**\n        @notice Each cToken is convertible into an ever increasing quantity of the underlying asset, as interest accrues in the market. The exchange rate between a cToken and the underlying asset is\n        equal to: exchangeRate = (getCash() + totalBorrows() - totalReserves()) / totalSupply()\n        @return The current exchange rate as an unsigned integer, scaled by 1e18.\n     */\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n        @notice The user's underlying balance, representing their assets in the protocol, is equal to the user's cToken balance multiplied by the Exchange Rate.\n        @param account The account to get the underlying balance of.\n        @return The amount of underlying currently owned by the account.\n     */\n    function balanceOfUnderlying(address account) external returns (uint256);\n\n    function comptroller() external view returns (IComptroller);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/loans/ILoanData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Commons\nimport \"../../util/TellerCommon.sol\";\n\n// Interfaces\nimport \"./ILoanStorage.sol\";\nimport \"./ILoanTermsConsensus.sol\";\nimport \"../SettingsInterface.sol\";\nimport \"../LendingPoolInterface.sol\";\nimport \"../../providers/compound/CErc20Interface.sol\";\n\n/**\n * @notice This interface defines the functions to get and calculate information about loan data.\n *\n * @author develop@teller.finance\n */\ninterface ILoanData {\n    /**\n     * @notice Checks whether the status of a loan is Active or has Terms Set\n     * @param loanID The loan ID for which to check the status\n     * @return bool value indicating if the loan is active or has terms set\n     */\n    function isActiveOrSet(uint256 loanID) external view returns (bool);\n\n    /**\n     * @notice Returns the total owed amount remaining for a specified loan\n     * @param loanID The ID of the loan to be queried\n     * @return uint256 The total amount owed remaining\n     */\n    function getTotalOwed(uint256 loanID) external view returns (uint256);\n\n    /**\n     * @notice Returns the total amount owed for a specified loan.\n     * @param loanID The loan ID to get the total amount owed.\n     * @return uint256 The amount owed.\n     */\n    function getLoanAmount(uint256 loanID) external view returns (uint256);\n\n    /**\n     * @notice Checks whether the loan's collateral ratio is considered to be secured based on the settings collateral buffer value.\n     * @param loanID The loan ID to check.\n     * @return bool value of it being secured or not.\n     */\n    function isLoanSecured(uint256 loanID) external view returns (bool);\n\n    /**\n     * @notice Checks whether a loan is allowed to be deposited to an Externally Owned Account.\n     * @param loanID The loan ID to check the collateral ratio for.\n     * @return bool indicating whether the loan with specified parameters can be deposited to an EOA.\n     */\n    function canGoToEOA(uint256 loanID) external view returns (bool);\n\n    /**\n     * @notice Returns the amount of interest owed for a given loan and loan amount.\n     * @param loanID The loan ID to get the owed interest.\n     * @param amountBorrow The principal of the loan to take out.\n     * @return uint256 The interest owed.\n     */\n    function getInterestOwedFor(uint256 loanID, uint256 amountBorrow)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the interest ratio based on the loan interest rate for the loan duration.\n     * @dev The interest rate on the loan terms is APY.\n     * @param loanID The loan ID to get the interest rate for.\n     */\n    function getInterestRatio(uint256 loanID) external view returns (uint256);\n\n    /**\n     * @notice Returns the collateral needed for a loan, in the lending token, needed to take out the loan or for it be liquidated.\n     * @param loanID The loan ID for which to get collateral information for\n     * @return uint256 Collateral needed in lending token value\n     */\n    function getCollateralInLendingTokens(uint256 loanID)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get information on the collateral needed for the loan.\n     * @param loanID The loan ID to get collateral info for.\n     * @return neededInLendingTokens int256 Collateral needed in Lending tokens.\n     * @return neededInCollateralTokens int256 Collateral needed in Collateral tokens (wei)\n     * @return escrowLoanValue uint256 The value of the loan held in the escrow contract\n     */\n    function getCollateralNeededInfo(uint256 loanID)\n        external\n        view\n        returns (\n            int256 neededInLendingTokens,\n            int256 neededInCollateralTokens,\n            uint256 escrowLoanValue\n        );\n\n    /**\n     * @notice Returns the minimum collateral value threshold, in the lending token, needed to take out the loan or for it be liquidated.\n     * @dev If the loan status is TermsSet, then the value is whats needed to take out the loan.\n     * @dev If the loan status is Active, then the value is the threshold at which the loan can be liquidated at.\n     * @param loanID The loan ID to get needed collateral info for.\n     * @return neededInLendingTokens int256 The minimum collateral value threshold required.\n     * @return escrowLoanValue uint256 The value of the loan held in the escrow contract.\n     */\n    function getCollateralNeededInTokens(uint256 loanID)\n        external\n        view\n        returns (int256 neededInLendingTokens, uint256 escrowLoanValue);\n\n    /**\n     * @notice It checks if a loan can be liquidated.\n     * @param loanID The loan ID to check.\n     * @return true if the loan is liquidable.\n     */\n    function isLiquidable(uint256 loanID) external view returns (bool);\n\n    /**\n     * @notice It gets the current liquidation reward for a given loan.\n     * @param loanID The loan ID to get the info.\n     * @return The value the liquidator will receive denoted in collateral tokens.\n     */\n    function getLiquidationReward(uint256 loanID)\n        external\n        view\n        returns (int256);\n}\n"
    },
    "contracts/interfaces/loans/ILoanStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Commons\nimport \"../../util/TellerCommon.sol\";\n\n// Interfaces\nimport \"../SettingsInterface.sol\";\nimport \"../LendingPoolInterface.sol\";\nimport \"./ILoanTermsConsensus.sol\";\nimport \"../../providers/compound/CErc20Interface.sol\";\n\n/**\n    Getting stack too deep issues and cannot get the proper\n    struct as a return value from calling loans() externally.\n    So we are just providing helpers here to get individual\n    fields on a storage pointer of the loan by loanId.\n */\nabstract contract ALoanStorage {\n    /**\n     * @notice Holds the data of all loans for the lending token.\n     */\n    mapping(uint256 => TellerCommon.Loan) public loans;\n\n    function loanTerms(uint256 loanId)\n        public\n        view\n        returns (TellerCommon.LoanTerms memory)\n    {\n        return loan(loanId).loanTerms;\n    }\n\n    function termsExpiry(uint256 loanId) public view returns (uint256) {\n        return loan(loanId).termsExpiry;\n    }\n\n    function loanStartTime(uint256 loanId) public view returns (uint256) {\n        return loan(loanId).loanStartTime;\n    }\n\n    function collateral(uint256 loanId) public view returns (uint256) {\n        return loan(loanId).collateral;\n    }\n\n    function lastCollateralIn(uint256 loanId) public view returns (uint256) {\n        return loan(loanId).lastCollateralIn;\n    }\n\n    function principalOwed(uint256 loanId) public view returns (uint256) {\n        return loan(loanId).principalOwed;\n    }\n\n    function interestOwed(uint256 loanId) public view returns (uint256) {\n        return loan(loanId).interestOwed;\n    }\n\n    function borrowedAmount(uint256 loanId) public view returns (uint256) {\n        return loan(loanId).borrowedAmount;\n    }\n\n    function escrow(uint256 loanId) public view returns (address) {\n        return loan(loanId).escrow;\n    }\n\n    function status(uint256 loanId)\n        public\n        view\n        returns (TellerCommon.LoanStatus)\n    {\n        return loan(loanId).status;\n    }\n\n    function liquidated(uint256 loanId) public view returns (bool) {\n        return loan(loanId).liquidated;\n    }\n\n    function loan(uint256 loanId)\n        internal\n        view\n        returns (TellerCommon.Loan storage loan_)\n    {\n        loan_ = loans[loanId];\n    }\n}\n\n/**\n * @notice This interface defines the functions to get and calculate information about loan data.\n *\n * @author develop@teller.finance\n */\ninterface ILoanStorage {\n    /**\n     * @notice Holds the total amount of collateral held by the contract.\n     */\n    function totalCollateral() external view returns (uint256);\n\n    /**\n     * @notice Holds the instance of the LendingPool used by the LoanManager.\n     */\n    function lendingPool() external view returns (LendingPoolInterface);\n\n    /**\n     * @notice Holds the lending token used for creating loans by the LoanManager and LendingPool.\n     */\n    function lendingToken() external view returns (address);\n\n    /**\n     * @notice Holds the collateral token.\n     */\n    function collateralToken() external view returns (address);\n\n    /**\n     * @notice Holds the Compound cToken where the underlying token matches the lending token.\n     */\n    function cToken() external view returns (CErc20Interface);\n\n    /**\n     * @notice Holds the ID of loans taken out\n     * @dev Also the next available loan ID\n     */\n    function loanIDCounter() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/loans/ILoanTermsConsensus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../util/TellerCommon.sol\";\n\n/**\n    @notice This interface defines the function to process the loan terms through the Teller protocol\n\n    @author develop@teller.finance\n */\ninterface ILoanTermsConsensus {\n    /**\n        @notice Processes the loan request\n        @param request Struct of the protocol loan request\n        @param responses List of structs of the protocol loan responses\n        @return uint256 Interest rate\n        @return uint256 Collateral ratio\n        @return uint256 Maximum loan amount\n     */\n    function processLoanTerms(\n        TellerCommon.LoanRequest calldata request,\n        TellerCommon.LoanResponse[] calldata responses\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n}\n"
    },
    "contracts/providers/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IComptroller {\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens)\n        external\n        returns (uint256[] memory);\n\n    function exitMarket(address cToken) external returns (uint256);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256);\n\n    function mintVerify(\n        address cToken,\n        address minter,\n        uint256 mintAmount,\n        uint256 mintTokens\n    ) external;\n\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256);\n\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external;\n\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256);\n\n    function borrowVerify(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external;\n\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256);\n\n    function transferVerify(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external;\n\n    function claimComp(address holder) external;\n\n    function claimComp(address holder, address[] calldata cTokens) external;\n\n    function claimComp(\n        address[] calldata holders,\n        address[] calldata cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 repayAmount\n    ) external view returns (uint256, uint256);\n\n    function getCompAddress() external view returns (address);\n}\n"
    },
    "contracts/base/upgradeable/DynamicUpgradeableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Interfaces\nimport \"../../interfaces/LogicVersionsRegistryInterface.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                        THIS CONTRACT IS A NON UPGRADEABLE STORAGE CONTRACT!                     **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of, PREPEND, or APPEND any storage variables to this or new versions   **/\n/**  of this contract as this will cause a ripple affect to the storage slots of all child          **/\n/**  contracts that inherit from this contract to be overwritten on the deployed proxy contract!!   **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract is used define the storage variables for all DynamicUpgradeable contracts.\n\n    @author develop@teller.finance\n */\nabstract contract DynamicUpgradeableStorage {\n    /**\n     * @notice It returns the logic registry that is used to determine the implementation logic for this proxy.\n     * @dev See LogicVersionsRegistry contract.\n     * @return LogicVersionsRegistryInterface\n     */\n    LogicVersionsRegistryInterface public logicRegistry;\n\n    /**\n     * @notice It represent the logic name (key) used for this proxy.\n     * @dev It is used by LogicVersionsRegistry to get the logic address for the given logic name.\n     * @dev It must NOT change over time.\n     * @return bytes32 the logic name.\n     */\n    bytes32 public logicName;\n\n    /**\n     * @notice Boolean indicating if the proxy must check the registry for a new implementation.\n     */\n    bool public strictDynamic;\n\n    /**\n     * @notice It stores the last known logic address locally to reduce gas costs.\n     */\n    address public implementationStored;\n\n    /**\n     * @dev It is the block number which the last time the proxy implementation was checked.\n     */\n    uint256 internal _implementationBlockUpdated;\n}\n"
    },
    "contracts/interfaces/LogicVersionsRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Commons\nimport \"../util/LogicVersionLib.sol\";\nimport \"../util/TellerCommon.sol\";\n\n/**\n    @notice It defines all the functions to manage the logic contract versions.\n\n    @author develop@teller.finance\n */\ninterface LogicVersionsRegistryInterface {\n    /**\n        @notice This event is emitted when a new logic version is created.\n        @param logicName new logic name.\n        @param logic address where the logic is.\n        @param version initial version for the logic address.\n     */\n    event LogicVersionCreated(\n        bytes32 indexed logicName,\n        address indexed logic,\n        uint256 version\n    );\n\n    /**\n        @notice This event is emitted when a logic version is rollbacked.\n        @param logicName the logic name.\n        @param oldLogic the old logic address.\n        @param newLogic the new (or previous) logic address.\n        @param oldVersion the old version.\n        @param newVersion the new (previous) version.\n     */\n    event LogicVersionRollbacked(\n        bytes32 indexed logicName,\n        address oldLogic,\n        address newLogic,\n        uint256 oldVersion,\n        uint256 newVersion\n    );\n\n    /**\n        @notice This event is emitted when a new logic version is upgraded.\n        @param logicName new logic name.\n        @param oldLogic the old logic address.\n        @param newLogic the new logic address.\n        @param oldVersion the old version.\n        @param newVersion the new version.\n     */\n    event LogicVersionUpgraded(\n        bytes32 indexed logicName,\n        address oldLogic,\n        address newLogic,\n        uint256 oldVersion,\n        uint256 newVersion\n    );\n\n    /** External Functions */\n\n    /**\n        @notice It creates multiple logic versions.\n        @param newLogicVersions lists of the new logic versions to create.\n     */\n    function createLogicVersions(\n        TellerCommon.CreateLogicVersionRequest[] calldata newLogicVersions\n    ) external;\n\n    /**\n        @notice It upgrades multiple logic addresses.\n        @param newLogicVersions lists of the new logic versions to create.\n     */\n    function upgradeLogicVersions(\n        TellerCommon.UpgradeLogicVersionRequest[] calldata newLogicVersions\n    ) external;\n\n    /**\n        @notice It upgrades a logic version given a logic name.\n        @param logicName logic name to upgrade.\n        @param newLogic the new logic address to set.\n        @param proxy The (optional) DynamicUpgradeable proxy address to attempt to directly upgrade.\n     */\n    function upgradeLogicVersion(\n        bytes32 logicName,\n        address newLogic,\n        address proxy\n    ) external;\n\n    /**\n        @notice It rollbacks a logic to a previous version.\n        @param logicName logic name to rollback.\n        @param previousVersion the previous version to be used.\n     */\n    function rollbackLogicVersion(bytes32 logicName, uint256 previousVersion)\n        external;\n\n    /**\n        @notice It gets the current logic version for a given logic name.\n        @param logicName to get.\n        @return currentVersion the current logic version number.\n        @return latestVersion the latest version number (higher than current if rolled back).\n        @return logic the address of the current logic version\n     */\n    function getLogicVersion(bytes32 logicName)\n        external\n        view\n        returns (\n            uint256 currentVersion,\n            uint256 latestVersion,\n            address logic\n        );\n\n    /**\n        @notice It tests whether a logic name is already configured.\n        @param logicName logic name to test.\n        @return true if the logic version is already configured. Otherwise it returns false.\n     */\n    function hasLogicVersion(bytes32 logicName) external view returns (bool);\n\n    /**\n        @notice It initializes this logic versions registry contract instance.\n        @param aOwner address of the owner of the registry.\n        @param initialLogicVersions lists of the new logic versions to create.\n     */\n    function initialize(\n        address aOwner,\n        TellerCommon.CreateLogicVersionRequest[] calldata initialLogicVersions\n    ) external;\n}\n"
    },
    "contracts/util/LogicVersionLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n    @notice This library manages the functions for the logic version struct.\n\n    @author develop@teller.finance\n */\nlibrary LogicVersionLib {\n    using SafeMath for uint256;\n    using Address for address;\n\n    /**\n        @notice It stores all the versions for a given logic.\n        @param currentVersion the current version.\n        @param latestVersion the latest version.\n        @param versions mapping version to logic address.\n        @param exists boolean to test whether this logic version exists or not.\n     */\n    struct LogicVersion {\n        uint256 currentVersion;\n        uint256 latestVersion;\n        mapping(uint256 => address) versions;\n        bool exists;\n    }\n\n    /**\n        @notice It creates a new logic version.\n        @param self the current logic version instance.\n        @param logic initial logic address.\n     */\n    function initialize(LogicVersion storage self, address logic) internal {\n        requireNotExists(self);\n        require(logic.isContract(), \"LOGIC_MUST_BE_CONTRACT\");\n        self.currentVersion = 0;\n        self.latestVersion = 0;\n        self.versions[self.currentVersion] = logic;\n        self.exists = true;\n    }\n\n    /**\n        @notice It rollbacks a logic to a previous version.\n        @param self the current logic version instance.\n        @param previousVersion the previous version to be used.\n     */\n    function rollback(LogicVersion storage self, uint256 previousVersion)\n        internal\n        returns (\n            uint256 currentVersion,\n            address previousLogic,\n            address newLogic\n        )\n    {\n        requireExists(self);\n        require(\n            self.currentVersion != previousVersion,\n            \"CURRENT_VERSION_MUST_BE_DIFF\"\n        );\n        require(\n            self.latestVersion >= previousVersion,\n            \"VERSION_MUST_BE_LTE_LATEST\"\n        );\n        currentVersion = self.currentVersion;\n        previousLogic = self.versions[self.currentVersion];\n        newLogic = self.versions[previousVersion];\n\n        self.currentVersion = previousVersion;\n    }\n\n    /**\n        @notice Checks whether the current logic version exists or not.\n        @dev It throws a require error if the logic version already exists.\n        @param self the current logic version.\n     */\n    function requireNotExists(LogicVersion storage self) internal view {\n        require(!self.exists, \"LOGIC_ALREADY_EXISTS\");\n    }\n\n    /**\n        @notice Checks whether the current logic version exists or not.\n        @dev It throws a require error if the current logic version doesn't exist.\n        @param self the current logic version.\n     */\n    function requireExists(LogicVersion storage self) internal view {\n        require(self.exists, \"LOGIC_NOT_EXISTS\");\n    }\n\n    /**\n        @notice It upgrades a logic version.\n        @dev It throws a require error if:\n            - The new logic is equal to the current logic.\n        @param self the current logic version.\n        @param newLogic the new logic to set in the logic version.\n        @return oldLogic the old logic address.\n        @return oldVersion the old version.\n        @return newVersion the new version.\n     */\n    function upgrade(LogicVersion storage self, address newLogic)\n        internal\n        returns (\n            address oldLogic,\n            uint256 oldVersion,\n            uint256 newVersion\n        )\n    {\n        requireExists(self);\n        require(\n            self.versions[self.currentVersion] != newLogic,\n            \"NEW_LOGIC_REQUIRED\"\n        );\n        require(newLogic.isContract(), \"LOGIC_MUST_BE_CONTRACT\");\n        oldLogic = self.versions[self.currentVersion];\n        oldVersion = self.currentVersion;\n        newVersion = self.latestVersion.add(1);\n\n        self.currentVersion = newVersion;\n        self.latestVersion = newVersion;\n        self.versions[newVersion] = newLogic;\n    }\n}\n"
    },
    "contracts/base/settings/AssetSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../util/AddressLib.sol\";\nimport \"../../util/CacheLib.sol\";\n\n// Contracts\nimport \"../Base.sol\";\n\n// Interfaces\nimport \"../../interfaces/AssetSettingsInterface.sol\";\nimport \"../../providers/compound/CErc20Interface.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice Asset settings contract for a specific asset on the protocol.\n\n    @author develop@teller.finance\n */\ncontract AssetSettings is AssetSettingsInterface, Base {\n    using AddressLib for address;\n    using CacheLib for CacheLib.Cache;\n\n    /**\n          @dev This mapping represents the asset settings where:\n\n          - The key is the asset address.\n          - The value is the Cache for all asset settings. It includes the settings addresses, uints, ints, bytes and boolean values.\n       */\n    mapping(address => CacheLib.Cache) internal assets;\n\n    /** Constants */\n    /**\n          @dev The asset setting name for cToken address settings.\n       */\n    bytes32 internal constant CTOKEN_ADDRESS_ASSET_SETTING =\n        keccak256(\"CTokenAddress\");\n\n    /**\n          @dev The asset setting name for aToken address settings.\n       */\n    bytes32 internal constant ATOKEN_ADDRESS_ASSET_SETTING =\n        keccak256(\"ATokenAddress\");\n\n    /**\n          @dev The asset setting name for yearn vault address settings.\n       */\n    bytes32 internal constant YEARN_VAULT_ADDRESS_ASSET_SETTING =\n        keccak256(\"YVaultAddress\");\n\n    /**\n          @dev The asset setting name for pool together's prize pool address settings.\n       */\n    bytes32 internal constant PRIZE_POOL_ADDRESS_ASSET_SETTING =\n        keccak256(\"PrizePoolAddress\");\n\n    /**\n          @dev The asset setting name for the maximum loan amount settings.\n       */\n    bytes32 internal constant MAX_LOAN_AMOUNT_ASSET_SETTING =\n        keccak256(\"MaxLoanAmount\");\n\n    /**\n          @dev The asset setting name for the maximum total value locked settings.\n       */\n    bytes32 internal constant MAX_TOTAL_VALUE_LOCKED_SETTING =\n        keccak256(\"MaxTVLAmount\");\n\n    /**\n          @dev The asset setting name for the maximum debt ratio settings.\n       */\n    bytes32 internal constant MAX_DEBT_RATIO_SETTING =\n        keccak256(\"MaxDebtRatio\");\n\n    /**\n      @notice It creates an asset with the given parameters.\n      @param assetAddress asset address used to create the new setting.\n      @param cTokenAddress cToken address used to configure the asset setting.\n      @param maxLoanAmount the initial max loan amount.\n      @param maxTVLAmount the initial max total value locked amount.\n      @param maxDebtRatio the initial max debt ratio amount.\n      */\n    function createAssetSetting(\n        address assetAddress,\n        address cTokenAddress,\n        uint256 maxLoanAmount,\n        uint256 maxTVLAmount,\n        uint256 maxDebtRatio\n    ) external override onlyPauser() {\n        assetAddress.requireNotEmpty(\"ASSET_ADDRESS_REQUIRED\");\n        cTokenAddress.requireNotEmpty(\"CTOKEN_ADDRESS_REQUIRED\");\n\n        if (assetAddress != settings.ETH_ADDRESS()) {\n            (bool success, bytes memory decimalsData) =\n                assetAddress.staticcall(abi.encodeWithSignature(\"decimals()\"));\n            require(\n                success && decimalsData.length > 0,\n                \"DECIMALS_NOT_SUPPORTED\"\n            );\n            require(\n                CErc20Interface(cTokenAddress).underlying() == assetAddress,\n                \"UNDERLYING_ASSET_MISMATCH\"\n            );\n        }\n\n        assets[assetAddress].initialize();\n        assets[assetAddress].updateAddress(\n            CTOKEN_ADDRESS_ASSET_SETTING,\n            cTokenAddress\n        );\n        if (maxLoanAmount > 0) {\n            assets[assetAddress].updateUint(\n                MAX_LOAN_AMOUNT_ASSET_SETTING,\n                maxLoanAmount\n            );\n        }\n        if (maxTVLAmount > 0) {\n            assets[assetAddress].updateUint(\n                MAX_TOTAL_VALUE_LOCKED_SETTING,\n                maxTVLAmount\n            );\n        }\n        if (maxDebtRatio > 0) {\n            assets[assetAddress].updateUint(\n                MAX_DEBT_RATIO_SETTING,\n                maxDebtRatio\n            );\n        }\n\n        emit AssetSettingsCreated(\n            msg.sender,\n            assetAddress,\n            cTokenAddress,\n            maxLoanAmount\n        );\n    }\n\n    /**\n     * @notice It checks if the settings have been initialized for an asset address.\n     */\n    function isInitialized(address assetAddress)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return assets[assetAddress].exists();\n    }\n\n    /**\n      @notice It updates the cToken address associated with an asset.\n      @param assetAddress asset address to configure.\n      @param cTokenAddress the new cToken address to configure.\n      */\n    function updateCTokenAddress(address assetAddress, address cTokenAddress)\n        external\n        override\n        onlyPauser()\n    {\n        cTokenAddress.requireNotEmpty(\"CTOKEN_ADDRESS_REQUIRED\");\n        address oldCTokenAddress =\n            assets[assetAddress].addresses[CTOKEN_ADDRESS_ASSET_SETTING];\n\n        assets[assetAddress].updateAddress(\n            CTOKEN_ADDRESS_ASSET_SETTING,\n            cTokenAddress\n        );\n\n        emit AssetSettingsAddressUpdated(\n            CTOKEN_ADDRESS_ASSET_SETTING,\n            msg.sender,\n            assetAddress,\n            oldCTokenAddress,\n            cTokenAddress\n        );\n    }\n\n    /**\n      @notice It returns the cToken address associated with an asset.\n      @param assetAddress asset address to get the associated cToken for.\n      @return The associated cToken address\n      */\n    function getCTokenAddress(address assetAddress)\n        external\n        view\n        override\n        returns (address)\n    {\n        assetAddress.requireNotEmpty(\"ASSET_ADDRESS_REQUIRED\");\n\n        return assets[assetAddress].addresses[CTOKEN_ADDRESS_ASSET_SETTING];\n    }\n\n    /**\n      @notice It updates the yearn vault address associated with an asset.\n      @param assetAddress asset address to configure.\n      @param yVaultAddress the new yVault address to configure.\n      */\n    function updateYVaultAddressSetting(\n        address assetAddress,\n        address yVaultAddress\n    ) external override onlyPauser() {\n        assets[assetAddress].updateAddress(\n            YEARN_VAULT_ADDRESS_ASSET_SETTING,\n            yVaultAddress\n        );\n    }\n\n    /**\n      @notice It returns the yearn vault address associated with an asset.\n      @param assetAddress asset address to get the associated yearn vault address for.\n      @return The address of the yearn vault.\n      */\n    function getYVaultAddress(address assetAddress)\n        external\n        view\n        override\n        returns (address)\n    {\n        assetAddress.requireNotEmpty(\"ASSET_ADDRESS_REQUIRED\");\n\n        return\n            assets[assetAddress].addresses[YEARN_VAULT_ADDRESS_ASSET_SETTING];\n    }\n\n    /**\n      @notice It updates the aToken address associated with an asset.\n      @param assetAddress asset address to configure.\n      @param aTokenAddress the new aToken address to configure.\n      */\n    function updateATokenAddress(address assetAddress, address aTokenAddress)\n        external\n        override\n        onlyPauser()\n    {\n        aTokenAddress.requireNotEmpty(\"ATOKEN_ADDRESS_REQUIRED\");\n        address oldATokenAddress =\n            assets[assetAddress].addresses[ATOKEN_ADDRESS_ASSET_SETTING];\n\n        assets[assetAddress].updateAddress(\n            ATOKEN_ADDRESS_ASSET_SETTING,\n            aTokenAddress\n        );\n\n        emit AssetSettingsAddressUpdated(\n            ATOKEN_ADDRESS_ASSET_SETTING,\n            msg.sender,\n            assetAddress,\n            oldATokenAddress,\n            aTokenAddress\n        );\n    }\n\n    /**\n      @notice It returns the aToken address associated with an asset.\n      @param assetAddress asset address to get the associated aToken for.\n      @return The associated aToken address\n      */\n    function getATokenAddress(address assetAddress)\n        external\n        view\n        override\n        returns (address)\n    {\n        assetAddress.requireNotEmpty(\"ASSET_ADDRESS_REQUIRED\");\n\n        return assets[assetAddress].addresses[ATOKEN_ADDRESS_ASSET_SETTING];\n    }\n\n    /**\n      @notice It updates the pool together prize pool address associated with an asset.\n      @param assetAddress asset address to configure.\n      @param prizePoolAddress the new aToken address to configure.\n      */\n    function updatePrizePoolAddress(\n        address assetAddress,\n        address prizePoolAddress\n    ) external override onlyPauser() {\n        prizePoolAddress.requireNotEmpty(\"PRIZE_POOL_ADDRESS_REQUIRED\");\n        address oldPrizePoolAddress =\n            assets[assetAddress].addresses[PRIZE_POOL_ADDRESS_ASSET_SETTING];\n\n        assets[assetAddress].updateAddress(\n            PRIZE_POOL_ADDRESS_ASSET_SETTING,\n            prizePoolAddress\n        );\n\n        emit AssetSettingsAddressUpdated(\n            PRIZE_POOL_ADDRESS_ASSET_SETTING,\n            msg.sender,\n            assetAddress,\n            oldPrizePoolAddress,\n            prizePoolAddress\n        );\n    }\n\n    /**\n      @notice It returns the pool together prize pool address associated with an asset.\n      @param assetAddress asset address to get the associated aToken for.\n      @return The associated prize pool address\n      */\n    function getPrizePoolAddress(address assetAddress)\n        external\n        view\n        override\n        returns (address)\n    {\n        assetAddress.requireNotEmpty(\"ASSET_ADDRESS_REQUIRED\");\n\n        return assets[assetAddress].addresses[PRIZE_POOL_ADDRESS_ASSET_SETTING];\n    }\n\n    /**\n      @notice It updates the max loan amount for a given asset.\n      @param assetAddress asset address used to update the max loan amount.\n      @param newMaxLoanAmount the new max loan amount to set.\n      */\n    function updateMaxLoanAmount(address assetAddress, uint256 newMaxLoanAmount)\n        external\n        override\n        onlyPauser()\n    {\n        assets[assetAddress].requireExists();\n        uint256 oldMaxLoanAmount =\n            assets[assetAddress].uints[MAX_LOAN_AMOUNT_ASSET_SETTING];\n\n        assets[assetAddress].updateUint(\n            MAX_LOAN_AMOUNT_ASSET_SETTING,\n            newMaxLoanAmount\n        );\n\n        emit AssetSettingsUintUpdated(\n            MAX_LOAN_AMOUNT_ASSET_SETTING,\n            msg.sender,\n            assetAddress,\n            oldMaxLoanAmount,\n            newMaxLoanAmount\n        );\n    }\n\n    /**\n      @notice Returns the max loan amount for a given asset.\n      @param assetAddress asset address to retrieve the max loan amount.\n      */\n    function getMaxLoanAmount(address assetAddress)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        assets[assetAddress].requireExists();\n\n        return assets[assetAddress].uints[MAX_LOAN_AMOUNT_ASSET_SETTING];\n    }\n\n    /**\n      @notice Tests whether a given amount is greater than the current max loan amount.\n      @param assetAddress asset address used to return the max loan amount setting.\n      @param amount the loan amount to check.\n      @return true if the given amount is greater than the current max loan amount. Otherwise it returns false.\n      */\n    function exceedsMaxLoanAmount(address assetAddress, uint256 amount)\n        external\n        view\n        override\n        returns (bool)\n    {\n        assets[assetAddress].requireExists();\n        return\n            amount > assets[assetAddress].uints[MAX_LOAN_AMOUNT_ASSET_SETTING];\n    }\n\n    /**\n      @notice It updates the max total value locked amount for a given asset.\n      @param assetAddress asset address used to update the max loan amount.\n      @param newMaxTVLAmount the new max total vault locked amount to set.\n      */\n    function updateMaxTVL(address assetAddress, uint256 newMaxTVLAmount)\n        external\n        override\n        onlyPauser()\n    {\n        assets[assetAddress].requireExists();\n        if (\n            newMaxTVLAmount !=\n            assets[assetAddress].uints[MAX_TOTAL_VALUE_LOCKED_SETTING]\n        ) {\n            assets[assetAddress].updateUint(\n                MAX_TOTAL_VALUE_LOCKED_SETTING,\n                newMaxTVLAmount\n            );\n        }\n    }\n\n    /**\n      @notice Returns the max total value locked amount for a given asset.\n      @param assetAddress asset address to retrieve the max total value locked amount.\n      */\n    function getMaxTVLAmount(address assetAddress)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        assets[assetAddress].requireExists();\n\n        return assets[assetAddress].uints[MAX_TOTAL_VALUE_LOCKED_SETTING];\n    }\n\n    /**\n      @notice It updates the max debt ratio for a given asset.\n      @dev The ratio value has 2 decimal places. I.e 100 = 1%\n      @param assetAddress asset address used to update the max debt ratio.\n      @param newMaxDebtRatio the new max debt ratio to set.\n      */\n    function updateMaxDebtRatio(address assetAddress, uint256 newMaxDebtRatio)\n        external\n        override\n        onlyPauser()\n    {\n        assets[assetAddress].requireExists();\n        if (\n            newMaxDebtRatio !=\n            assets[assetAddress].uints[MAX_DEBT_RATIO_SETTING]\n        ) {\n            assets[assetAddress].updateUint(\n                MAX_DEBT_RATIO_SETTING,\n                newMaxDebtRatio\n            );\n        }\n    }\n\n    /**\n      @notice Returns the max debt ratio for a given asset.\n      @dev The ratio value has 2 decimal places. I.e 100 = 1%\n      @param assetAddress asset address to retrieve the max debt ratio.\n      */\n    function getMaxDebtRatio(address assetAddress)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        assets[assetAddress].requireExists();\n        return assets[assetAddress].uints[MAX_DEBT_RATIO_SETTING];\n    }\n\n    /**\n      @notice It removes a configuration for a given asset on the platform.\n      @param assetAddress asset address to remove.\n      */\n    function removeAsset(address assetAddress) external override onlyPauser() {\n        assets[assetAddress].requireExists();\n        assets[assetAddress].clearCache(\n            [\n                MAX_LOAN_AMOUNT_ASSET_SETTING,\n                MAX_TOTAL_VALUE_LOCKED_SETTING,\n                CTOKEN_ADDRESS_ASSET_SETTING,\n                YEARN_VAULT_ADDRESS_ASSET_SETTING,\n                PRIZE_POOL_ADDRESS_ASSET_SETTING\n            ],\n            [\n                CacheLib.CacheType.Uint,\n                CacheLib.CacheType.Uint,\n                CacheLib.CacheType.Address,\n                CacheLib.CacheType.Address,\n                CacheLib.CacheType.Address\n            ]\n        );\n        delete assets[assetAddress];\n        emit AssetSettingsRemoved(msg.sender, assetAddress);\n    }\n\n    function initialize() external override {\n        _initialize(msg.sender);\n    }\n}\n"
    },
    "contracts/base/settings/Settings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../util/AddressLib.sol\";\nimport \"../../util/PlatformSettingsLib.sol\";\nimport \"../../util/AddressArrayLib.sol\";\nimport \"../../util/CacheLib.sol\";\nimport \"../../providers/openzeppelin/Roles.sol\";\n\n// Contracts\nimport \"../proxies/InitializeableDynamicProxy.sol\";\nimport \"./AssetSettings.sol\";\nimport \"../LogicVersionsRegistry.sol\";\nimport \"../DappRegistry.sol\";\nimport \"../PriceAggregator.sol\";\nimport \"../Factory.sol\";\n\n// Interfaces\nimport \"../../interfaces/SettingsInterface.sol\";\nimport \"../../interfaces/IDappRegistry.sol\";\nimport \"../../interfaces/IPriceAggregator.sol\";\nimport \"../../providers/compound/CErc20Interface.sol\";\nimport \"../../interfaces/AssetSettingsInterface.sol\";\nimport \"../../interfaces/IMarketFactory.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract manages the configuration of the platform.\n    @dev The platform settings functions (create, update, and remove) don't include the whenNotPaused()\n    modifier because we might need to use them in both cases (when the platform is paused and not paused).\n        Example:\n            - There is a potential issue and before analyzing it, we pause the platform to avoid funds losses.\n            Finally, as result of the analysis, we decided to update a platform setting (or create a new one for the\n            cloud nodes). In this scenario, if the modifier is present, we couldn't update the setting\n            (because the platform is paused).\n\n    @author develop@teller.finance\n */\ncontract Settings is SettingsInterface, Base, Factory {\n    using AddressLib for address;\n    using Address for address;\n    using AddressArrayLib for address[];\n    using PlatformSettingsLib for PlatformSettingsLib.PlatformSetting;\n    using Roles for Roles.Role;\n    using CacheLib for CacheLib.Cache;\n\n    /** Constants */\n\n    /**\n        @dev The setting name for the required subsmission settings.\n        @dev This is the minimum percentage of node responses that will be required by the platform to either take out a loan, and to claim accrued interest. If the number of node responses are less than the ones specified here, the loan or accrued interest claim request will be rejected by the platform\n     */\n    bytes32 internal constant REQUIRED_SUBMISSIONS_PERCENTAGE_SETTING =\n        keccak256(\"RequiredSubmissionsPercentage\");\n\n    /**\n        @dev The setting name for the maximum tolerance settings.\n        @dev This is the maximum tolerance for the values submitted (by nodes) when they are aggregated (average). It is used in the consensus mechanisms.\n        @dev This is a percentage value with 2 decimal places.\n            i.e. maximumTolerance of 325 => tolerance of 3.25% => 0.0325 of value\n            i.e. maximumTolerance of 0 => It means all the values submitted must be equals.\n        @dev The max value is 100% => 10000\n     */\n    bytes32 internal constant MAXIMUM_TOLERANCE_SETTING =\n        keccak256(\"MaximumTolerance\");\n    /**\n        @dev The setting name for the response expiry length settings.\n        @dev This is the maximum time (in seconds) a node has to submit a response. After that time, the response is considered expired and will not be accepted by the protocol.\n     */\n\n    bytes32 internal constant RESPONSE_EXPIRY_LENGTH_SETTING =\n        keccak256(\"ResponseExpiryLength\");\n\n    /**\n        @dev The setting name for the safety interval settings.\n        @dev This is the minimum time you need to wait (in seconds) between the last time you deposit collateral and you take out the loan.\n        @dev It is used to avoid potential attacks using Flash Loans (AAVE) or Flash Swaps (Uniswap V2).\n     */\n    bytes32 internal constant SAFETY_INTERVAL_SETTING =\n        keccak256(\"SafetyInterval\");\n\n    /**\n        @dev The setting name for the term expiry time settings.\n        @dev This represents the time (in seconds) that loan terms will be available after requesting them.\n        @dev After this time, the loan terms will expire and the borrower will need to request it again.\n     */\n    bytes32 internal constant TERMS_EXPIRY_TIME_SETTING =\n        keccak256(\"TermsExpiryTime\");\n\n    /**\n        @dev The setting name for the liquidate ETH price settings.\n        @dev It represents the percentage value (with 2 decimal places) to liquidate loans.\n            i.e. an ETH liquidation price at 95% is stored as 9500\n     */\n    bytes32 internal constant LIQUIDATE_ETH_PRICE_SETTING =\n        keccak256(\"LiquidateEthPrice\");\n\n    /**\n        @dev The setting name for the maximum loan duration settings.\n        @dev The maximum loan duration setting is defined in seconds. Loans will not be given for timespans larger than the one specified here.\n     */\n    bytes32 internal constant MAXIMUM_LOAN_DURATION_SETTING =\n        keccak256(\"MaximumLoanDuration\");\n\n    /**\n        @dev The setting name for the request loan terms rate limit settings.\n        @dev The request loan terms rate limit setting is defined in seconds.\n     */\n    bytes32 internal constant REQUEST_LOAN_TERMS_RATE_LIMIT_SETTING =\n        keccak256(\"RequestLoanTermsRateLimit\");\n\n    /**\n        @dev The setting name for the collateral buffer.\n        @dev The collateral buffer is a safety buffer above the required collateral amount to liquidate a loan. It is required to ensure the loan does not get liquidated immediately after the loan is taken out if the value of the collateral asset deposited drops drastically.\n        @dev It represents the percentage value (with 2 decimal places) of a collateral buffer.\n            e.g.: collateral buffer at 100% is stored as 10000.\n     */\n    bytes32 internal constant COLLATERAL_BUFFER_SETTING =\n        keccak256(\"CollateralBuffer\");\n\n    /**\n        @dev The setting name for the over collateralized buffer.\n        @dev The over collateralized buffer is the minimum required collateral ratio in order for a loan to be taken out without an Escrow contract and for the funds to go to the borrower's EOA (external overridely owned account).\n        @dev It represents the percentage value (with 2 decimal places) of a over collateralized buffer.\n            e.g.: over collateralized buffer at 130% is stored as 13000.\n     */\n    bytes32 internal constant OVER_COLLATERALIZED_BUFFER_SETTING =\n        keccak256(\"OverCollateralizedBuffer\");\n\n    /* State Variables */\n\n    /**\n        @notice It represents a mapping to identify the lending pools paused and not paused.\n\n        i.e.: address(lending pool) => true or false.\n     */\n    mapping(address => bool) public override lendingPoolPaused;\n\n    /**\n        @notice It represents a mapping to configure the asset settings.\n        @notice The key belongs to the asset address. Example: address(DAI) or address(USDC).\n        @notice The value has the asset settings.\n\n        Examples:\n\n        address(DAI) => {\n            cTokenAddress = 0x1234...890\n            maxLoanAmount = 1000 DAI (max)\n        }\n        address(USDC) => {\n            cTokenAddress = 0x2345...901\n            maxLoanAmount = 500 USDC (max)\n        }\n     */\n\n    /**\n        @notice It is the global instance of the AssetSettings contract.\n     */\n    AssetSettingsInterface public override assetSettings;\n\n    /**\n        @dev This mapping represents the platform settings where:\n\n        - The key is the platform setting name.\n        - The value is the platform setting. It includes the value, minimum and maximum values.\n     */\n    mapping(bytes32 => PlatformSettingsLib.PlatformSetting)\n        private _platformSettings;\n\n    /**\n     * @dev It holds storage values that can be set in a storage slot.\n     */\n    CacheLib.Cache internal cacheStorage;\n\n    /**\n        @notice It is the global instance of the dapp registry.\n     */\n    IDappRegistry public override dappRegistry;\n\n    /**\n        @notice It is the global instance of the PriceAggregator contract.\n     */\n    IPriceAggregator public override priceAggregator;\n\n    /**\n        @notice It is the global instance of the MarketFactory contract.\n     */\n    IMarketFactory public override marketFactory;\n\n    /**\n        @notice This mapping represents the list of wallet addresses that are allowed to interact with the protocol\n\n        - The key is belongs to the user's wallet address\n        - The value is a boolean flag indicating if the address has permissions\n     */\n    mapping(address => bool) public authorizedAddresses;\n\n    Roles.Role private _pausers;\n\n    /**\n        @notice Flag pausing the use of the Protocol\n     */\n    bool public paused;\n\n    /**\n        @notice Flag restricting the use of the Protocol to authorizedAddress\n     */\n    bool public platformRestricted;\n\n    /** Modifiers */\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() override {\n        require(!paused, \"PLATFORM_PAUSED\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused, \"PLATFORM_NOT_PAUSED\");\n        _;\n    }\n\n    modifier onlyPauser() override {\n        require(isPauser(msg.sender), \"NOT_PAUSER\");\n        _;\n    }\n\n    /* Constructor */\n\n    /** external override Functions */\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    function platformSettings(bytes32 settingName)\n        public\n        view\n        override\n        returns (PlatformSettingsLib.PlatformSetting memory)\n    {\n        return _platformSettings[settingName];\n    }\n\n    function isPauser(address account) public view override returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function removePauser(address account) public onlyPauser {\n        _removePauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n\n    /**\n        @notice It creates a new platform setting given a setting name, value, min and max values.\n        @param settingName setting name to create.\n        @param value the initial value for the given setting name.\n        @param minValue the min value for the setting.\n        @param maxValue the max value for the setting.\n     */\n    function createPlatformSetting(\n        bytes32 settingName,\n        uint256 value,\n        uint256 minValue,\n        uint256 maxValue\n    ) external override onlyPauser {\n        require(settingName != \"\", \"SETTING_NAME_MUST_BE_PROVIDED\");\n        _platformSettings[settingName].initialize(value, minValue, maxValue);\n\n        emit PlatformSettingCreated(\n            settingName,\n            msg.sender,\n            value,\n            minValue,\n            maxValue\n        );\n    }\n\n    /**\n        @notice It updates an existent platform setting given a setting name.\n        @notice It only allows to update the value (not the min or max values).\n        @notice In case you need to update the min or max values, you need to remove it, and create it again.\n        @param settingName setting name to update.\n        @param newValue the new value to set.\n     */\n    function updatePlatformSetting(bytes32 settingName, uint256 newValue)\n        external\n        override\n        onlyPauser\n    {\n        uint256 oldValue = _platformSettings[settingName].update(newValue);\n\n        emit PlatformSettingUpdated(\n            settingName,\n            msg.sender,\n            oldValue,\n            newValue\n        );\n    }\n\n    /**\n        @notice Removes a current platform setting given a setting name.\n        @param settingName to remove.\n     */\n    function removePlatformSetting(bytes32 settingName)\n        external\n        override\n        onlyPauser\n    {\n        uint256 oldValue = _platformSettings[settingName].value;\n        _platformSettings[settingName].remove();\n\n        emit PlatformSettingRemoved(settingName, oldValue, msg.sender);\n    }\n\n    /**\n        @notice It gets the current \"RequiredSubmissionsPercentage\" setting's value\n        @return value the current value.\n     */\n    function getRequiredSubmissionsPercentageValue()\n        external\n        view\n        override\n        returns (uint256 value)\n    {\n        value = _platformSettings[REQUIRED_SUBMISSIONS_PERCENTAGE_SETTING]\n            .value;\n    }\n\n    /**\n        @notice It gets the current \"MaximumTolerance\" setting's value\n        @return value the current value.\n     */\n    function getMaximumToleranceValue()\n        external\n        view\n        override\n        returns (uint256 value)\n    {\n        value = _platformSettings[MAXIMUM_TOLERANCE_SETTING].value;\n    }\n\n    /**\n        @notice It gets the current \"ResponseExpiryLength\" setting's value\n        @return value the current value.\n     */\n    function getResponseExpiryLengthValue()\n        external\n        view\n        override\n        returns (uint256 value)\n    {\n        value = _platformSettings[RESPONSE_EXPIRY_LENGTH_SETTING].value;\n    }\n\n    /**\n        @notice It gets the current \"SafetyInterval\" setting's value\n        @return value the current value.\n     */\n    function getSafetyIntervalValue()\n        external\n        view\n        override\n        returns (uint256 value)\n    {\n        value = _platformSettings[SAFETY_INTERVAL_SETTING].value;\n    }\n\n    /**\n        @notice It gets the current \"TermsExpiryTime\" setting's value\n        @return value the current value.\n     */\n    function getTermsExpiryTimeValue()\n        external\n        view\n        override\n        returns (uint256 value)\n    {\n        value = _platformSettings[TERMS_EXPIRY_TIME_SETTING].value;\n    }\n\n    /**\n        @notice It gets the current \"LiquidateEthPrice\" setting's value\n        @return value the current value.\n     */\n    function getLiquidateEthPriceValue()\n        external\n        view\n        override\n        returns (uint256 value)\n    {\n        value = _platformSettings[LIQUIDATE_ETH_PRICE_SETTING].value;\n    }\n\n    /**\n        @notice It gets the current \"MaximumLoanDuration\" setting's value\n        @return value the current value.\n     */\n    function getMaximumLoanDurationValue()\n        external\n        view\n        override\n        returns (uint256 value)\n    {\n        value = _platformSettings[MAXIMUM_LOAN_DURATION_SETTING].value;\n    }\n\n    /**\n        @notice It gets the current \"RequestLoanTermsRateLimit\" setting's value\n        @return value the current value.\n     */\n    function getRequestLoanTermsRateLimitValue()\n        external\n        view\n        override\n        returns (uint256 value)\n    {\n        value = _platformSettings[REQUEST_LOAN_TERMS_RATE_LIMIT_SETTING].value;\n    }\n\n    /**\n        @notice It gets the current \"CollateralBuffer\" setting's value\n        @return value the current value.\n     */\n    function getCollateralBufferValue()\n        external\n        view\n        override\n        returns (uint256 value)\n    {\n        value = _platformSettings[COLLATERAL_BUFFER_SETTING].value;\n    }\n\n    /**\n        @notice It gets the current \"OverCollateralizedBuffer\" setting's value\n        @return value the current value.\n     */\n    function getOverCollateralizedBufferValue()\n        external\n        view\n        override\n        returns (uint256 value)\n    {\n        value = _platformSettings[OVER_COLLATERALIZED_BUFFER_SETTING].value;\n    }\n\n    /**\n     * @notice It returns the the platform ETH address.\n     */\n    function ETH_ADDRESS() external view override returns (address) {\n        return cacheStorage.addresses[\"ETH_ADDRESS\"];\n    }\n\n    /**\n     * @notice It returns the address of the WETH token.\n     */\n    function WETH_ADDRESS() external view override returns (address) {\n        return cacheStorage.addresses[\"WETH_ADDRESS\"];\n    }\n\n    /**\n     * @notice It returns the address of the Compound CETH token.\n     */\n    function CETH_ADDRESS() external view override returns (address) {\n        return cacheStorage.addresses[\"CETH_ADDRESS\"];\n    }\n\n    /**\n     * @notice It returns the address of the UniswapV2Router.\n     */\n    function getUniswapV2RouterAddress()\n        external\n        view\n        override\n        returns (address)\n    {\n        return cacheStorage.addresses[\"UniswapV2Router\"];\n    }\n\n    /**\n     * @notice It returns the address of the InitializeableDynamicProxy contract.\n     */\n    function initDynamicProxyLogic() external view override returns (address) {\n        return cacheStorage.addresses[\"InitializeableDynamicProxy\"];\n    }\n\n    /**\n        @notice It tests whether a setting name is already configured.\n        @param settingName setting name to test.\n        @return true if the setting is already configured. Otherwise it returns false.\n     */\n    function hasPlatformSetting(bytes32 settingName)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _getPlatformSetting(settingName).exists;\n    }\n\n    function getPlatformSetting(bytes32 settingName)\n        external\n        view\n        returns (PlatformSettingsLib.PlatformSetting memory)\n    {\n        return _getPlatformSetting(settingName);\n    }\n\n    /**\n        @notice It pauses a specific lending pool.\n        @param lendingPoolAddress lending pool address to pause.\n     */\n    function pauseLendingPool(address lendingPoolAddress)\n        external\n        override\n        onlyPauser\n        whenNotPaused\n    {\n        lendingPoolAddress.requireNotEmpty(\"LENDING_POOL_IS_REQUIRED\");\n        require(\n            !lendingPoolPaused[lendingPoolAddress],\n            \"LENDING_POOL_ALREADY_PAUSED\"\n        );\n\n        lendingPoolPaused[lendingPoolAddress] = true;\n\n        emit LendingPoolPaused(msg.sender, lendingPoolAddress);\n    }\n\n    /**\n        @notice It unpauses a specific lending pool.\n        @param lendingPoolAddress lending pool address to unpause.\n     */\n    function unpauseLendingPool(address lendingPoolAddress)\n        external\n        override\n        onlyPauser\n        whenNotPaused\n    {\n        lendingPoolAddress.requireNotEmpty(\"LENDING_POOL_IS_REQUIRED\");\n        require(\n            lendingPoolPaused[lendingPoolAddress],\n            \"LENDING_POOL_IS_NOT_PAUSED\"\n        );\n\n        lendingPoolPaused[lendingPoolAddress] = false;\n\n        emit LendingPoolUnpaused(msg.sender, lendingPoolAddress);\n    }\n\n    /**\n        @notice It gets whether the platform is paused or not.\n        @return true if platform is paused. Otherwise it returns false.\n     */\n    function isPaused() external view override returns (bool) {\n        return paused;\n    }\n\n    /**\n        @notice Tests whether amount exceeds the current maximum loan amount for a specific asset settings.\n        @param assetAddress asset address to test the setting.\n        @param amount amount to test.\n        @return true if amount exceeds current max loan amout. Otherwise it returns false.\n     */\n    function exceedsMaxLoanAmount(address assetAddress, uint256 amount)\n        external\n        view\n        returns (bool)\n    {\n        return assetSettings.exceedsMaxLoanAmount(assetAddress, amount);\n    }\n\n    /**\n        @notice Gets the cToken address for a given asset address.\n        @param assetAddress token address.\n        @return the cToken address for a given asset address.\n     */\n    function getCTokenAddress(address assetAddress)\n        external\n        view\n        override\n        returns (address)\n    {\n        return assetSettings.getCTokenAddress(assetAddress);\n    }\n\n    /**\n        @notice Requires an account to have the pauser role.\n        @param account account to test.\n     */\n    function requirePauserRole(address account) public view override {\n        require(isPauser(account) || account == address(this), \"NOT_PAUSER\");\n    }\n\n    /**\n        @notice Restricts the use of the Teller protocol to authorized wallet addresses only\n        @param restriction Bool turning the resitriction on or off\n     */\n    function restrictPlatform(bool restriction) external override onlyPauser {\n        platformRestricted = restriction;\n        emit PlatformRestricted(restriction, msg.sender);\n    }\n\n    /**\n        @notice Returns whether the platform is restricted or not\n        @return bool True if the platform is restricted, false if not\n     */\n    function isPlatformRestricted() external view override returns (bool) {\n        return platformRestricted;\n    }\n\n    /**\n        @notice Adds a wallet address to the list of authorized wallets\n        @param addressToAdd The wallet address of the user being authorized\n     */\n    function addAuthorizedAddress(address addressToAdd) public override {\n        require(\n            isPauser(msg.sender) || msg.sender == address(dappRegistry),\n            \"CALLER_NOT_PAUSER\"\n        );\n        authorizedAddresses[addressToAdd] = true;\n        emit AuthorizationGranted(addressToAdd, msg.sender);\n    }\n\n    // The escrow must be added as an authorized address since it will be interacting with the protocol\n    // TODO: Remove after non-guarded launch\n    function addEscrowAuthorized(address escrowAddress) external override {\n        (bool success, bytes memory data) =\n            msg.sender.staticcall(abi.encodeWithSignature(\"lendingPool()\"));\n        require(success, \"FAILED_FETCHING_LP\");\n        address lpAddress = abi.decode(data, (address));\n        require(\n            marketFactory.marketRegistry().loanManagerRegistry(\n                lpAddress,\n                msg.sender\n            ),\n            \"CALLER_NOT_LOANS\"\n        );\n        authorizedAddresses[escrowAddress] = true;\n        emit AuthorizationGranted(escrowAddress, msg.sender);\n    }\n\n    /**\n        @notice Adds a list of wallet addresses to the list of authorized wallets\n        @param addressesToAdd The list of wallet addresses being authorized\n     */\n    function addAuthorizedAddressList(address[] calldata addressesToAdd)\n        external\n        override\n    {\n        for (uint256 i = 0; i < addressesToAdd.length; i++) {\n            addAuthorizedAddress(addressesToAdd[i]);\n        }\n    }\n\n    /**\n        @notice Removes a wallet address from the list of authorized wallets\n        @param addressToRemove The wallet address of the user being unauthorized\n     */\n    function removeAuthorizedAddress(address addressToRemove)\n        external\n        override\n        onlyPauser\n    {\n        authorizedAddresses[addressToRemove] = false;\n        emit AuthorizationRevoked(addressToRemove, msg.sender);\n    }\n\n    /**\n        @notice Tests whether an account has authorization\n        @param account The account address to check for\n        @return True if account has authorization, false if it does not\n     */\n    function hasAuthorization(address account)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return isPauser(account) || authorizedAddresses[account];\n    }\n\n    /**\n        @notice Requires an account to have platform authorization.\n        @dev Checks if an account address has authorization or proxy contract is registered.\n        @param account account to test.\n     */\n    function requireAuthorization(address account) public view override {\n        require(\n            !platformRestricted || hasAuthorization(account),\n            \"NOT_AUTHORIZED\"\n        );\n    }\n\n    /**\n        @notice It initializes this settings contract instance.\n        @param wethTokenAddress canonical WETH token address.\n        @param cethTokenAddress compound CETH token address.\n        @param initDynamicProxyAddress Address of a deployed InitializeableDynamicProxy contract.\n        @param uniswapV2RouterAddress Address of the UniswapV2Router instance to use for the platform.\n     */\n    function initialize(\n        address wethTokenAddress,\n        address cethTokenAddress,\n        address initDynamicProxyAddress,\n        address uniswapV2RouterAddress\n    ) external override {\n        require(wethTokenAddress.isContract(), \"WETH_ADDRESS_MUST_BE_CONTRACT\");\n\n        _addPauser(msg.sender);\n        _initialize(address(this));\n\n        cacheStorage.initialize();\n        cacheStorage.updateAddress(\"UniswapV2Router\", uniswapV2RouterAddress);\n        cacheStorage.updateAddress(\n            \"InitializeableDynamicProxy\",\n            initDynamicProxyAddress\n        );\n        cacheStorage.updateAddress(\n            \"ETH_ADDRESS\",\n            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n        );\n        cacheStorage.updateAddress(\"WETH_ADDRESS\", wethTokenAddress);\n        cacheStorage.updateAddress(\"CETH_ADDRESS\", cethTokenAddress);\n\n        assetSettings = AssetSettingsInterface(\n            _deployInitDynamicProxy(keccak256(\"AssetSettings\"))\n        );\n        priceAggregator = IPriceAggregator(\n            _deployInitDynamicProxy(keccak256(\"PriceAggregator\"))\n        );\n        dappRegistry = IDappRegistry(\n            _deployInitDynamicProxy(keccak256(\"DappRegistry\"))\n        );\n        marketFactory = IMarketFactory(\n            _deployInitDynamicProxy(keccak256(\"MarketFactory\"))\n        );\n    }\n\n    /** Internal functions */\n\n    /**\n        @notice Deploys a new DynamicProxy given a logic name.\n        @dev All proxies created through this function are create as non strict dynamic. See DynamicUpgradeable\n        @dev Each one deployed here should have an empty parameter initialize function.\n        @param logicName The name where the logic will be stored as.\n     */\n    function _deployInitDynamicProxy(bytes32 logicName)\n        internal\n        returns (address proxyAddress)\n    {\n        proxyAddress = _clone(\n            cacheStorage.addresses[\"InitializeableDynamicProxy\"]\n        );\n        IInitializeableDynamicProxy(proxyAddress).initialize(\n            address(logicRegistry),\n            logicName,\n            false\n        );\n\n        // Try to initialize the actual contract implementation.\n        (bool success, ) =\n            proxyAddress.call(abi.encodeWithSignature(\"initialize()\"));\n        if (!success) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n    }\n\n    /**\n        @notice It gets the platform setting for a given setting name.\n        @param settingName the setting name to look for.\n        @return the current platform setting for the given setting name.\n     */\n    function _getPlatformSetting(bytes32 settingName)\n        internal\n        view\n        returns (PlatformSettingsLib.PlatformSetting memory)\n    {\n        return _platformSettings[settingName];\n    }\n}\n"
    },
    "contracts/providers/openzeppelin/Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping(address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account)\n        internal\n        view\n        returns (bool)\n    {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "contracts/base/proxies/InitializeableDynamicProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"./BaseDynamicProxy.sol\";\n\n// Interfaces\nimport \"../../interfaces/IInitializeableDynamicProxy.sol\";\n\n/**\n    @notice It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.\n    @notice It extends BaseUpgradeable to get access to the settings.\n\n    @author develop@teller.finance\n */\ncontract InitializeableDynamicProxy is\n    IInitializeableDynamicProxy,\n    BaseDynamicProxy\n{\n    /**\n        @notice It initializes a new dynamic proxy given a logic registry contract and a logic name.\n        @param aLogicRegistryAddress the settings contract address.\n        @param aLogicName the settings contract address.\n        @param isStrictDynamic Boolean indicating if the proxy must check the registry for a new implementation.\n     */\n    function initialize(\n        address aLogicRegistryAddress,\n        bytes32 aLogicName,\n        bool isStrictDynamic\n    ) public override {\n        require(address(logicRegistry) == address(0), \"PROXY_ALREADY_INIT\");\n        logicRegistry = LogicVersionsRegistryInterface(aLogicRegistryAddress);\n        logicName = aLogicName;\n        strictDynamic = isStrictDynamic;\n        _updateImplementationStored();\n    }\n}\n"
    },
    "contracts/base/LogicVersionsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Commons and Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../util/AddressLib.sol\";\nimport \"../util/LogicVersionLib.sol\";\nimport \"../util/TellerCommon.sol\";\n\n// Interfaces\nimport \"../interfaces/LogicVersionsRegistryInterface.sol\";\nimport \"../interfaces/IBaseProxy.sol\";\nimport \"../interfaces/SettingsInterface.sol\";\n\n/**\n    @notice It manages all the logic contract versions, mapping each one to a logic name (or key).\n    @author develop@teller.finance\n */\ncontract LogicVersionsRegistry is LogicVersionsRegistryInterface {\n    using LogicVersionLib for LogicVersionLib.LogicVersion;\n    using Address for address;\n\n    /* State Variables */\n\n    /**\n     * @notice It is the only address that may make changes in the contract.\n     */\n    address public owner;\n\n    /**\n        @dev It represents a mapping to identify a logic name (key) and the current logic address and version.\n\n        i.e.:\n            bytes32(\"EtherCollateralLoans\") => { logic: \"0x123...789\", version: 1 }.\n            bytes32(\"LendingPool\") => { logic: \"0x456...987\", version: 3 }.\n     */\n    mapping(bytes32 => LogicVersionLib.LogicVersion) internal logicVersions;\n\n    /** Modifiers */\n\n    /**\n     * @notice It checks that the sender is the owner address.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"NOT_OWNER\");\n        _;\n    }\n\n    /** External Functions */\n    /**\n        @notice It creates multiple logic versions.\n        @param newLogicVersions lists of the new logic versions to create.\n     */\n    function createLogicVersions(\n        TellerCommon.CreateLogicVersionRequest[] calldata newLogicVersions\n    ) external override onlyOwner {\n        _createLogicVersions(newLogicVersions);\n    }\n\n    /**\n        @notice It upgrades multiple logic addresses.\n        @param newLogicVersions lists of the new logic versions to create.\n     */\n    function upgradeLogicVersions(\n        TellerCommon.UpgradeLogicVersionRequest[] calldata newLogicVersions\n    ) external override onlyOwner {\n        _upgradeLogicVersions(newLogicVersions);\n    }\n\n    /**\n        @notice It upgrades a logic version given a logic name.\n        @param logicName logic name to upgrade.\n        @param newLogic the new logic address to set.\n        @param proxy The (optional) DynamicUpgradeable proxy address to attempt to directly upgrade.\n     */\n    function upgradeLogicVersion(\n        bytes32 logicName,\n        address newLogic,\n        address proxy\n    ) external override onlyOwner {\n        _upgradeLogicVersion(logicName, newLogic, proxy);\n    }\n\n    /**\n        @notice It rollbacks a logic to a previous version.\n        @param logicName logic name to rollback.\n        @param previousVersion the previous version to be used.\n     */\n    function rollbackLogicVersion(bytes32 logicName, uint256 previousVersion)\n        external\n        override\n        onlyOwner\n    {\n        (uint256 currentVersion, address previousLogic, address newLogic) =\n            logicVersions[logicName].rollback(previousVersion);\n\n        emit LogicVersionRollbacked(\n            logicName,\n            previousLogic,\n            newLogic,\n            currentVersion,\n            previousVersion\n        );\n    }\n\n    /**\n        @notice Transfers ownership of the contract to a new account (`newOwner`).\n        @dev Can only be called by the current owner.\n        @param newOwner The address that should be the new owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n\n    /**\n        @notice It gets the current logic version for a given logic name.\n        @param logicName to get.\n        @return currentVersion the current logic version number.\n        @return latestVersion the latest version number (higher than current if rolled back).\n        @return logic the address of the current logic version\n     */\n    function getLogicVersion(bytes32 logicName)\n        external\n        view\n        override\n        returns (\n            uint256 currentVersion,\n            uint256 latestVersion,\n            address logic\n        )\n    {\n        LogicVersionLib.LogicVersion storage logicVersion =\n            logicVersions[logicName];\n\n        currentVersion = logicVersion.currentVersion;\n        latestVersion = logicVersion.latestVersion;\n        logic = logicVersion.versions[currentVersion];\n    }\n\n    /**\n        @notice It tests whether a logic name is already configured.\n        @param logicName logic name to test.\n        @return true if the logic version is already configured. Otherwise it returns false.\n     */\n    function hasLogicVersion(bytes32 logicName)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return logicVersions[logicName].exists;\n    }\n\n    /**\n        @notice It initializes this logic versions constants.\n        @param aOwner address of the owner of the registry.\n        @param initialLogicVersions lists of the new logic versions to create.\n     */\n    function initialize(\n        address aOwner,\n        TellerCommon.CreateLogicVersionRequest[] calldata initialLogicVersions\n    ) external override {\n        require(owner == address(0), \"ALREADY_INIT\");\n        owner = aOwner;\n        _createLogicVersions(initialLogicVersions);\n    }\n\n    /** Internal functions */\n\n    /**\n        @notice It creates a new logic version given a logic name and address.\n        @param logicName logic name to create.\n        @param logic the logic address value for the given logic name.\n     */\n    function _createLogicVersion(bytes32 logicName, address logic) internal {\n        require(logicName != \"\", \"LOGIC_NAME_MUST_BE_PROVIDED\");\n        logicVersions[logicName].initialize(logic);\n\n        emit LogicVersionCreated(logicName, logic, 0);\n    }\n\n    /**\n        @notice It creates multiple logic versions.\n        @param newLogicVersions lists of the logic versions to create.\n     */\n    function _createLogicVersions(\n        TellerCommon.CreateLogicVersionRequest[] memory newLogicVersions\n    ) internal {\n        for (uint256 i; i < newLogicVersions.length; i++) {\n            _createLogicVersion(\n                newLogicVersions[i].logicName,\n                newLogicVersions[i].logic\n            );\n        }\n    }\n\n    /**\n        @notice It upgrades a new logic version given a logic name and address.\n        @param logicName logic name to create.\n        @param newLogic the logic address value for the given logic name.\n        @param proxy The (optional) DynamicUpgradeable proxy address to attempt to directly upgrade.\n     */\n    function _upgradeLogicVersion(\n        bytes32 logicName,\n        address newLogic,\n        address proxy\n    ) internal {\n        // If proxy given, make sure its not strict dynamic and logic names match before directly upgrading.\n        if (proxy != address(0)) {\n            (bool success, bytes memory data) =\n                proxy.staticcall(abi.encodeWithSignature(\"strictDynamic()\"));\n            require(\n                success && !abi.decode(data, (bool)),\n                \"PROXY_STRICT_DYNAMIC\"\n            );\n\n            (success, data) = proxy.staticcall(\n                abi.encodeWithSignature(\"logicName()\")\n            );\n            require(\n                success && abi.decode(data, (bytes32)) == logicName,\n                \"MISMATCH_LOGIC_NAME\"\n            );\n\n            (success, ) = proxy.call(\n                abi.encodeWithSignature(\"upgradeProxyTo(address)\", newLogic)\n            );\n            require(success, \"FAILED_TO_DIRECTLY_UPGRADE\");\n        }\n\n        (address oldLogic, uint256 oldVersion, uint256 newVersion) =\n            logicVersions[logicName].upgrade(newLogic);\n\n        emit LogicVersionUpgraded(\n            logicName,\n            oldLogic,\n            newLogic,\n            oldVersion,\n            newVersion\n        );\n    }\n\n    /**\n        @notice It upgrades multiple logic versions.\n        @param newLogicVersions Lists of the logic versions to upgrade.\n     */\n    function _upgradeLogicVersions(\n        TellerCommon.UpgradeLogicVersionRequest[] memory newLogicVersions\n    ) internal {\n        for (uint256 i; i < newLogicVersions.length; i++) {\n            _upgradeLogicVersion(\n                newLogicVersions[i].logicName,\n                newLogicVersions[i].logic,\n                newLogicVersions[i].proxy\n            );\n        }\n    }\n}\n"
    },
    "contracts/base/DappRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"./Base.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n// Interfaces\nimport \"../interfaces/loans/ILoanManager.sol\";\nimport \"../interfaces/IDappRegistry.sol\";\n\n// Commons\nimport \"../util/AddressLib.sol\";\nimport \"../util/AddressArrayLib.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract is used as a factory for the escrow contract that will be owned by the borrowers.\n\n    @author develop@teller.finance\n */\ncontract DappRegistry is IDappRegistry, Base {\n    using AddressArrayLib for AddressArrayLib.AddressArray;\n    using AddressLib for address;\n    using Address for address;\n\n    /* State Variables */\n\n    /**\n        @dev It holds the Dapp's configuration.\n     */\n    mapping(address => TellerCommon.Dapp) private _dapps;\n\n    /**\n     *  @dev It contains all the dapps added in this factory.\n     */\n    AddressArrayLib.AddressArray internal dappsList;\n\n    /* Modifiers */\n\n    /* External Functions */\n\n    function dapps(address dapp)\n        public\n        view\n        override\n        returns (TellerCommon.Dapp memory)\n    {\n        return _dapps[dapp];\n    }\n\n    /**\n        @notice It adds a new dapp to the factory.\n        @param dapp address to add in this factory.\n        @param unsecured boolean to describe in the dapp is allowed to be used with unsecured loans.\n     */\n    function addDapp(address dapp, bool unsecured)\n        external\n        override\n        onlyPauser\n    {\n        require(dapp.isContract(), \"DAPP_ISNT_A_CONTRACT\");\n        require(!_isDapp(dapp), \"DAPP_ALREADY_EXIST\");\n\n        _dapps[dapp] = TellerCommon.Dapp({\n            exists: true,\n            unsecured: unsecured\n        });\n        dappsList.add(dapp);\n\n        emit NewDappAdded(msg.sender, dapp, unsecured);\n    }\n\n    /**\n        @notice It updates a dapp configuration.\n        @param dapp address to add in this factory.\n        @param unsecured boolean that describes if the dapp can be used by with an unsecured loan.\n     */\n    function updateDapp(address dapp, bool unsecured)\n        external\n        override\n        onlyPauser\n    {\n        require(_isDapp(dapp), \"DAPP_NOT_EXIST\");\n\n        _dapps[dapp].unsecured = unsecured;\n\n        emit DappUpdated(msg.sender, dapp, unsecured);\n    }\n\n    /**\n        @notice It removes a current dapp from the factory.\n        @param dapp address to remove.\n     */\n    function removeDapp(address dapp) external override onlyPauser {\n        require(dapp.isContract(), \"DAPP_ISNT_A_CONTRACT\");\n        require(_isDapp(dapp), \"DAPP_NOT_EXIST\");\n\n        _dapps[dapp].exists = false;\n        dappsList.remove(dapp);\n\n        emit DappRemoved(msg.sender, dapp);\n    }\n\n    /**\n        @notice Gets all the dapps in the factory.\n        @return an array of dapps (addresses).\n     */\n    function getDapps() external view override returns (address[] memory) {\n        return dappsList.array;\n    }\n\n    /**\n        @notice It initializes this escrow contract factory instance.\n     */\n    function initialize() external override {\n        _initialize(msg.sender);\n    }\n\n    /** Internal Functions */\n\n    /**\n        @notice It tests whether an address is a dapp or not.\n        @param dapp address to test.\n        @return true if the address is a dapp. Otherwise it returns false.\n     */\n    function _isDapp(address dapp) internal view returns (bool) {\n        return _dapps[dapp].exists;\n    }\n}\n"
    },
    "contracts/base/PriceAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./Base.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../util/AddressArrayLib.sol\";\n\n// Interfaces\nimport \"../interfaces/IPriceAggregator.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract is used to fetch and calculate prices and values from one token to another through Chainlink Aggregators.\n    @dev It tries to find an aggregator using the token addresses supplied. If unable, it uses ETH as a pass through asset to construct a path conversion.\n\n    @author develop@teller.finance\n */\ncontract PriceAggregator is IPriceAggregator, Base {\n    using Address for address;\n    using AddressLib for address;\n    using AddressArrayLib for AddressArrayLib.AddressArray;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    /* State Variables */\n\n    uint256 internal constant TEN = 10;\n\n    /*\n        @notice It is a mapping for Chainlink Aggregator contracts by baseTokenAddress => quoteTokenAddress => chainlinkAggregatorAddress\n     */\n    mapping(address => mapping(address => address)) internal aggregators;\n\n    mapping(address => AddressArrayLib.AddressArray) internal supportedTokens;\n\n    /* External Functions */\n\n    function getTokensSupportedBy(address tokenAddress)\n        external\n        view\n        returns (address[] memory)\n    {\n        return supportedTokens[tokenAddress].array;\n    }\n\n    /**\n        @notice It grabs the Chainlink Aggregator contract address for the token pair if it is supported.\n        @param src Source token address.\n        @param dst Destination token address.\n        @return AggregatorV2V3Interface The Chainlink Aggregator address.\n        @return bool whether or not the values from the Aggregator should be considered inverted.\n     */\n    function aggregatorFor(address src, address dst)\n        external\n        view\n        override\n        returns (AggregatorV2V3Interface, bool)\n    {\n        src = _normalizeTokenAddress(src);\n        dst = _normalizeTokenAddress(dst);\n\n        return _aggregatorFor(src, dst);\n    }\n\n    /**\n        @notice It checks if the token is supported.\n        @param tokenAddress Token address to check support for.\n        @return bool whether or not the token is supported.\n     */\n    function isTokenSupported(address tokenAddress)\n        external\n        view\n        override\n        returns (bool)\n    {\n        tokenAddress = _normalizeTokenAddress(tokenAddress);\n\n        return supportedTokens[tokenAddress].length() > 0;\n    }\n\n    /**\n        @notice It calculates the value of a token amount into another.\n        @param src Source token address.\n        @param dst Destination token address.\n        @param srcAmount Amount of the source token to convert into the destination token.\n        @return uint256 Value of the source token amount in destination tokens.\n     */\n    function valueFor(\n        address src,\n        address dst,\n        uint256 srcAmount\n    ) external view override returns (uint256) {\n        src = _normalizeTokenAddress(src);\n        dst = _normalizeTokenAddress(dst);\n\n        return _valueFor(src, dst, srcAmount);\n    }\n\n    /**\n        @notice It returns the price of the token pair as given from the Chainlink Aggregator.\n        @dev It tries to use ETH as a pass through asset if the direct pair is not supported.\n        @param src Source token address.\n        @param dst Destination token address.\n        @return int256 The latest answer as given from Chainlink.\n     */\n    function latestAnswerFor(address src, address dst)\n        external\n        view\n        override\n        returns (int256)\n    {\n        src = _normalizeTokenAddress(src);\n        dst = _normalizeTokenAddress(dst);\n\n        return _priceFor(src, dst);\n    }\n\n    /**\n        @notice It allows for additional Chainlink Aggregators to be supported.\n        @param src Source token address.\n        @param dst Destination token address.\n        @param aggregator Price aggregator address.\n     */\n    function add(\n        address src,\n        address dst,\n        address aggregator\n    ) external override onlyPauser {\n        src = _normalizeTokenAddress(src);\n        dst = _normalizeTokenAddress(dst);\n\n        (AggregatorV2V3Interface agg, ) = _aggregatorFor(src, dst);\n        require(address(agg).isEmpty(), \"CHAINLINK_PAIR_ALREADY_EXISTS\");\n\n        require(\n            src.isContract() || src == settings.ETH_ADDRESS(),\n            \"TOKEN_A_NOT_CONTRACT\"\n        );\n        require(\n            dst.isContract() || dst == settings.ETH_ADDRESS(),\n            \"TOKEN_B_NOT_CONTRACT\"\n        );\n        require(aggregator.isContract(), \"AGGREGATOR_NOT_CONTRACT\");\n\n        aggregators[src][dst] = aggregator;\n        supportedTokens[src].add(dst);\n        supportedTokens[dst].add(src);\n    }\n\n    /**\n        @notice It removes support for a Chainlink Aggregator pair.\n        @param src Source token address.\n        @param dst Destination token address.\n     */\n    function remove(address src, address dst) external override onlyPauser {\n        src = _normalizeTokenAddress(src);\n        dst = _normalizeTokenAddress(dst);\n\n        (AggregatorV2V3Interface agg, ) = _aggregatorFor(src, dst);\n        if (address(agg).isEmpty()) {\n            return;\n        }\n\n        aggregators[src][dst] = address(0);\n        supportedTokens[src].remove(dst);\n        supportedTokens[dst].remove(src);\n    }\n\n    /**\n        @notice It removes support for a Chainlink Aggregator.\n        @param tokenAddress Token to remove all markets for.\n     */\n    function remove(address tokenAddress) external override onlyPauser {\n        tokenAddress = _normalizeTokenAddress(tokenAddress);\n\n        address[] storage arr = supportedTokens[tokenAddress].array;\n        for (uint256 i; i < arr.length; i++) {\n            (AggregatorV2V3Interface agg, bool inverse) =\n                _aggregatorFor(tokenAddress, arr[i]);\n            if (inverse) {\n                aggregators[arr[i]][tokenAddress] = address(0);\n            } else {\n                aggregators[tokenAddress][arr[i]] = address(0);\n            }\n\n            arr.pop();\n        }\n    }\n\n    /**\n        @notice It initializes this PriceAggregator instance.\n     */\n    function initialize() external override {\n        _initialize(msg.sender);\n    }\n\n    /* Internal Functions */\n\n    /**\n        @notice It normalizes the token address to ETH if WETH.\n        @param tokenAddress The address of the token to normalize.\n    */\n    function _normalizeTokenAddress(address tokenAddress)\n        internal\n        view\n        returns (address)\n    {\n        return\n            tokenAddress == settings.WETH_ADDRESS()\n                ? settings.ETH_ADDRESS()\n                : tokenAddress;\n    }\n\n    /**\n        @notice It gets the number of decimals for a given token.\n        @param addr Token address to get decimals for.\n        @return uint8 Number of decimals the given token.\n     */\n    function _decimalsFor(address addr) internal view returns (uint8) {\n        return addr == settings.ETH_ADDRESS() ? 18 : ERC20(addr).decimals();\n    }\n\n    /**\n        @notice It grabs the Chainlink Aggregator contract address for the token pair if it is supported.\n        @param src Source token address.\n        @param dst Destination token address.\n        @return aggregator The Chainlink Aggregator address.\n        @return inverse whether or not the values from the Aggregator should be considered inverted.\n     */\n    function _aggregatorFor(address src, address dst)\n        internal\n        view\n        returns (AggregatorV2V3Interface aggregator, bool inverse)\n    {\n        inverse = aggregators[src][dst] == address(0);\n        aggregator = AggregatorV2V3Interface(\n            inverse ? aggregators[dst][src] : aggregators[src][dst]\n        );\n    }\n\n    /**\n        @notice It calculates the value of a token amount into another.\n        @param src Source token address.\n        @param dst Destination token address.\n        @param srcAmount Amount of the source token to convert into the destination token.\n        @return uint256 Value of the source token amount in destination tokens.\n     */\n    function _valueFor(\n        address src,\n        address dst,\n        uint256 srcAmount\n    ) internal view returns (uint256) {\n        return\n            (srcAmount.mul(uint256(_priceFor(src, dst)))).div(\n                uint256(TEN**_decimalsFor(src))\n            );\n    }\n\n    /**\n        @notice It returns the price of the token pair as given from the Chainlink Aggregator.\n        @dev It tries to use ETH as a pass through asset if the direct pair is not supported.\n        @param src Source token address.\n        @param dst Destination token address.\n        @return int256 The latest answer as given from Chainlink.\n     */\n    function _priceFor(address src, address dst)\n        internal\n        view\n        returns (int256)\n    {\n        (AggregatorV2V3Interface agg, bool inverse) = _aggregatorFor(src, dst);\n        uint256 dstDecimals = _decimalsFor(dst);\n        int256 dstFactor = int256(TEN**dstDecimals);\n        if (address(agg) != address(0)) {\n            int256 price = agg.latestAnswer();\n            uint256 resDecimals = agg.decimals();\n            if (inverse) {\n                price = int256(TEN**(resDecimals.add(resDecimals))).div(price);\n            }\n            if (dstDecimals > resDecimals) {\n                price = price.mul(int256(TEN**(dstDecimals.sub(resDecimals))));\n            } else {\n                price = price.div(int256(TEN**(resDecimals.sub(dstDecimals))));\n            }\n            int256 srcFactor = int256(TEN**_decimalsFor(src));\n            return price;\n        } else {\n            for (uint256 i; i < supportedTokens[src].array.length; i++) {\n                address routeToken = supportedTokens[src].array[i];\n                (bool found, ) = supportedTokens[routeToken].getIndex(dst);\n                if (found) {\n                    int256 price1 = _priceFor(src, routeToken);\n                    int256 price2 = _priceFor(dst, routeToken);\n\n                    return (price1.mul(dstFactor)).div(price2);\n                }\n            }\n            revert(\"CANNOT_CALCULATE_VALUE\");\n        }\n    }\n}\n"
    },
    "contracts/base/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\n/**  contract that this contract inherits from                                                      **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract stores the logic to clone an already deployed contract with minimal amount of code.\n    @notice By cloning a contract, we are able to create a new contract instance without having to spend all the deployment cost of the same code.\n\n    @author develop@teller.finance.\n */\ncontract Factory {\n    function _clone(address target) internal returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n\n        assembly {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            result := create(0, clone, 0x37)\n        }\n    }\n}\n"
    },
    "contracts/base/proxies/BaseDynamicProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"./BaseProxy.sol\";\nimport \"../upgradeable/DynamicUpgradeable.sol\";\n\n/**\n    @notice It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.\n    @notice It extends BaseUpgradeable to get access to the settings.\n\n    @author develop@teller.finance\n */\nabstract contract BaseDynamicProxy is BaseProxy, DynamicUpgradeable {\n    function _implementation()\n        internal\n        view\n        virtual\n        override(DynamicUpgradeable, Proxy)\n        returns (address)\n    {\n        return DynamicUpgradeable._implementation();\n    }\n\n    /**\n     * @notice It is called by the OZ proxy contract before calling the internal _implementation() function.\n     */\n    function _beforeFallback() internal override {\n        if (strictDynamic && _implementationBlockUpdated + 50 <= block.number) {\n            address(this).delegatecall(\n                abi.encodeWithSignature(\"_updateImplementationStored()\")\n            );\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IInitializeableDynamicProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IInitializeableDynamicProxy {\n    /**\n        @notice It initializes a new dynamic proxy given a logic registry contract and a logic name.\n        @param aLogicRegistryAddress the settings contract address.\n        @param aLogicName the settings contract address.\n        @param isStrictDynamic Boolean indicating if the proxy must check the registry for a new implementation.\n     */\n    function initialize(\n        address aLogicRegistryAddress,\n        bytes32 aLogicName,\n        bool isStrictDynamic\n    ) external;\n}\n"
    },
    "contracts/base/proxies/BaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Interfaces\nimport \"../../interfaces/IBaseProxy.sol\";\n\n// Contracts\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\n\n/**\n    @notice It is the base Proxy contract for all other Proxy contracts.\n    @dev It makes the current logic implementation address publicly available.\n\n    @author develop@teller.finance\n */\nabstract contract BaseProxy is IBaseProxy, Proxy {\n    /**\n        @notice Returns the current implementation.\n        @return Address of the current implementation\n     */\n    function implementation() external view override returns (address) {\n        return _implementation();\n    }\n}\n"
    },
    "contracts/interfaces/IBaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBaseProxy {\n    /**\n        @notice Returns the current implementation.\n        @return Address of the current implementation\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "contracts/base/MarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n// Interfaces\nimport \"../interfaces/loans/ILoanManager.sol\";\nimport \"../interfaces/loans/ILoanStorage.sol\";\nimport \"../interfaces/loans/ILoanTermsConsensus.sol\";\nimport \"../interfaces/LendingPoolInterface.sol\";\nimport \"../interfaces/SettingsInterface.sol\";\nimport \"../interfaces/IMarketFactory.sol\";\nimport \"../interfaces/IMarketRegistry.sol\";\nimport \"../interfaces/ITToken.sol\";\n\n// Contracts\nimport \"./Base.sol\";\nimport \"./proxies/InitializeableDynamicProxy.sol\";\nimport \"./MarketRegistry.sol\";\nimport \"./Factory.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract offers functions to manage markets.\n\n    @author develop@teller.finance\n */\ncontract MarketFactory is IMarketFactory, Base, Factory {\n    using Address for address;\n\n    /* State Variables */\n\n    IMarketRegistry public override marketRegistry;\n\n    /**\n     * @notice It holds the address of a deployed InitializeableDynamicProxy contract.\n     * @dev It is used to deploy a new proxy contract with minimal gas cost using the logic in the Factory contract.\n     */\n    address public initDynamicProxyLogic;\n\n    /** External Functions */\n\n    /**\n        @notice It creates a new market for a given lending and collateral tokens.\n        @dev It uses the Settings.ETH_ADDRESS to represent the ETHER.\n        @param lendingToken the token address used to create the lending pool and TToken.\n        @param collateralToken the collateral token address.\n     */\n    function createMarket(address lendingToken, address collateralToken)\n        external\n        override\n        whenNotPaused\n        onlyPauser\n    {\n        require(\n            !marketRegistry.marketExists(lendingToken, collateralToken),\n            \"MARKET_ALREADY_EXISTS\"\n        );\n        require(lendingToken.isContract(), \"BORROWED_TOKEN_MUST_BE_CONTRACT\");\n        require(\n            collateralToken == settings.ETH_ADDRESS() ||\n                collateralToken.isContract(),\n            \"COLL_TOKEN_MUST_BE_CONTRACT\"\n        );\n\n        address loanManagerAddress =\n            _createDynamicProxy(keccak256(\"LoanManager\"), true);\n\n        LendingPoolInterface lendingPool =\n            LendingPoolInterface(marketRegistry.lendingPools(lendingToken));\n        if (address(lendingPool) == address(0)) {\n            lendingPool = _createLendingPool(lendingToken);\n        }\n\n        // Initializing Loans\n        ILoanManager(loanManagerAddress).initialize(\n            address(lendingPool),\n            address(settings),\n            collateralToken,\n            initDynamicProxyLogic\n        );\n\n        marketRegistry.registerMarket(address(lendingPool), loanManagerAddress);\n\n        emit NewMarketCreated(\n            msg.sender,\n            lendingToken,\n            collateralToken,\n            loanManagerAddress,\n            address(lendingPool)\n        );\n    }\n\n    /**\n        @notice It initializes this market factory instance.\n     */\n    function initialize() external override {\n        _initialize(msg.sender);\n\n        initDynamicProxyLogic = settings.initDynamicProxyLogic();\n\n        marketRegistry = IMarketRegistry(\n            _createDynamicProxy(keccak256(\"MarketRegistry\"), false)\n        );\n        marketRegistry.initialize();\n    }\n\n    /** Internal Functions */\n\n    /**\n        @notice It creates a InitializeableDynamicProxy instance for a given logic name.\n        @dev It is used to create all the market contracts as strict dynamic proxies.\n     */\n    function _createDynamicProxy(bytes32 logicName, bool strict)\n        internal\n        returns (address proxyAddress)\n    {\n        proxyAddress = _clone(initDynamicProxyLogic);\n        IInitializeableDynamicProxy(proxyAddress).initialize(\n            address(logicRegistry),\n            logicName,\n            strict\n        );\n    }\n\n    /**\n        @notice Creates a proxy contract for LendingPool and its TToken.\n        @param lendingToken the token address used to create the lending pool and TToken.\n        @return lendingPool a new LendingPool instance.\n     */\n    function _createLendingPool(address lendingToken)\n        internal\n        returns (LendingPoolInterface lendingPool)\n    {\n        lendingPool = LendingPoolInterface(\n            _createDynamicProxy(keccak256(\"LendingPool\"), true)\n        );\n\n        ITToken tToken =\n            ITToken(_createDynamicProxy(keccak256(\"TToken\"), true));\n\n        lendingPool.initialize(\n            marketRegistry,\n            lendingToken,\n            address(tToken),\n            address(settings)\n        );\n        tToken.initialize(address(lendingPool));\n    }\n}\n"
    },
    "contracts/base/MarketRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"./Base.sol\";\n\n// Utils\nimport \"../util/AddressArrayLib.sol\";\n\n// Interfaces\nimport \"../interfaces/IMarketRegistry.sol\";\nimport \"../interfaces/LendingPoolInterface.sol\";\nimport \"../interfaces/loans/ILoans.sol\";\n\n/**\n    @notice It manages all the registered TToken contract address, mapping each one to a boolean.\n\n    @author develop@teller.finance\n */\ncontract MarketRegistry is IMarketRegistry, Base {\n    using AddressArrayLib for AddressArrayLib.AddressArray;\n\n    /* State Variables */\n\n    address public owner;\n\n    /**\n        @dev It maps a lending token to an array of collateral tokens that represent a market.\n     */\n    mapping(address => AddressArrayLib.AddressArray) internal markets;\n\n    /**\n        @notice It maps a lending token to the associated LendingPool contract.\n     */\n    mapping(address => address) public override lendingPools;\n\n    /**\n        @notice It maps a lending token and collateral token to the associated LoanManager contract.\n     */\n    mapping(address => mapping(address => address))\n        public\n        override loanManagers;\n\n    /**\n        @notice It represents a mapping to identify a LendingPool's LoanManager contract address.\n     */\n    mapping(address => mapping(address => bool))\n        public\n        override loanManagerRegistry;\n\n    /* Modifiers */\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    // external override Functions\n\n    /**\n        @notice It registers a new market with a LendingPool and Loans contract pair.\n        @param lendingPoolAddress a lending pool contract used to borrow assets.\n        @param loanManagerAddress a loan manager contract that stores all the relevant loans info and functionality.\n     */\n    function registerMarket(\n        address lendingPoolAddress,\n        address loanManagerAddress\n    ) external override onlyOwner {\n        require(\n            !loanManagerRegistry[lendingPoolAddress][loanManagerAddress],\n            \"MARKET_ALREADY_REGISTERED\"\n        );\n\n        address lendingToken =\n            address(LendingPoolInterface(lendingPoolAddress).lendingToken());\n        address collateralToken = ILoans(loanManagerAddress).collateralToken();\n        markets[lendingToken].add(collateralToken);\n        lendingPools[lendingToken] = lendingPoolAddress;\n        loanManagers[lendingToken][collateralToken] = loanManagerAddress;\n        loanManagerRegistry[lendingPoolAddress][loanManagerAddress] = true;\n    }\n\n    /**\n        @notice It fetches an array of collateral tokens that a given lending token supports.\n        @param lendingTokenAddress a token that the protocol lends.\n        @return an array of collateral tokens supported by the lending token market.\n     */\n    function getMarkets(address lendingTokenAddress)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return markets[lendingTokenAddress].array;\n    }\n\n    /**\n        @notice It checks if a market already exists.\n        @param lendingTokenAddress The lending token address.\n        @param collateralTokenAddress The collateral token address.\n     */\n    function marketExists(\n        address lendingTokenAddress,\n        address collateralTokenAddress\n    ) external view override returns (bool exists) {\n        (exists, ) = markets[lendingTokenAddress].getIndex(\n            collateralTokenAddress\n        );\n    }\n\n    /**\n     * @notice It initializes the MarketRegistry contract by setting the owner of the caller.\n     * @dev This contract is constructed and initialized by the MarketFactory.\n     */\n    function initialize() external override {\n        require(owner == address(0), \"ALREADY_INIT\");\n        owner = msg.sender;\n    }\n}\n"
    },
    "contracts/interfaces/loans/ILoans.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ILoanManager.sol\";\nimport \"./ILoanData.sol\";\nimport \"./ILoanStorage.sol\";\nimport \"./ILoanTermsConsensus.sol\";\n\nabstract contract ILoans is\n    ILoanManager,\n    ILoanData,\n    ILoanTermsConsensus,\n    ILoanStorage,\n    ALoanStorage\n{}\n"
    },
    "contracts/base/nft/NFTDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// Contracts\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"../Factory.sol\";\nimport \"../../interfaces/nft/ITellerNFT.sol\";\n\n// Interfaces\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                        THIS CONTRACT IS AN UPGRADEABLE STORAGE CONTRACT!                        **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions            **/\n/**  of this contract as this will cause a ripple affect to the storage slots of all child          **/\n/**  contracts that inherit from this contract to be overwritten on the deployed proxy contract!!   **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice\n *\n * @author develop@teller.finance\n */\ncontract NFTDistributor {\n    ITellerNFT public nft;\n\n    bytes32[] public tierMerkleRoots;\n\n    mapping(uint256 => mapping(uint256 => uint256)) public claimedBitMap;\n\n    event Claimed(uint256 index, address account, uint256 amount);\n\n    event TierAdded(uint256 index);\n\n    function getTierMerkleRoots() external view returns (bytes32[] memory) {\n        return tierMerkleRoots;\n    }\n\n    function claim(\n        uint256 tierIndex,\n        uint256 index,\n        address account,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(!isClaimed(tierIndex, index), \"Teller: NFT already claimed.\");\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(\n            MerkleProof.verify(merkleProof, tierMerkleRoots[tierIndex], node),\n            \"Teller: Invalid proof.\"\n        );\n\n        // Mark it claimed and send the token.\n        _setClaimed(tierIndex, index);\n        for (uint256 i; i < amount; i++) {\n            nft.mint(tierIndex, account);\n        }\n\n        emit Claimed(index, account, amount);\n    }\n\n    function _setClaimed(uint256 tierIndex, uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[tierIndex][claimedWordIndex] =\n            claimedBitMap[tierIndex][claimedWordIndex] |\n            (1 << claimedBitIndex);\n    }\n\n    function isClaimed(uint256 tierIndex, uint256 index)\n        public\n        view\n        returns (bool)\n    {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[tierIndex][claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    function addTier(bytes32 merkleRoot) external {\n        tierMerkleRoots.push(merkleRoot);\n\n        emit TierAdded(tierMerkleRoots.length - 1);\n    }\n\n    function initialize(address nftAddress) external {\n        require(address(nft) == address(0), \"Teller: Already initialized\");\n        nft = ITellerNFT(nftAddress);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "contracts/interfaces/nft/ITellerNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\ninterface ITellerNFT {\n    struct Tier {\n        uint256 baseLoanSize;\n        string[] hashes;\n        address contributionAsset;\n        uint256 contributionSize;\n        uint8 contributionMultiplier;\n    }\n\n    function mint(uint256 tierIndex, address owner) external virtual;\n\n    function addTier(Tier memory newTier) external virtual;\n}\n"
    },
    "contracts/base/nft/TellerNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// Contracts\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"../upgradeable/DynamicUpgradeable.sol\";\nimport \"./NFTStorage.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n// Interfaces\nimport \"../../interfaces/nft/ITellerNFT.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract is used by borrowers to call Dapp functions (using delegate calls).\n * @notice This contract should only be constructed using it's upgradeable Proxy contract.\n * @notice In order to call a Dapp function, the Dapp must be added in the DappRegistry instance.\n *\n * @author develop@teller.finance\n */\ncontract TellerNFT is\n    ITellerNFT,\n    ERC721Upgradeable,\n    AccessControlUpgradeable,\n    NFTStorage\n{\n    using Counters for Counters.Counter;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeMath for uint256;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    // It holds the total number of tiers.\n    Counters.Counter internal tierCounter;\n\n    // It holds the total number of tokens minted for a tier.\n    mapping(uint256 => Counters.Counter) internal tierTokenCounter;\n\n    // It holds the information about a tier.\n    mapping(uint256 => Tier) public tiers;\n\n    // It holds which tier a token ID is in.\n    mapping(uint256 => uint256) public tokenTierMap;\n\n    // It holds a set of token IDs for an owner address.\n    mapping(address => EnumerableSet.UintSet) internal ownerTokenIDs;\n\n    modifier onlyMinter() {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Teller: not minter\");\n        _;\n    }\n\n    /**\n     * @notice It returns an array of token IDs owned by an address.\n     * @dev It uses a EnumerableSet to store values and loops over each element to add to the array.\n     * @dev Can be costly if calling within a contract for address with many tokens.\n     */\n    function getTierHashes(uint256 tierIndex)\n        external\n        view\n        returns (string[] memory)\n    {\n        return tiers[tierIndex].hashes;\n    }\n\n    /**\n     * @notice It returns an array of token IDs owned by an address.\n     * @dev It uses a EnumerableSet to store values and loops over each element to add to the array.\n     * @dev Can be costly if calling within a contract for address with many tokens.\n     */\n    function ownedTokens(address owner)\n        external\n        view\n        returns (uint256[] memory owned)\n    {\n        EnumerableSet.UintSet storage set = ownerTokenIDs[owner];\n        owned = new uint256[](set.length());\n        for (uint256 i; i < owned.length; i++) {\n            owned[i] = set.at(i);\n        }\n    }\n\n    function mint(uint256 tierIndex, address owner)\n        external\n        override\n        onlyMinter\n    {\n        // Get the new token ID\n        Counters.Counter storage counter = tierTokenCounter[tierIndex];\n        uint256 tokenId = counter.current();\n        counter.increment();\n\n        // Mint and set the token to the tier index\n        _safeMint(owner, tokenId);\n        tokenTierMap[tokenId] = tierIndex;\n\n        // Set\n        _setOwner(owner, tokenId);\n    }\n\n    function addTier(Tier memory newTier) external override onlyMinter {\n        Tier storage tier = tiers[tierCounter.current()];\n        require(\n            tier.contributionAsset == address(0),\n            \"Teller: tier already exists\"\n        );\n\n        tier.baseLoanSize = newTier.baseLoanSize;\n        tier.hashes = newTier.hashes;\n        tier.contributionAsset = newTier.contributionAsset;\n        tier.contributionSize = newTier.contributionSize;\n        tier.contributionMultiplier = newTier.contributionMultiplier;\n\n        tierCounter.increment();\n    }\n\n    function removeMinter(address minter) external onlyMinter {\n        revokeRole(MINTER_ROLE, minter);\n    }\n\n    function addMinter(address minter) public onlyMinter {\n        _setupRole(MINTER_ROLE, minter);\n    }\n\n    function initialize(address[] calldata minters) external {\n        __ERC721_init(\"Teller NFT\", \"TNFT\");\n\n        for (uint256 i; i < minters.length; i++) {\n            _setupRole(MINTER_ROLE, minters[i]);\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        override(AccessControlUpgradeable, ERC721Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(ITellerNFT).interfaceId;\n    }\n\n    /**\n     * @notice The token URI is based on the token ID.\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length > 0\n                ? string(abi.encodePacked(baseURI, _tokenURIHash(tokenId)))\n                : \"\";\n    }\n\n    /**\n     * @notice It returns the hash to use for the token URI.\n     */\n    function _tokenURIHash(uint256 tokenId)\n        internal\n        view\n        returns (string memory)\n    {\n        string[] storage tierImageHashes = tiers[tokenTierMap[tokenId]].hashes;\n        return tierImageHashes[tokenId.mod(tierImageHashes.length)];\n    }\n\n    /**\n     * @notice The base URI path where the token media is hosted.\n     * @dev Base URI for computing {tokenURI}.\n     */\n    function _baseURI() internal view override returns (string memory) {\n        return \"https://gateway.pinata.cloud/ipfs/\";\n    }\n\n    /**\n     * @notice Moves token to new owner set and then transfers.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        _setOwner(to, tokenId);\n        super._transfer(from, to, tokenId);\n    }\n\n    /**\n     * @notice It removes the token from the current owner set and adds to new owner.\n     */\n    function _setOwner(address newOwner, uint256 tokenId) internal {\n        address currentOwner = ownerOf(tokenId);\n        if (currentOwner != address(0)) {\n            ownerTokenIDs[currentOwner].remove(tokenId);\n        }\n        ownerTokenIDs[newOwner].add(tokenId);\n    }\n\n    function _msgData()\n        internal\n        pure\n        override(ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"./extensions/IERC721EnumerableUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping (uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping (address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Upgradeable).interfaceId\n            || interfaceId == type(IERC721MetadataUpgradeable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721Upgradeable.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721Upgradeable.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override {\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override {\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/base/nft/NFTStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// Contracts\n\n// Interfaces\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                        THIS CONTRACT IS AN UPGRADEABLE STORAGE CONTRACT!                        **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions            **/\n/**  of this contract as this will cause a ripple affect to the storage slots of all child          **/\n/**  contracts that inherit from this contract to be overwritten on the deployed proxy contract!!   **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice\n *\n * @author develop@teller.finance\n */\ncontract NFTStorage {\n\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/providers/uniswap/Uniswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// External Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Interfaces\nimport \"./IUniswapV2Router02.sol\";\nimport \"../../interfaces/IPriceAggregator.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\n/**  contract that this contract inherits from                                                      **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract is used to swap tokens on Uniswap.\n *\n * @author develop@teller.finance\n */\ncontract Uniswap {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Swaps tokens using a given UniswapV2Router.\n     * @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.\n     * @param sourceAmount amount of source token to swap.\n     * @param minDestination The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param v2RouterAddress The UniswapV2Router router address to use.\n     * @return uint256 The destination amount that was acquired from the swap.\n     */\n    function swapWithRouter(\n        address[] memory path,\n        uint256 sourceAmount,\n        uint256 minDestination,\n        address v2RouterAddress\n    ) public returns (uint256) {\n        require(path.length >= 2, \"UNI_PATH_TOO_SHORT\");\n        address source = path[0];\n        address destination = path[path.length - 1];\n        require(source != destination, \"UNI_SRC_DST_SAME\");\n\n        IERC20(source).safeIncreaseAllowance(v2RouterAddress, sourceAmount);\n        uint256[] memory amounts =\n            IUniswapV2Router02(v2RouterAddress).swapExactTokensForTokens(\n                sourceAmount,\n                minDestination,\n                path,\n                address(this),\n                block.timestamp\n            );\n\n        require(amounts.length == path.length, \"UNI_ERROR_SWAPPING\");\n        return amounts[amounts.length - 1];\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/providers/uniswap/UniSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Interfaces\nimport \"./IUniswapV2Router02.sol\";\nimport \"../../base/Base.sol\";\nimport \"../../interfaces/IPriceAggregator.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\n/**  contract that this contract inherits from                                                      **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract allows other contracts to extend it and swap tokens via Uniswap using a delegatcall.\n *\n * @author develop@teller.finance\n */\ncontract UniSwapper is Base {\n    /**\n     * @notice Swaps tokens using UniswapV2Router via the platform defined Uniswap contract.\n     * @notice Allows for a custom minimum destination amount to be required.\n     * @dev See the swap function below.\n     */\n    function _uniswap(\n        address[] memory path,\n        uint256 sourceAmount,\n        uint256 minDestination\n    ) internal returns (uint256) {\n        address uniswapV2RouterAddress = settings.getUniswapV2RouterAddress();\n        return\n            _swap(path, sourceAmount, minDestination, uniswapV2RouterAddress);\n    }\n\n    /**\n     * @notice Swaps tokens using UniswapV2Router via the platform defined Uniswap contract.\n     * @notice Will check Uniswap via the router what the expected minimum destination amount should be.\n     * @dev See the swap function below.\n     */\n    function _uniswap(address[] memory path, uint256 sourceAmount)\n        internal\n        returns (uint256)\n    {\n        address uniswapV2RouterAddress = settings.getUniswapV2RouterAddress();\n        uint256 minDestination =\n            IUniswapV2Router02(uniswapV2RouterAddress).getAmountsOut(\n                sourceAmount,\n                path\n            )[path.length - 1];\n        return\n            _swap(path, sourceAmount, minDestination, uniswapV2RouterAddress);\n    }\n\n    /**\n     * @notice Swaps tokens using UniswapV2Router via the platform defined Uniswap contract.\n     * @dev The source and destination tokens must be supported by the supplied PriceAggregator.\n     * @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.\n     * @param sourceAmount amount of source token to swap.\n     * @param minDestination The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param uniswapV2RouterAddress The UniswapV2Router router address to use.\n     * @return uint256 The destination amount that was acquired from the swap.\n     */\n    function _swap(\n        address[] memory path,\n        uint256 sourceAmount,\n        uint256 minDestination,\n        address uniswapV2RouterAddress\n    ) private returns (uint256) {\n        IPriceAggregator priceAggregator = settings.priceAggregator();\n        require(\n            priceAggregator.isTokenSupported(path[0]),\n            \"UNI_SRC_NOT_SUPPORTED\"\n        );\n        require(\n            priceAggregator.isTokenSupported(path[path.length - 1]),\n            \"UNI_DST_NOT_SUPPORTED\"\n        );\n\n        (, , address uniswap) =\n            logicRegistry.getLogicVersion(keccak256(\"Uniswap\"));\n        (bool success, bytes memory data) =\n            uniswap.delegatecall(\n                abi.encodeWithSignature(\n                    \"swapWithRouter(address[],uint256,uint256,address)\",\n                    path,\n                    sourceAmount,\n                    minDestination,\n                    uniswapV2RouterAddress\n                )\n            );\n\n        assembly {\n            if eq(success, 0) {\n                revert(add(data, 0x20), returndatasize())\n            }\n        }\n\n        return abi.decode(data, (uint256));\n    }\n}\n"
    },
    "contracts/base/lending-pool/LendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"../../util/CompoundRatesLib.sol\";\nimport \"../../util/NumbersLib.sol\";\n\n// Interfaces\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../../interfaces/loans/ILoanManager.sol\";\nimport \"../../providers/compound/CErc20Interface.sol\";\nimport \"../../providers/compound/IComptroller.sol\";\nimport \"../../interfaces/IMarketRegistry.sol\";\nimport \"../../interfaces/ITToken.sol\";\nimport \"../../interfaces/LendingPoolInterface.sol\";\n\nimport \"./LendingPoolStorage.sol\";\n\n// Contracts\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../Base.sol\";\nimport \"../../providers/uniswap/UniSwapper.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice The LendingPool contract holds all of the tokens that lenders transfer into the protocol.\n    It is the contract that lenders interact with to deposit and withdraw their tokens including interest.\n\n    @author develop@teller.finance\n */\ncontract LendingPool is LendingPoolInterface, Base, UniSwapper {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using CompoundRatesLib for CErc20Interface;\n    using NumbersLib for uint256;\n    using AddressLib for address;\n\n    uint8 public constant EXCHANGE_RATE_DECIMALS = 36;\n\n    ITToken public override tToken;\n\n    ERC20 public override lendingToken;\n\n    CErc20Interface public override cToken;\n\n    IComptroller public override compound;\n\n    ERC20 public override comp;\n\n    IMarketRegistry public marketRegistry;\n\n    /*\n        The total amount of underlying asset that has been originally been supplied by each\n        lender not including interest earned.\n    */\n    mapping(address => uint256) internal _totalSuppliedUnderlyingLender;\n\n    // The total amount of underlying asset that has been lent out for loans.\n    uint256 internal _totalBorrowed;\n\n    // The total amount of underlying asset that has been repaid from loans.\n    uint256 internal _totalRepaid;\n\n    // The total amount of underlying interest that has been claimed for each lender.\n    mapping(address => uint256) internal _totalInterestEarnedLender;\n\n    // The total amount of underlying interest the pool has earned from loans being repaid.\n    uint256 public override totalInterestEarned;\n\n    /**\n     * @notice It holds the platform AssetSettings instance.\n     */\n    AssetSettingsInterface public assetSettings;\n\n    bool internal _notEntered;\n\n    /** Modifiers */\n\n    /**\n        @notice It checks the address is the LoanManager contract address.\n        @dev It throws a require error if parameter is not equal to loan manager contract address.\n     */\n    modifier isLoan() {\n        _requireIsLoan();\n        _;\n    }\n\n    /**\n     * @notice Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    /* Constructor */\n\n    /** External Functions */\n\n    /**\n        @notice It allows users to deposit tokens into the pool.\n        @dev the user must call ERC20.approve function previously.\n        @dev If the cToken is available (not 0x0), it deposits the lending token amount into Compound directly.\n        @param lendingTokenAmount of tokens to deposit in the pool.\n    */\n    function deposit(uint256 lendingTokenAmount)\n        external\n        override\n        updateImpIfNeeded\n        nonReentrant\n        whenNotPaused\n        whenLendingPoolNotPaused(address(this))\n        onlyAuthorized\n    {\n        _accrueInterest();\n        uint256 previousSupply = _getTotalSupplied();\n\n        // Transferring tokens to the LendingPool\n        lendingTokenAmount = tokenTransferFrom(msg.sender, lendingTokenAmount);\n\n        require(\n            previousSupply.add(lendingTokenAmount) <=\n                assetSettings.getMaxTVLAmount(address(lendingToken)),\n            \"MAX_TVL_REACHED\"\n        );\n\n        _totalSuppliedUnderlyingLender[\n            msg.sender\n        ] = _totalSuppliedUnderlyingLender[msg.sender].add(lendingTokenAmount);\n\n        // Depositing to Compound accrues interest which changes the exchange rate.\n        _depositToCompoundIfSupported(lendingTokenAmount);\n\n        // Mint tToken tokens\n        uint256 tTokenAmount =\n            _tTokensFromLendingTokens(\n                lendingTokenAmount,\n                _exchangeRateForSupply(previousSupply)\n            );\n        tTokenMint(msg.sender, tTokenAmount);\n        // Emit event\n        emit TokenDeposited(msg.sender, lendingTokenAmount, tTokenAmount);\n    }\n\n    /**\n        @notice It allows any tToken holder to burn their tToken tokens and withdraw their tokens.\n        @dev If the cToken is available (not 0x0), it withdraws the lending tokens from Compound before\n        transferring the tokens to the holder.\n        @param lendingTokenAmount of tokens to withdraw.\n     */\n    function withdraw(uint256 lendingTokenAmount)\n        external\n        override\n        updateImpIfNeeded\n        nonReentrant\n        whenNotPaused\n        whenLendingPoolNotPaused(address(this))\n        onlyAuthorized\n    {\n        uint256 exchangeRate = _exchangeRateCurrent();\n        uint256 tTokenAmount =\n            _tTokensFromLendingTokens(lendingTokenAmount, exchangeRate);\n\n        require(tTokenAmount > 0, \"WITHDRAW_TTOKEN_DUST\");\n        require(\n            IERC20(address(tToken)).balanceOf(msg.sender) > tTokenAmount,\n            \"TTOKEN_NOT_ENOUGH_BALANCE\"\n        );\n\n        _withdraw(lendingTokenAmount, tTokenAmount, exchangeRate);\n    }\n\n    function withdrawAll()\n        external\n        updateImpIfNeeded\n        nonReentrant\n        whenNotPaused\n        whenLendingPoolNotPaused(address(this))\n        onlyAuthorized\n        returns (uint256)\n    {\n        uint256 tTokenAmount = IERC20(address(tToken)).balanceOf(msg.sender);\n        uint256 exchangeRate = _exchangeRateCurrent();\n        uint256 lendingTokenAmount =\n            _lendingTokensFromTTokens(tTokenAmount, exchangeRate);\n\n        _withdraw(lendingTokenAmount, tTokenAmount, exchangeRate);\n\n        return lendingTokenAmount;\n    }\n\n    /**\n        @notice It allows a borrower repaying their loan.\n        @dev This function can be called ONLY by the LoanManager contract.\n        @dev It requires a ERC20.approve call before calling it.\n        @dev It throws a require error if borrower called ERC20.approve function before calling it.\n        @param principalAmount amount of tokens towards the principal.\n        @param interestAmount amount of tokens towards the interest.\n        @param borrower address that is repaying the loan.\n     */\n    function repay(\n        uint256 principalAmount,\n        uint256 interestAmount,\n        address borrower\n    )\n        external\n        override\n        updateImpIfNeeded\n        nonReentrant\n        isLoan\n        whenLendingPoolNotPaused(address(this))\n        onlyAuthorized\n    {\n        uint256 totalAmount = principalAmount.add(interestAmount);\n        require(totalAmount > 0, \"REPAY_ZERO\");\n\n        // Transfers tokens to LendingPool.\n        tokenTransferFrom(borrower, totalAmount);\n\n        _totalRepaid = _totalRepaid.add(principalAmount);\n        totalInterestEarned = totalInterestEarned.add(interestAmount);\n\n        _depositToCompoundIfSupported(totalAmount);\n\n        // Emits event.\n        emit TokenRepaid(borrower, totalAmount);\n    }\n\n    /**\n        @notice Once the loan is created, it transfers the amount of tokens to the borrower.\n\n        @param amount of tokens to transfer.\n        @param borrower address which will receive the tokens.\n        @dev This function only can be invoked by the ILoanManager implementation.\n        @dev It withdraws the lending tokens from Compound before transferring tokens to the borrower.\n     */\n    function createLoan(uint256 amount, address borrower)\n        external\n        override\n        updateImpIfNeeded\n        nonReentrant\n        isLoan\n        whenLendingPoolNotPaused(address(this))\n        onlyAuthorized\n    {\n        uint256 lendingTokenBalance = lendingToken.balanceOf(address(this));\n        if (lendingTokenBalance < amount) {\n            _withdrawFromCompoundIfSupported(amount.sub(lendingTokenBalance));\n        }\n\n        // Transfer tokens to the borrower.\n        tokenTransfer(borrower, amount);\n\n        _totalBorrowed = _totalBorrowed.add(amount);\n    }\n\n    function swapAccumulatedComp() external updateImpIfNeeded {\n        _swapAccumulatedComp();\n    }\n\n    function getMarketStateCurrent()\n        external\n        updateImpIfNeeded\n        returns (\n            uint256 totalSupplied,\n            uint256 totalBorrowed,\n            uint256 totalRepaid,\n            uint256 totalOnLoan\n        )\n    {\n        _accrueInterest();\n        return _getMarketState();\n    }\n\n    /**\n        @notice It calculates the market state values across all markets.\n        @notice It returns values that represent the global state across all markets.\n        @return totalSupplied\n        @return totalBorrowed\n        @return totalRepaid\n        @return totalOnLoan\n     */\n    function getMarketState()\n        external\n        view\n        override\n        returns (\n            uint256 totalSupplied,\n            uint256 totalBorrowed,\n            uint256 totalRepaid,\n            uint256 totalOnLoan\n        )\n    {\n        return _getMarketState();\n    }\n\n    /**\n        @notice It returns the balance of underlying tokens a lender owns with the amount\n        of TTokens owned and the current exchange rate.\n        @return a lender's balance of the underlying token in the pool.\n     */\n    function balanceOfUnderlying(address lender)\n        external\n        override\n        updateImpIfNeeded\n        returns (uint256)\n    {\n        return\n            _lendingTokensFromTTokens(\n                IERC20(address(tToken)).balanceOf(lender),\n                _exchangeRateCurrent()\n            );\n    }\n\n    /**\n        @notice Returns the total amount of interest earned by a lender.\n        @dev This value includes already claimed + unclaimed interest earned.\n        @return total interest earned by lender.\n     */\n    function getLenderInterestEarned(address lender)\n        external\n        override\n        updateImpIfNeeded\n        returns (uint256)\n    {\n        uint256 currentLenderInterest =\n            _calculateLenderInterestEarned(lender, _exchangeRateCurrent());\n        return _totalInterestEarnedLender[lender].add(currentLenderInterest);\n    }\n\n    /**\n        @notice Returns the amount of claimable interest a lender has earned.\n        @return claimable interest value.\n     */\n    function getClaimableInterestEarned(address lender)\n        external\n        override\n        updateImpIfNeeded\n        returns (uint256)\n    {\n        return _calculateLenderInterestEarned(lender, _exchangeRateCurrent());\n    }\n\n    /**\n        @notice It gets the debt-to-supply (DtS) ratio for a given market, including a new loan amount.\n        @notice The formula to calculate DtS ratio (including a new loan amount) is:\n\n            DtS = (SUM(total borrowed) - SUM(total repaid) + NewLoanAmount) / SUM(total supplied)\n\n        @notice The value has 2 decimal places.\n            Example:\n                100 => 1%\n        @param loanAmount a new loan amount to consider in the ratio.\n        @return the debt-to-supply ratio value.\n     */\n    function getDebtRatioFor(uint256 loanAmount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 totalSupplied = _getTotalSupplied();\n        return\n            totalSupplied == 0\n                ? 0\n                : _totalBorrowed.add(loanAmount).sub(_totalRepaid).ratioOf(\n                    totalSupplied\n                );\n    }\n\n    /**\n        @notice It calculates the current exchange rate for the TToken based on the total supply of the lending token.\n        @return the exchange rate for 1 TToken to the underlying token.\n     */\n    function exchangeRateCurrent()\n        external\n        updateImpIfNeeded\n        returns (uint256)\n    {\n        return _exchangeRateCurrent();\n    }\n\n    /**\n        @notice It calculates the stored exchange rate for the TToken based on the total supply of the lending token.\n        @return the exchange rate for 1 TToken to the underlying token.\n     */\n    function exchangeRateStored() external view returns (uint256) {\n        return _exchangeRateStored();\n    }\n\n    function tTokensFromLendingTokens(uint256 lendingTokenAmount)\n        external\n        updateImpIfNeeded\n        returns (uint256)\n    {\n        return\n            _tTokensFromLendingTokens(\n                lendingTokenAmount,\n                _exchangeRateCurrent()\n            );\n    }\n\n    function lendingTokensFromTTokens(uint256 tTokenAmount)\n        external\n        updateImpIfNeeded\n        returns (uint256)\n    {\n        return _lendingTokensFromTTokens(tTokenAmount, _exchangeRateCurrent());\n    }\n\n    /**\n        @notice It initializes the contract state variables.\n        @param aMarketRegistry the MarketRegistry contract.\n        @param aLendingToken The underlying token that is used for lending.\n        @param aTToken the Teller token to link to the lending pool.\n        @param settingsAddress Settings contract address.\n        @dev It throws a require error if the contract is already initialized.\n     */\n    function initialize(\n        IMarketRegistry aMarketRegistry,\n        address aLendingToken,\n        address aTToken,\n        address settingsAddress\n    ) external override {\n        aTToken.requireNotEmpty(\"TTOKEN_ADDRESS_IS_REQUIRED\");\n\n        Base._initialize(settingsAddress);\n\n        marketRegistry = aMarketRegistry;\n        tToken = ITToken(aTToken);\n        lendingToken = ERC20(aLendingToken);\n        cToken = CErc20Interface(\n            settings.getCTokenAddress(address(lendingToken))\n        );\n        compound = IComptroller(cToken.comptroller());\n        comp = ERC20(compound.getCompAddress());\n        assetSettings = settings.assetSettings();\n\n        _notEntered = true;\n    }\n\n    /** Internal functions */\n\n    function _calculateLenderInterestEarned(\n        address lender,\n        uint256 exchangeRate\n    ) internal view returns (uint256) {\n        uint256 lenderUnderlyingBalance =\n            _lendingTokensFromTTokens(\n                IERC20(address(tToken)).balanceOf(lender),\n                exchangeRate\n            );\n        return\n            lenderUnderlyingBalance.sub(_totalSuppliedUnderlyingLender[lender]);\n    }\n\n    /**\n        @notice It calculates the current exchange rate for the TToken based on the total supply of the lending token.\n        @dev This will accrue interest for us before we calculate anything.\n        @return the exchange rate for 1 TToken to the underlying token.\n     */\n    function _exchangeRateCurrent() internal returns (uint256) {\n        _accrueInterest();\n        return _exchangeRateStored();\n    }\n\n    /**\n        @notice It calculates the exchange rate for the TToken based on the total supply of the lending token.\n        @dev If the lending token is deposited into Compound the value calculated uses the exchangeRateStored value.\n        @dev If the intended use case is for the current exchange rate, call the _exchangeRateCurrent function above.\n        @return the exchange rate for 1 TToken to the underlying token.\n     */\n    function _exchangeRateStored() internal view returns (uint256) {\n        return _exchangeRateForSupply(_getTotalSupplied());\n    }\n\n    function _exchangeRateForSupply(uint256 supply)\n        internal\n        view\n        returns (uint256)\n    {\n        if (IERC20(address(tToken)).totalSupply() == 0) {\n            return uint256(10)**uint256(EXCHANGE_RATE_DECIMALS);\n        }\n\n        return\n            supply.mul(uint256(10)**uint256(EXCHANGE_RATE_DECIMALS)).div(\n                IERC20(address(tToken)).totalSupply()\n            );\n    }\n\n    /**\n        @notice It calculates the market state values across all markets.\n        @notice Returns values that represent the global state across all markets.\n        @return totalSupplied\n        @return totalBorrowed\n        @return totalRepaid\n        @return totalOnLoan\n     */\n    function _getMarketState()\n        internal\n        view\n        returns (\n            uint256 totalSupplied,\n            uint256 totalBorrowed,\n            uint256 totalRepaid,\n            uint256 totalOnLoan\n        )\n    {\n        totalSupplied = _getTotalSupplied();\n        totalBorrowed = _totalBorrowed;\n        totalRepaid = _totalRepaid;\n        totalOnLoan = _totalBorrowed.sub(totalRepaid);\n    }\n\n    /**\n        @notice It calculates the total supply of the lending token across all markets.\n        @return totalSupplied the total supply denoted in the lending token.\n     */\n    function _getTotalSupplied() internal view returns (uint256 totalSupplied) {\n        totalSupplied = lendingToken.balanceOf(address(this)).add(\n            _totalBorrowed.sub(_totalRepaid)\n        );\n\n        if (address(cToken) != address(0)) {\n            totalSupplied = totalSupplied.add(\n                cToken.valueInUnderlying(cToken.balanceOf(address(this)))\n            );\n        }\n    }\n\n    function _withdraw(\n        uint256 lendingTokenAmount,\n        uint256 tTokenAmount,\n        uint256 exchangeRate\n    ) internal {\n        uint256 lendingTokenBalance = lendingToken.balanceOf(address(this));\n\n        _withdrawFromCompoundIfSupported(\n            lendingTokenAmount.sub(lendingTokenBalance)\n        );\n\n        uint256 currentLenderInterest =\n            _calculateLenderInterestEarned(msg.sender, exchangeRate);\n        uint256 totalSuppliedDiff;\n        if (lendingTokenAmount > currentLenderInterest) {\n            totalSuppliedDiff = lendingTokenAmount.sub(currentLenderInterest);\n            _totalInterestEarnedLender[msg.sender] = _totalInterestEarnedLender[\n                msg.sender\n            ]\n                .add(currentLenderInterest);\n        } else {\n            _totalInterestEarnedLender[msg.sender] = _totalInterestEarnedLender[\n                msg.sender\n            ]\n                .add(lendingTokenAmount);\n        }\n        _totalSuppliedUnderlyingLender[\n            msg.sender\n        ] = _totalSuppliedUnderlyingLender[msg.sender].sub(totalSuppliedDiff);\n\n        // Burn tToken tokens.\n        tToken.burn(msg.sender, tTokenAmount);\n\n        // Transfers tokens\n        tokenTransfer(msg.sender, lendingTokenAmount);\n\n        // Emit event.\n        emit TokenWithdrawn(msg.sender, lendingTokenAmount, tTokenAmount);\n    }\n\n    function _tTokensFromLendingTokens(\n        uint256 lendingTokenAmount,\n        uint256 exchangeRate\n    ) internal pure returns (uint256) {\n        return\n            lendingTokenAmount\n                .mul(uint256(10)**uint256(EXCHANGE_RATE_DECIMALS))\n                .div(exchangeRate);\n    }\n\n    function _lendingTokensFromTTokens(\n        uint256 tTokenAmount,\n        uint256 exchangeRate\n    ) internal pure returns (uint256) {\n        return\n            tTokenAmount.mul(exchangeRate).div(\n                uint256(10)**uint256(EXCHANGE_RATE_DECIMALS)\n            );\n    }\n\n    /**\n        @notice It deposits a given amount of tokens to Compound.\n        @dev The cToken address must be defined in AssetSettings.\n        @dev The underlying token value of the tokens to be deposited must be positive. Because the decimals of\n            cTokens and the underlying asset can differ, the deposit of dust tokens may result in no cTokens minted.\n        @param amount The amount of underlying tokens to deposit.\n        @return difference The amount of underlying tokens deposited.\n     */\n    function _depositToCompoundIfSupported(uint256 amount)\n        internal\n        returns (uint256 difference)\n    {\n        if (address(cToken) == address(0)) {\n            return 0;\n        }\n\n        // approve the cToken contract to take lending tokens\n        lendingToken.safeApprove(address(cToken), amount);\n\n        uint256 balanceBefore = lendingToken.balanceOf(address(this));\n\n        // Now mint cTokens, which will take lending tokens\n        uint256 mintResult = cToken.mint(amount);\n        require(mintResult == 0, \"COMPOUND_DEPOSIT_ERROR\");\n\n        uint256 balanceAfter = lendingToken.balanceOf(address(this));\n        difference = balanceBefore.sub(balanceAfter);\n        require(difference > 0, \"DEPOSIT_CTOKEN_DUST\");\n    }\n\n    /**\n        @notice It withdraws a given amount of tokens from Compound.\n        @param amount The amount of underlying tokens to withdraw.\n        @return The amount of underlying tokens withdrawn.\n     */\n    function _withdrawFromCompoundIfSupported(uint256 amount)\n        internal\n        returns (uint256)\n    {\n        if (address(cToken) == address(0)) {\n            return 0;\n        }\n\n        uint256 balanceBefore = lendingToken.balanceOf(address(this));\n\n        uint256 redeemResult = cToken.redeemUnderlying(amount);\n        require(redeemResult == 0, \"COMPOUND_REDEEM_UNDERLYING_ERROR\");\n\n        uint256 balanceAfter = lendingToken.balanceOf(address(this));\n        return balanceAfter.sub(balanceBefore);\n    }\n\n    function _swapAccumulatedComp() internal {\n        address[] memory cTokens = new address[](1);\n        cTokens[0] = address(cToken);\n\n        compound.claimComp(address(this), cTokens);\n\n        // Amount which goes into the swap is COMP balance of the lending pool.\n        uint256 amountIn = comp.balanceOf(address(this));\n\n        // Path of the swap is always COMP -> WETH -> LendingToken.\n        address[] memory path = new address[](3);\n        path[0] = address(comp);\n        path[1] = settings.WETH_ADDRESS();\n        path[2] = address(lendingToken);\n\n        _uniswap(path, amountIn);\n    }\n\n    /**\n        @notice It validates whether transaction sender is the loan manager contract address.\n        @dev This function is overriden in some mock contracts for testing purposes.\n     */\n    function _requireIsLoan() internal view {\n        require(\n            marketRegistry.loanManagerRegistry(address(this), msg.sender),\n            \"CALLER_NOT_LOANS_CONTRACT\"\n        );\n    }\n\n    /** Private functions */\n\n    /**\n        @notice It transfers an amount of tokens to a specific address.\n        @param recipient address which will receive the tokens.\n        @param amount of tokens to transfer.\n        @dev It throws a require error if 'transfer' invocation fails.\n     */\n    function tokenTransfer(address recipient, uint256 amount) private {\n        uint256 currentBalance = lendingToken.balanceOf(address(this));\n        require(currentBalance >= amount, \"LENDING_TOKEN_NOT_ENOUGH_BALANCE\");\n        lendingToken.safeTransfer(recipient, amount);\n    }\n\n    /**\n        @notice It transfers an amount of tokens from an address to this contract.\n        @param from address where the tokens will transfer from.\n        @param amount to be transferred.\n        @dev It throws a require error if 'transferFrom' invocation fails.\n     */\n    function tokenTransferFrom(address from, uint256 amount)\n        private\n        returns (uint256 balanceIncrease)\n    {\n        uint256 balanceBefore = lendingToken.balanceOf(address(this));\n        uint256 allowance = lendingToken.allowance(from, address(this));\n        require(allowance >= amount, \"LEND_TOKEN_NOT_ENOUGH_ALLOWANCE\");\n        lendingToken.safeTransferFrom(from, address(this), amount);\n        return lendingToken.balanceOf(address(this)).sub(balanceBefore);\n    }\n\n    /**\n        @notice It mints tToken tokens, and send them to a specific address.\n        @param to address which will receive the minted tokens.\n        @param amount to be minted.\n        @dev This contract must has a Minter Role in tToken (mintable) token.\n        @dev It throws a require error if mint invocation fails.\n     */\n    function tTokenMint(address to, uint256 amount) private {\n        tToken.mint(to, amount);\n    }\n\n    function _accrueInterest() private {\n        address(cToken).call(abi.encodeWithSignature(\"accrueInterest()\"));\n    }\n}\n"
    },
    "contracts/util/CompoundRatesLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Interfaces\nimport \"../providers/compound/CErc20Interface.sol\";\n\n// Contracts\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nlibrary CompoundRatesLib {\n    function EXCHANGE_RATE_DECIMALS() public pure returns (uint8) {\n        return 18;\n    }\n\n    function valueInUnderlying(CErc20Interface cToken, uint256 cTokenAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            (cTokenAmount * cToken.exchangeRateStored()) /\n            (uint256(10)**uint256(EXCHANGE_RATE_DECIMALS()));\n    }\n\n    function valueOfUnderlying(CErc20Interface cToken, uint256 underlyingAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            (underlyingAmount *\n                uint256(10)**uint256(EXCHANGE_RATE_DECIMALS())) /\n            cToken.exchangeRateStored();\n    }\n}\n"
    },
    "contracts/base/lending-pool/LendingPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n// Interfaces\nimport \"../../interfaces/loans/ILoanManager.sol\";\nimport \"../../providers/compound/CErc20Interface.sol\";\nimport \"../../providers/compound/IComptroller.sol\";\nimport \"../../interfaces/IMarketRegistry.sol\";\nimport \"../../interfaces/ITToken.sol\";\nimport \"../../interfaces/AssetSettingsInterface.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice The LendingPool contract holds all of the tokens that lenders transfer into the protocol.\n    It is the contract that lenders interact with to deposit and withdraw their tokens including interest.\n\n    @author develop@teller.finance\n */\nabstract contract LendingPoolStorage {\n    uint8 public constant EXCHANGE_RATE_DECIMALS = 36;\n\n    ITToken public tToken;\n\n    ERC20 public lendingToken;\n\n    CErc20Interface public cToken;\n\n    IComptroller public compound;\n\n    ERC20 public comp;\n\n    IMarketRegistry public marketRegistry;\n\n    /*\n        The total amount of underlying asset that has been originally been supplied by each\n        lender not including interest earned.\n    */\n    mapping(address => uint256) internal _totalSuppliedUnderlyingLender;\n\n    // The total amount of underlying asset that has been lent out for loans.\n    uint256 internal _totalBorrowed;\n\n    // The total amount of underlying asset that has been repaid from loans.\n    uint256 internal _totalRepaid;\n\n    // The total amount of underlying interest that has been claimed for each lender.\n    mapping(address => uint256) internal _totalInterestEarnedLender;\n\n    // The total amount of underlying interest the pool has earned from loans being repaid.\n    uint256 public totalInterestEarned;\n\n    /**\n     * @notice It holds the platform AssetSettings instance.\n     */\n    AssetSettingsInterface public assetSettings;\n\n    bool internal _notEntered;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/base/loans/LoanManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries and common\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../util/TellerCommon.sol\";\nimport \"../../util/NumbersLib.sol\";\n\n// Contracts\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../Base.sol\";\nimport \"./LoanStorage.sol\";\nimport \"./../proxies/DynamicProxy.sol\";\nimport \"../Factory.sol\";\n\n// Interfaces\nimport \"../../interfaces/loans/ILoanManager.sol\";\nimport \"../../interfaces/loans/ILoanStorage.sol\";\nimport \"../../interfaces/loans/ILoanTermsConsensus.sol\";\nimport \"../../interfaces/LendingPoolInterface.sol\";\nimport \"../../interfaces/escrow/IEscrow.sol\";\nimport \"../../interfaces/IInitializeableDynamicProxy.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\n/**  contract that this contract inherits from                                                      **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract is used as a basis for the creation of the different types of loans across the platform\n * @notice It implements the Base contract from Teller and the ILoanManager\n *\n * @author develop@teller.finance\n */\ncontract LoanManager is\n    ILoanManager,\n    ILoanData,\n    ILoanTermsConsensus,\n    Factory,\n    Base,\n    LoanStorage\n{\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using NumbersLib for uint256;\n    using NumbersLib for int256;\n    using AddressLib for address;\n\n    /* Modifiers */\n\n    /**\n     * @notice Checks whether the loan is active or not\n     * @dev Throws a require error if the loan is not active\n     * @param loanID number of loan to check\n     */\n    modifier loanActive(uint256 loanID) {\n        require(\n            loans[loanID].status == TellerCommon.LoanStatus.Active,\n            \"LOAN_NOT_ACTIVE\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Checks whether the loan is active and has been set or not\n     * @dev Throws a require error if the loan is not active or has not been set\n     * @param loanID number of loan to check\n     */\n    modifier loanActiveOrSet(uint256 loanID) {\n        require(isActiveOrSet(loanID), \"LOAN_NOT_ACTIVE_OR_SET\");\n        _;\n    }\n\n    /**\n     * @notice Checks the given loan request is valid.\n     * @dev It throws an require error if the duration exceeds the maximum loan duration.\n     * @dev It throws an require error if the loan amount exceeds the maximum loan amount for the given asset.\n     * @param loanRequest to validate.\n     */\n    modifier withValidLoanRequest(TellerCommon.LoanRequest memory loanRequest) {\n        uint256 maxLoanDuration = settings.getMaximumLoanDurationValue();\n        require(\n            maxLoanDuration >= loanRequest.duration,\n            \"DURATION_EXCEEDS_MAX_DURATION\"\n        );\n\n        bool exceedsMaxLoanAmount =\n            assetSettings.exceedsMaxLoanAmount(\n                lendingToken,\n                loanRequest.amount\n            );\n        require(!exceedsMaxLoanAmount, \"AMOUNT_EXCEEDS_MAX_AMOUNT\");\n\n        require(\n            _isDebtRatioValid(loanRequest.amount),\n            \"SUPPLY_TO_DEBT_EXCEEDS_MAX\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    /* Public Functions */\n\n    /**\n     * @notice See LoanData.getBorrowerLoans\n     */\n    function getBorrowerLoans(address borrower)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return borrowerLoans[borrower];\n    }\n\n    /**\n     * @notice See LoanData.isActiveOrSet\n     */\n    function isActiveOrSet(uint256 loanID) public view override returns (bool) {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\"isActiveOrSet(uint256)\", loanID)\n            );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice See LoanData.getTotalOwed\n     */\n    function getTotalOwed(uint256 loanID)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\"getTotalOwed(uint256)\", loanID)\n            );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice See LoanData.getLoanAmount\n     */\n    function getLoanAmount(uint256 loanID)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\"getLoanAmount(uint256)\", loanID)\n            );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice See LoanData.isLoanSecured\n     */\n    function isLoanSecured(uint256 loanID) public view override returns (bool) {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\"isLoanSecured(uint256)\", loanID)\n            );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice See LoanData.canGoToEOA\n     */\n    function canGoToEOA(uint256 loanID) public view override returns (bool) {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\"canGoToEOA(uint256)\", loanID)\n            );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice See LoanData.getInterestOwedFor\n     */\n    function getInterestOwedFor(uint256 loanID, uint256 amountBorrow)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\n                    \"getInterestOwedFor(uint256,uint256)\",\n                    loanID,\n                    amountBorrow\n                )\n            );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice See LoanData.getInterestRatio\n     */\n    function getInterestRatio(uint256 loanID)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\"getInterestRatio(uint256)\", loanID)\n            );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice See LoanData.getCollateralInLendingTokens\n     */\n    function getCollateralInLendingTokens(uint256 loanID)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\n                    \"getCollateralInLendingTokens(uint256)\",\n                    loanID\n                )\n            );\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice See LoanData.getCollateralNeededInfo\n     */\n    function getCollateralNeededInfo(uint256 loanID)\n        public\n        view\n        override\n        returns (\n            int256,\n            int256,\n            uint256\n        )\n    {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\n                    \"getCollateralNeededInfo(uint256)\",\n                    loanID\n                )\n            );\n        return abi.decode(data, (int256, int256, uint256));\n    }\n\n    /**\n     * @notice See LoanData.getCollateralNeededInTokens\n     */\n    function getCollateralNeededInTokens(uint256 loanID)\n        public\n        view\n        override\n        returns (int256, uint256)\n    {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\n                    \"getCollateralNeededInTokens(uint256)\",\n                    loanID\n                )\n            );\n        return abi.decode(data, (int256, uint256));\n    }\n\n    /**\n     * @notice See LoanData.isLiquidable\n     */\n    function isLiquidable(uint256 loanID) public view override returns (bool) {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\"isLiquidable(uint256)\", loanID)\n            );\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice See LoanData.getLiquidationReward\n     */\n    function getLiquidationReward(uint256 loanID)\n        public\n        view\n        override\n        returns (int256)\n    {\n        bytes memory data =\n            _delegateView(\n                loanData,\n                abi.encodeWithSignature(\"getLiquidationReward(uint256)\", loanID)\n            );\n        return abi.decode(data, (int256));\n    }\n\n    function processLoanTerms(\n        TellerCommon.LoanRequest memory request,\n        TellerCommon.LoanResponse[] memory responses\n    )\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        bytes memory data =\n            _delegateView(\n                loanTermsConsensus,\n                abi.encodeWithSignature(\n                    \"processLoanTerms((address,address,address,uint256,uint256,uint256,uint256),(address,address,uint256,uint256,uint256,uint256,(uint8,bytes32,bytes32))[])\",\n                    request,\n                    responses\n                )\n            );\n        return abi.decode(data, (uint256, uint256, uint256));\n    }\n\n    /* External Functions */\n\n    /**\n     * @notice Creates a loan with the loan request and terms\n     * @param request Struct of the protocol loan request\n     * @param responses List of structs of the protocol loan responses\n     * @param collateralAmount Amount of collateral required for the loan\n     */\n    function createLoanWithTerms(\n        TellerCommon.LoanRequest calldata request,\n        TellerCommon.LoanResponse[] calldata responses,\n        uint256 collateralAmount\n    )\n        external\n        payable\n        override\n        updateImpIfNeeded\n        nonReentrant\n        whenNotPaused\n        withValidLoanRequest(request)\n        onlyAuthorized\n    {\n        require(msg.sender == request.borrower, \"NOT_LOAN_REQUESTER\");\n\n        (uint256 interestRate, uint256 collateralRatio, uint256 maxLoanAmount) =\n            processLoanTerms(request, responses);\n\n        uint256 loanID =\n            _createNewLoan(\n                request,\n                interestRate,\n                collateralRatio,\n                maxLoanAmount\n            );\n\n        if (collateralAmount > 0) {\n            _payInCollateral(loanID, collateralAmount);\n        }\n\n        if (request.recipient.isNotEmpty()) {\n            require(canGoToEOA(loanID), \"UNDER_COLL_WITH_RECIPIENT\");\n        }\n\n        borrowerLoans[request.borrower].push(loanID);\n\n        emit LoanTermsSet(\n            loanID,\n            msg.sender,\n            loans[loanID].loanTerms.recipient,\n            request.requestNonce\n        );\n    }\n\n    /**\n     * @notice Withdraw collateral from a loan, unless this isn't allowed\n     * @param amount The amount of collateral token or ether the caller is hoping to withdraw.\n     * @param loanID The ID of the loan the collateral is for\n     */\n    function withdrawCollateral(uint256 amount, uint256 loanID)\n        external\n        override\n        updateImpIfNeeded\n        nonReentrant\n        loanActiveOrSet(loanID)\n        whenNotPaused\n        whenLendingPoolNotPaused(address(lendingPool))\n        onlyAuthorized\n    {\n        require(\n            msg.sender == loans[loanID].loanTerms.borrower,\n            \"CALLER_DOESNT_OWN_LOAN\"\n        );\n        require(amount > 0, \"CANNOT_WITHDRAW_ZERO\");\n\n        if (loans[loanID].status == TellerCommon.LoanStatus.Active) {\n            (, int256 neededInCollateralTokens, ) =\n                getCollateralNeededInfo(loanID);\n            if (neededInCollateralTokens > 0) {\n                // Withdrawal amount holds the amount of excess collateral in the loan\n                uint256 withdrawalAmount =\n                    loans[loanID].collateral.sub(\n                        uint256(neededInCollateralTokens)\n                    );\n                require(\n                    withdrawalAmount >= amount,\n                    \"COLLATERAL_AMOUNT_TOO_HIGH\"\n                );\n            }\n        } else {\n            require(\n                loans[loanID].collateral >= amount,\n                \"COLLATERAL_AMOUNT_NOT_MATCH\"\n            );\n        }\n\n        _withdrawCollateral(loanID, amount, payable(msg.sender));\n    }\n\n    /**\n     * @notice Deposit collateral tokens into a loan.\n     * @param borrower The address of the loan borrower.\n     * @param loanID The ID of the loan the collateral is for\n     * @param amount The amount to deposit as collateral.\n     */\n    function depositCollateral(\n        address borrower,\n        uint256 loanID,\n        uint256 amount\n    )\n        external\n        payable\n        override\n        updateImpIfNeeded\n        loanActiveOrSet(loanID)\n        whenNotPaused\n        whenLendingPoolNotPaused(address(lendingPool))\n        onlyAuthorized\n    {\n        borrower.requireEqualTo(\n            loans[loanID].loanTerms.borrower,\n            \"BORROWER_LOAN_ID_MISMATCH\"\n        );\n        require(amount > 0, \"CANNOT_DEPOSIT_ZERO\");\n\n        // Update the loan collateral and total. Transfer tokens to this contract.\n        _payInCollateral(loanID, amount);\n    }\n\n    /**\n     * @notice Take out a loan\n     *\n     * @dev collateral ratio is a percentage of the loan amount that's required in collateral\n     * @dev the percentage will be *(10**2). I.e. collateralRatio of 5244 means 52.44% collateral\n     * @dev is required in the loan. Interest rate is also a percentage with 2 decimal points.\n     */\n    function takeOutLoan(uint256 loanID, uint256 amountBorrow)\n        external\n        override\n        updateImpIfNeeded\n        nonReentrant\n        whenNotPaused\n        whenLendingPoolNotPaused(address(lendingPool))\n        onlyAuthorized\n    {\n        require(msg.sender == loans[loanID].loanTerms.borrower, \"NOT_BORROWER\");\n        require(\n            loans[loanID].status == TellerCommon.LoanStatus.TermsSet,\n            \"LOAN_NOT_SET\"\n        );\n        require(\n            loans[loanID].termsExpiry >= block.timestamp,\n            \"LOAN_TERMS_EXPIRED\"\n        );\n        require(_isDebtRatioValid(amountBorrow), \"SUPPLY_TO_DEBT_EXCEEDS_MAX\");\n        require(\n            loans[loanID].loanTerms.maxLoanAmount >= amountBorrow,\n            \"MAX_LOAN_EXCEEDED\"\n        );\n        // check that enough collateral has been provided for this loan\n        (, int256 neededInCollateral, ) = getCollateralNeededInfo(loanID);\n        require(\n            neededInCollateral <= int256(loans[loanID].collateral),\n            \"MORE_COLLATERAL_REQUIRED\"\n        );\n        require(\n            loans[loanID].lastCollateralIn <=\n                block.timestamp.sub(settings.getSafetyIntervalValue()),\n            \"COLLATERAL_DEPOSITED_RECENTLY\"\n        );\n\n        loans[loanID].borrowedAmount = amountBorrow;\n        loans[loanID].principalOwed = amountBorrow;\n        loans[loanID].interestOwed = getInterestOwedFor(loanID, amountBorrow);\n        loans[loanID].status = TellerCommon.LoanStatus.Active;\n        loans[loanID].loanStartTime = block.timestamp;\n\n        address loanRecipient;\n        bool eoaAllowed = canGoToEOA(loanID);\n        if (eoaAllowed) {\n            loanRecipient = loans[loanID].loanTerms.recipient.isEmpty()\n                ? loans[loanID].loanTerms.borrower\n                : loans[loanID].loanTerms.recipient;\n        } else {\n            loans[loanID].escrow = _createEscrow(loanID);\n            loanRecipient = loans[loanID].escrow;\n        }\n\n        lendingPool.createLoan(amountBorrow, loanRecipient);\n\n        if (!eoaAllowed) {\n            loans[loanID].escrow.requireNotEmpty(\"ESCROW_CONTRACT_NOT_DEFINED\");\n            IEscrow(loans[loanID].escrow).initialize(\n                address(settings),\n                address(lendingPool),\n                loanID,\n                lendingToken,\n                loans[loanID].loanTerms.borrower\n            );\n        }\n\n        emit LoanTakenOut(\n            loanID,\n            loans[loanID].loanTerms.borrower,\n            loans[loanID].escrow,\n            amountBorrow\n        );\n    }\n\n    /**\n     * @notice Make a payment to a loan\n     * @param amount The amount of tokens to pay back to the loan\n     * @param loanID The ID of the loan the payment is for\n     */\n    function repay(uint256 amount, uint256 loanID)\n        external\n        override\n        updateImpIfNeeded\n        nonReentrant\n        loanActive(loanID)\n        whenNotPaused\n        whenLendingPoolNotPaused(address(lendingPool))\n        onlyAuthorized\n    {\n        require(amount > 0, \"AMOUNT_VALUE_REQUIRED\");\n        // calculate the actual amount to repay\n        uint256 totalOwed = getTotalOwed(loanID);\n        if (totalOwed < amount) {\n            amount = totalOwed;\n        }\n        // update the amount owed on the loan\n        totalOwed = totalOwed.sub(amount);\n\n        // Deduct the interest and principal owed\n        uint256 principalPaid;\n        uint256 interestPaid;\n        if (amount < loans[loanID].interestOwed) {\n            interestPaid = amount;\n            loans[loanID].interestOwed = loans[loanID].interestOwed.sub(amount);\n        } else {\n            if (loans[loanID].interestOwed > 0) {\n                interestPaid = loans[loanID].interestOwed;\n                amount = amount.sub(interestPaid);\n                loans[loanID].interestOwed = 0;\n            }\n\n            if (amount > 0) {\n                principalPaid = amount;\n                loans[loanID].principalOwed = loans[loanID].principalOwed.sub(\n                    amount\n                );\n            }\n        }\n\n        // collect the money from the payer\n        lendingPool.repay(principalPaid, interestPaid, msg.sender);\n\n        // if the loan is now fully paid, close it and return collateral\n        if (totalOwed == 0) {\n            loans[loanID].status = TellerCommon.LoanStatus.Closed;\n            _withdrawCollateral(\n                loanID,\n                loans[loanID].collateral,\n                loans[loanID].loanTerms.borrower\n            );\n        }\n\n        emit LoanRepaid(\n            loanID,\n            loans[loanID].loanTerms.borrower,\n            principalPaid.add(interestPaid),\n            msg.sender,\n            totalOwed\n        );\n    }\n\n    /**\n     * @notice Liquidate a loan if it is expired or under collateralized\n     * @param loanID The ID of the loan to be liquidated\n     */\n    function liquidateLoan(uint256 loanID)\n        external\n        override\n        updateImpIfNeeded\n        nonReentrant\n        loanActive(loanID)\n        whenNotPaused\n        whenLendingPoolNotPaused(address(lendingPool))\n    {\n        require(isLiquidable(loanID), \"DOESNT_NEED_LIQUIDATION\");\n\n        int256 rewardInCollateral = getLiquidationReward(loanID);\n\n        // the liquidator pays the amount still owed on the loan\n        uint256 amountToLiquidate =\n            loans[loanID].principalOwed.add(loans[loanID].interestOwed);\n        lendingPool.repay(\n            loans[loanID].principalOwed,\n            loans[loanID].interestOwed,\n            msg.sender\n        );\n\n        loans[loanID].status = TellerCommon.LoanStatus.Closed;\n        loans[loanID].liquidated = true;\n\n        // the caller gets the collateral from the loan\n        _payOutLiquidator(loanID, rewardInCollateral, payable(msg.sender));\n\n        emit LoanLiquidated(\n            loanID,\n            loans[loanID].loanTerms.borrower,\n            msg.sender,\n            rewardInCollateral,\n            amountToLiquidate\n        );\n    }\n\n    /**\n        @notice It adds a new account as a signer.\n        @param account address to add.\n        @dev The sender must be the owner.\n        @dev It throws a require error if the sender is not the owner.\n     */\n    function addSigner(address account) external override updateImpIfNeeded onlyPauser {\n        _delegateTo(\n            loanTermsConsensus,\n            abi.encodeWithSignature(\"addSigner(address)\", account)\n        );\n    }\n\n    /**\n        @notice It adds a list of account as signers.\n        @param accounts addresses to add.\n        @dev The sender must be the owner.\n        @dev It throws a require error if the sender is not the owner.\n     */\n    function addSigners(address[] calldata accounts)\n        external\n        override\n        updateImpIfNeeded\n        onlyPauser\n    {\n        _delegateTo(\n            loanTermsConsensus,\n            abi.encodeWithSignature(\"addSigners(address[])\", accounts)\n        );\n    }\n\n    /**\n     *  @notice It calls the LogicVersionRegistry to update the stored logic address for LoanData.\n     */\n    function updateLoanDataLogic() public override {\n        (, , loanData) = logicRegistry.getLogicVersion(LOAN_DATA_LOGIC_NAME);\n    }\n\n    /**\n     *  @notice It calls the LogicVersionRegistry to update the stored logic address for LoanTermsConsensus.\n     */\n    function updateLoanTermsConsensusLogic() public override {\n        (, , loanTermsConsensus) = logicRegistry.getLogicVersion(\n            LOAN_TERMS_CONSENSUS_LOGIC_NAME\n        );\n    }\n\n    /**\n     * @notice Initializes the current contract instance setting the required parameters.\n     * @param lendingPoolAddress Address of the LendingPool.\n     * @param settingsAddress Address for the platform Settings contract.\n     * @param collateralTokenAddress Address of the collateral token for loans in this contract.\n     * @param initDynamicProxyLogicAddress Address of a deployed InitializeableDynamicProxy contract.\n     */\n    function initialize(\n        address lendingPoolAddress,\n        address settingsAddress,\n        address collateralTokenAddress,\n        address initDynamicProxyLogicAddress\n    ) external override {\n        lendingPoolAddress.requireNotEmpty(\"PROVIDE_LENDING_POOL_ADDRESS\");\n\n        _initialize(settingsAddress);\n\n        lendingPool = LendingPoolInterface(lendingPoolAddress);\n        lendingToken = address(lendingPool.lendingToken());\n        cToken = CErc20Interface(lendingPool.cToken());\n        initDynamicProxyLogic = initDynamicProxyLogicAddress;\n        assetSettings = settings.assetSettings();\n\n        collateralToken = collateralTokenAddress;\n\n        updateLoanDataLogic();\n        updateLoanTermsConsensusLogic();\n\n        _notEntered = true;\n    }\n\n    /** Internal Functions */\n\n    function _delegateTo(address imp, bytes memory sigWithData)\n        internal\n        returns (bytes memory returnData)\n    {\n        bool success;\n        (success, returnData) = imp.delegatecall(sigWithData);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n    }\n\n    function delegateTo(address imp, bytes memory sigWithData)\n        public\n        returns (bytes memory returnData)\n    {\n        require(msg.sender == address(this), \"INVALID_CALLER\");\n        return _delegateTo(imp, sigWithData);\n    }\n\n    function _delegateView(address target, bytes memory sigWithData)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returnData) =\n            address(this).staticcall(\n                abi.encodeWithSignature(\n                    \"delegateTo(address,bytes)\",\n                    target,\n                    sigWithData\n                )\n            );\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return abi.decode(returnData, (bytes));\n    }\n\n    /**\n     * @notice Checks if the loan has an Escrow and claims any tokens then pays out the loan collateral.\n     * @dev See Escrow.claimTokens for more info.\n     * @param loanID The ID of the loan which is being liquidated\n     * @param rewardInCollateral The total amount of reward based in the collateral token to pay the liquidator\n     * @param recipient The address of the liquidator where the liquidation reward will be sent to\n     */\n    function _payOutLiquidator(\n        uint256 loanID,\n        int256 rewardInCollateral,\n        address payable recipient\n    ) internal {\n        if (rewardInCollateral <= 0) {\n            return;\n        }\n        uint256 reward = uint256(rewardInCollateral);\n        if (reward < loans[loanID].collateral) {\n            _payOutCollateral(loanID, reward, recipient);\n        } else if (reward >= loans[loanID].collateral) {\n            uint256 remainingCollateralAmount =\n                reward.sub(loans[loanID].collateral);\n            _payOutCollateral(loanID, loans[loanID].collateral, recipient);\n            if (\n                remainingCollateralAmount > 0 &&\n                loans[loanID].escrow != address(0x0)\n            ) {\n                IEscrow(loans[loanID].escrow).claimTokensByCollateralValue(\n                    recipient,\n                    remainingCollateralAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws the collateral from a loan to an address.\n     * @param loanID ID of loan from which collateral is to be paid out.\n     * @param amount Amount of collateral paid out.\n     * @param recipient Address of the recipient of the collateral.\n     */\n    function _withdrawCollateral(\n        uint256 loanID,\n        uint256 amount,\n        address payable recipient\n    ) internal {\n        // Update the contract total and the loan collateral total\n        _payOutCollateral(loanID, amount, recipient);\n\n        emit CollateralWithdrawn(\n            loanID,\n            loans[loanID].loanTerms.borrower,\n            recipient,\n            amount\n        );\n    }\n\n    /**\n     * @notice Pays out an amount of collateral for a loan.\n     * @param loanID ID of loan from which collateral is to be paid out.\n     * @param amount Amount of collateral paid out.\n     * @param recipient Address of the recipient of the collateral.\n     */\n    function _payOutCollateral(\n        uint256 loanID,\n        uint256 amount,\n        address payable recipient\n    ) internal {\n        totalCollateral = totalCollateral.sub(amount);\n        loans[loanID].collateral = loans[loanID].collateral.sub(amount);\n        recipient.transfer(amount);\n    }\n\n    /**\n     * @notice Pays collateral in for the associated loan\n     * @param loanID The ID of the loan the collateral is for\n     * @param amount The amount of collateral to be paid\n     */\n    function _payInCollateral(uint256 loanID, uint256 amount) internal {\n        require(msg.value == amount, \"INCORRECT_ETH_AMOUNT\");\n\n        totalCollateral = totalCollateral.add(amount);\n        loans[loanID].collateral = loans[loanID].collateral.add(amount);\n        loans[loanID].lastCollateralIn = block.timestamp;\n        emit CollateralDeposited(loanID, msg.sender, amount);\n    }\n\n    /**\n     * @notice It validates whether supply to debt (StD) ratio is valid including the loan amount.\n     * @param newLoanAmount the new loan amount to consider o the StD ratio.\n     * @return true if the ratio is valid. Otherwise it returns false.\n     */\n    function _isDebtRatioValid(uint256 newLoanAmount)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            lendingPool.getDebtRatioFor(newLoanAmount) <=\n            assetSettings.getMaxDebtRatio(lendingToken);\n    }\n\n    /**\n     * @notice Creates a loan with the loan request.\n     * @param request Loan request as per the struct of the Teller platform.\n     * @param interestRate Interest rate set in the loan terms.\n     * @param collateralRatio Collateral ratio set in the loan terms.\n     * @param maxLoanAmount Maximum loan amount that can be taken out, set in the loan terms.\n     */\n    function _createNewLoan(\n        TellerCommon.LoanRequest memory request,\n        uint256 interestRate,\n        uint256 collateralRatio,\n        uint256 maxLoanAmount\n    ) internal returns (uint256) {\n        // Get and increment new loan ID\n        uint256 loanID = loanIDCounter;\n        loanIDCounter = loanIDCounter.add(1);\n\n        require(\n            loans[loanID].status == TellerCommon.LoanStatus.NonExistent,\n            \"LOAN_ALREADY_EXISTS\"\n        );\n        require(request.borrower != address(0), \"BORROWER_EMPTY\");\n\n        loans[loanID].id = loanID;\n        loans[loanID].status = TellerCommon.LoanStatus.TermsSet;\n        loans[loanID].loanTerms = TellerCommon.LoanTerms({\n            borrower: request.borrower,\n            recipient: request.recipient,\n            interestRate: interestRate,\n            collateralRatio: collateralRatio,\n            maxLoanAmount: maxLoanAmount,\n            duration: request.duration\n        });\n\n        uint256 termsExpiryTime = settings.getTermsExpiryTimeValue();\n        loans[loanID].termsExpiry = block.timestamp.add(termsExpiryTime);\n\n        return loanID;\n    }\n\n    /**\n     * @notice It creates an Escrow contract instance for a given loan id.\n     * @param loanID loan id associated to the Escrow contract.\n     * @return escrow the new Escrow contract address.\n     */\n    function _createEscrow(uint256 loanID) internal returns (address escrow) {\n        require(\n            loans[loanID].escrow == address(0x0),\n            \"LOAN_ESCROW_ALREADY_EXISTS\"\n        );\n\n        escrow = _clone(initDynamicProxyLogic);\n        IInitializeableDynamicProxy(escrow).initialize(\n            address(logicRegistry),\n            keccak256(\"Escrow\"),\n            true\n        );\n        // The escrow must be added as an authorized address since it will be interacting with the protocol\n        // TODO: Remove after non-guarded launch\n        settings.addEscrowAuthorized(escrow);\n    }\n}\n"
    },
    "contracts/base/loans/LoanStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"../../util/TellerCommon.sol\";\nimport \"../../util/AddressArrayLib.sol\";\n\n// Interfaces\nimport \"../../interfaces/loans/ILoanStorage.sol\";\nimport \"../../interfaces/loans/ILoanTermsConsensus.sol\";\nimport \"../../interfaces/LendingPoolInterface.sol\";\nimport \"../../interfaces/AssetSettingsInterface.sol\";\n\n// Contracts\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                        THIS CONTRACT IS AN UPGRADEABLE STORAGE CONTRACT!                        **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of, PREPEND, or APPEND any storage variables to this or new versions   **/\n/**  of this contract as this will cause a ripple affect to the storage slots of all child          **/\n/**  contracts that inherit from this contract to be overwritten on the deployed proxy contract!!   **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract is used to storage the state variables for all of the LoanManager and LoanData contracts.\n *\n * @author develop@teller.finance.\n */\nabstract contract LoanStorage is ILoanStorage, ALoanStorage {\n    /* State Variables */\n\n    // Loan length will be inputted in seconds.\n    uint256 internal constant SECONDS_PER_YEAR = 31536000;\n\n    /**\n     * @notice Holds the total amount of collateral held by the contract.\n     */\n    uint256 public override totalCollateral;\n\n    /**\n     * @notice Holds the instance of the LendingPool used by the LoanManager.\n     */\n    LendingPoolInterface public override lendingPool;\n\n    /**\n     * @notice Holds the lending token used for creating loans by the LoanManager and LendingPool.\n     */\n    address public override lendingToken;\n\n    /**\n     * @notice Holds the collateral token.\n     */\n    address public override collateralToken;\n\n    /**\n     * @notice Holds the Compound cToken where the underlying token matches the lending token.\n     */\n    CErc20Interface public override cToken;\n\n    /**\n     * @dev Holds a list of all loans for a borrower address.\n     */\n    mapping(address => uint256[]) internal borrowerLoans;\n\n    /**\n     * @notice Holds the ID of loans taken out\n     * @dev Also the next available loan ID\n     */\n    uint256 public override loanIDCounter;\n\n    /**\n     * @dev Holds the list of authorizer signers for loans.\n     */\n    AddressArrayLib.AddressArray internal signers;\n\n    /**\n     * @dev It holds the address of a deployed InitializeableDynamicProxy contract.\n     * @dev It is used to deploy a new proxy contract with minimal gas cost using the logic in the Factory contract.\n     */\n    address internal initDynamicProxyLogic;\n\n    /**\n     * @dev Holds the address of the LoanData implementation.\n     */\n    address internal loanData;\n\n    /**\n     * @dev Holds the address of the LoanTermsConsensus implementation.\n     */\n    address internal loanTermsConsensus;\n\n    /**\n     * @notice Holds the logic name used for the LoanData contract.\n     * @dev Is used to check the LogicVersionsRegistry for a new LoanData implementation.\n     */\n    bytes32 public constant LOAN_DATA_LOGIC_NAME = keccak256(\"LoanData\");\n\n    /**\n     * @notice Holds the logic name used for the LoanTermsConsensus contract.\n     * @dev Is used to check the LogicVersionsRegistry for a new LoanTermsConsensus implementation.\n     */\n    bytes32 public constant LOAN_TERMS_CONSENSUS_LOGIC_NAME =\n        keccak256(\"LoanTermsConsensus\");\n\n    bool internal _notEntered;\n\n    /**\n     * @notice It holds the platform AssetSettings instance.\n     */\n    AssetSettingsInterface public assetSettings;\n}\n"
    },
    "contracts/base/proxies/DynamicProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"./BaseDynamicProxy.sol\";\n\n/**\n    @notice It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.\n    @notice It extends BaseUpgradeable to get access to the settings.\n\n    @author develop@teller.finance\n */\ncontract DynamicProxy is BaseDynamicProxy {\n    /**\n        @notice It creates a new dynamic proxy given a logic registry contract and a logic name.\n        @param logicRegistryAddress the settings contract address.\n        @param aLogicName the settings contract address.\n        @param isStrictDynamic Boolean indicating if the proxy must check the registry for a new implementation.\n     */\n    constructor(\n        address logicRegistryAddress,\n        bytes32 aLogicName,\n        bool isStrictDynamic\n    ) {\n        logicRegistry = LogicVersionsRegistryInterface(logicRegistryAddress);\n        logicName = aLogicName;\n        strictDynamic = isStrictDynamic;\n        _updateImplementationStored();\n    }\n}\n"
    },
    "contracts/interfaces/escrow/IEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"../../util/TellerCommon.sol\";\n\n// Interfaces\nimport \"../loans/ILoanManager.sol\";\nimport \"../loans/ILoanManager.sol\";\n\n/**\n * @notice This interface defines all function to allow borrowers interact with their escrow contracts.\n *\n * @author develop@teller.finance\n */\ninterface IEscrow {\n    /* External Functions */\n\n    /**\n     * @notice It calls a given dapp using a delegatecall function by a borrower owned the current loan id associated to this escrow contract.\n     * @param dappData the current dapp data to be executed.\n     */\n    function callDapp(TellerCommon.DappData calldata dappData) external;\n\n    /**\n     * @notice Calculate the value of the loan by getting the value of all tokens the Escrow owns.\n     * @return Escrow total value denoted in the lending token.\n     */\n    function calculateTotalValue() external view returns (uint256);\n\n    /**\n     * @notice Repay this Escrow's loan.\n     * @dev If the Escrow's balance of the borrowed token is less than the amount to repay, transfer tokens from the sender's wallet.\n     */\n    function repay(uint256 amount) external;\n\n    /**\n     * @notice Sends the tokens owned by this escrow to the recipient.\n     * @dev The loan must not be active.\n     * @dev The recipient must either be the loan borrower AND the loan must be already liquidated.\n     */\n    function claimTokens() external;\n\n    /**\n     * @notice Send the equivilant of tokens owned by this escrow (in collateral value) to the recipient,\n     * @dev The loan must not be active\n     * @dev The loan must be liquidated\n     * @dev The recipeient must be the loan manager contract\n     * @param recipient address to send the tokens to\n     * @param value The value of escrow held tokens, to be claimed based on collateral value\n     */\n    function claimTokensByCollateralValue(address recipient, uint256 value)\n        external;\n\n    /**\n     * @notice It initializes this escrow instance for a given loans address and loan id.\n     * @param settingsAddress The address of the settings contract.\n     * @param lendingPoolAddress e\n     * @param aLoanID the loan ID associated to this escrow instance.\n     * @param lendingTokenAddress The token that the Escrow loan will be for.\n     * @param borrowerAddress e\n     */\n    function initialize(\n        address settingsAddress,\n        address lendingPoolAddress,\n        uint256 aLoanID,\n        address lendingTokenAddress,\n        address borrowerAddress\n    ) external;\n\n    /**\n     * @notice Notifies when the Escrow's tokens have been claimed.\n     * @param recipient address where the tokens where sent to.\n     */\n    event TokensClaimed(address recipient);\n}\n"
    },
    "contracts/mocks/LoanManagerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../base/loans/LoanManager.sol\";\n\ncontract LoanManagerMock is LoanManager {\n    fallback() external payable {}\n}\n"
    },
    "contracts/base/proxies/SettingsDynamicProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"./BaseDynamicProxy.sol\";\nimport \"../LogicVersionsRegistry.sol\";\n\n/**\n    @notice It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.\n    @notice It extends BaseUpgradeable to get access to the settings.\n\n    @author develop@teller.finance\n */\ncontract SettingsDynamicProxy is BaseDynamicProxy {\n    /**\n        @notice It creates the LogicVersionsRegistry that will be used for the platform and create initial logic versions.\n        @param initialLogicVersions list of the logic versions to create.\n     */\n    constructor(\n        TellerCommon.CreateLogicVersionRequest[] memory initialLogicVersions\n    ) {\n        logicRegistry = new LogicVersionsRegistry();\n        logicRegistry.initialize(msg.sender, initialLogicVersions);\n\n        logicName = keccak256(\"Settings\");\n        strictDynamic = false;\n        _updateImplementationStored();\n    }\n}\n"
    },
    "contracts/base/loans/LoanTermsConsensus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../../util/ECDSALib.sol\";\n\n// Interfaces\nimport \"../../interfaces/loans/ILoanData.sol\";\nimport \"../../interfaces/loans/ILoanTermsConsensus.sol\";\nimport \"../../interfaces/SettingsInterface.sol\";\nimport \"../../interfaces/escrow/IEscrow.sol\";\nimport \"../../interfaces/loans/ILoanManager.sol\";\n\n// Contracts\nimport \"../Base.sol\";\nimport \"../BaseStorage.sol\";\nimport \"./LoanStorage.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\n/**  contract that this contract inherits from                                                      **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract stores the logic for validating consensus on loan terms.\n * @dev The LoanManager delegatecall's to this, like a Diamond.\n *\n * @author develop@teller.finance.\n */\ncontract LoanTermsConsensus is ILoanTermsConsensus, Base, LoanStorage {\n    using SafeMath for uint256;\n    using NumbersList for NumbersList.Values;\n    using NumbersLib for uint256;\n    using Address for address;\n    using AddressArrayLib for AddressArrayLib.AddressArray;\n\n    /* Modifiers */\n\n    /**\n     * @notice Checks if sender has a pauser role\n     * @dev Throws an error if the sender has not a pauser role.\n     */\n    modifier onlyPauser() override {\n        settings.requirePauserRole(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Checks if the number of responses is greater or equal to a percentage of the number of signers.\n     */\n    modifier onlyEnoughSubmissions(uint256 responseCount) {\n        uint256 percentageRequired =\n            settings.getRequiredSubmissionsPercentageValue();\n\n        require(\n            responseCount.ratioOf(signers.array.length) >= percentageRequired,\n            \"INSUFFICIENT_NUMBER_OF_RESPONSES\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Processes the loan request\n     * @param request Struct of the protocol loan request\n     * @param responses List of structs of the protocol loan responses\n     * @return interestRate Interest rate\n     * @return collateralRatio Collateral ratio\n     * @return maxLoanAmount Maximum loan amount\n     */\n    function processLoanTerms(\n        TellerCommon.LoanRequest calldata request,\n        TellerCommon.LoanResponse[] calldata responses\n    )\n        external\n        view\n        override\n        onlyEnoughSubmissions(responses.length)\n        returns (\n            uint256 interestRate,\n            uint256 collateralRatio,\n            uint256 maxLoanAmount\n        )\n    {\n        // NOTE: nonReentrant doesn't work across facets unless we use\n        // diamond storage.\n        // WE CANNOT MAKE NON-STATIC EXTERNAL CALLS OR THE BORROWER\n        // COULD MANIPULATE THE NONCE\n        address borrower = request.borrower;\n\n        _validateLoanRequest(borrower, request.requestNonce);\n\n        require(\n            request.consensusAddress == address(this),\n            \"BAD_CONSENSUS_ADDRESS\"\n        );\n\n        uint256 chainId = _getChainId();\n\n        bytes32 requestHash = _hashRequest(request, chainId);\n\n        uint256 responseExpiryLengthValue =\n            settings.getResponseExpiryLengthValue();\n\n        TellerCommon.AccruedLoanTerms memory termSubmissions;\n\n        for (uint256 i = 0; i < responses.length; i++) {\n            TellerCommon.LoanResponse memory response = responses[i];\n\n            require(_isSigner(response.signer), \"NOT_SIGNER\");\n\n            require(\n                response.consensusAddress == request.consensusAddress,\n                \"CONSENSUS_ADDRESS_MISMATCH\"\n            );\n\n            /**\n                Check if we've encountered this signer for this request already.\n                Not the cleanest solution to a dictionary lookup problem, but\n                that doesn't exist in EVM memory and this is relatively cheap\n                for a rather large number of signers.\n                Rough gas cost: (n/2) * (1 + n) * MLOAD + n * MSTORE.\n             */\n            for (uint8 j = 0; j < i; j++) {\n                require(\n                    response.signer != responses[j].signer,\n                    \"SIGNER_ALREADY_SUBMITTED\"\n                );\n            }\n\n            require(\n                response.responseTime >=\n                    block.timestamp.sub(responseExpiryLengthValue),\n                \"RESPONSE_EXPIRED\"\n            );\n\n            bytes32 responseHash =\n                _hashResponse(response, requestHash, chainId);\n\n            require(\n                _signatureValid(\n                    response.signature,\n                    responseHash,\n                    response.signer\n                ),\n                \"SIGNATURE_INVALID\"\n            );\n\n            termSubmissions.interestRate.addValue(response.interestRate);\n            termSubmissions.collateralRatio.addValue(response.collateralRatio);\n            termSubmissions.maxLoanAmount.addValue(response.maxLoanAmount);\n        }\n\n        uint256 tolerance = settings.getMaximumToleranceValue();\n        interestRate = _getConsensus(termSubmissions.interestRate, tolerance);\n        collateralRatio = _getConsensus(\n            termSubmissions.collateralRatio,\n            tolerance\n        );\n        maxLoanAmount = _getConsensus(termSubmissions.maxLoanAmount, tolerance);\n    }\n\n    /**\n     * @notice It adds a new account as a signer.\n     * @param account address to add.\n     * @dev The sender must be the owner.\n     * @dev It throws a require error if the sender is not the owner.\n     */\n    function addSigner(address account) external onlyPauser {\n        _addSigner(account);\n    }\n\n    /**\n     * @notice It adds a list of account as signers.\n     * @param accounts addresses to add.\n     * @dev The sender must be the owner.\n     * @dev It throws a require error if the sender is not the owner.\n     */\n    function addSigners(address[] calldata accounts) external onlyPauser {\n        for (uint256 index = 0; index < accounts.length; index++) {\n            address account = accounts[index];\n            _addSigner(account);\n        }\n    }\n\n    /**\n     * @notice It removes an account as a signer.\n     * @param account address to remove.\n     * @dev The sender must be the owner.\n     */\n    function removeSigner(address account) external onlyPauser {\n        _removeSigner(account);\n    }\n\n    /**\n     * @notice Generates a hash for the loan response\n     * @param response Structs of the protocol loan responses\n     * @param requestHash Hash of the loan request\n     * @return bytes32 Hash of the loan response\n     */\n    function _hashResponse(\n        TellerCommon.LoanResponse memory response,\n        bytes32 requestHash,\n        uint256 chainId\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    response.consensusAddress,\n                    response.responseTime,\n                    response.interestRate,\n                    response.collateralRatio,\n                    response.maxLoanAmount,\n                    chainId,\n                    requestHash\n                )\n            );\n    }\n\n    /**\n     * @notice Generates a hash for the loan request\n     * @param request Struct of the protocol loan request\n     * @return bytes32 Hash of the loan request\n     */\n    function _hashRequest(\n        TellerCommon.LoanRequest memory request,\n        uint256 chainId\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    request.borrower,\n                    request.recipient,\n                    request.consensusAddress,\n                    request.requestNonce,\n                    request.amount,\n                    request.duration,\n                    request.requestTime,\n                    chainId\n                )\n            );\n    }\n\n    /**\n     * @notice It validates whether a signature is valid or not.\n     * @param signature signature to validate.\n     * @param dataHash used to recover the signer.\n     * @param expectedSigner the expected signer address.\n     * @return true if the expected signer is equal to the signer. Otherwise it returns false.\n     */\n    function _signatureValid(\n        TellerCommon.Signature memory signature,\n        bytes32 dataHash,\n        address expectedSigner\n    ) internal pure returns (bool) {\n        return\n            expectedSigner ==\n            ECDSA.recover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19Ethereum Signed Message:\\n32\",\n                        dataHash\n                    )\n                ),\n                signature.v,\n                signature.r,\n                signature.s\n            );\n    }\n\n    /**\n        Checks if the nonce provided in the request is equal to the borrower's number of loans.\n        Also verifies if the borrower has taken out a loan recently (rate limit).\n     * @param borrower the borrower's address.\n     * @param nonce the nonce included in the loan request.\n     */\n    function _validateLoanRequest(address borrower, uint256 nonce)\n        internal\n        view\n    {\n        uint256[] storage _borrowerLoans = borrowerLoans[borrower];\n        uint256 numberOfLoans = _borrowerLoans.length;\n\n        require(nonce == numberOfLoans, \"BAD_NONCE\");\n\n        // In case it is the first time that borrower requests loan terms, we don't\n        // validate the rate limit.\n        if (numberOfLoans == 0) {\n            return;\n        }\n\n        require(\n            loans[_borrowerLoans[numberOfLoans - 1]].loanStartTime.add(\n                settings.getRequestLoanTermsRateLimitValue()\n            ) <= block.timestamp,\n            \"REQS_LOAN_TERMS_LMT_EXCEEDS_MAX\"\n        );\n    }\n\n    function _isSigner(address account) internal view returns (bool isSigner_) {\n        (isSigner_, ) = signers.getIndex(account);\n    }\n\n    /**\n     * @notice Gets the consensus value for a list of values (uint values).\n     * @notice The values must be in a maximum tolerance range.\n     * @return the consensus value.\n     */\n    function _getConsensus(NumbersList.Values memory values, uint256 tolerance)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(values.isWithinTolerance(tolerance), \"RESPONSES_TOO_VARIED\");\n\n        return values.getAverage();\n    }\n\n    /**\n     * @notice Gets the current chain id using the opcode 'chainid()'.\n     * @return the current chain id.\n     */\n    function _getChainId() internal view returns (uint256) {\n        // silence state mutability warning without generating bytecode.\n        // see https://github.com/ethereum/solidity/issues/2691\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    function _addSigner(address account) internal {\n        if (!_isSigner(account)) {\n            signers.add(account);\n        }\n    }\n\n    function _removeSigner(address account) internal {\n        signers.remove(account);\n    }\n}\n"
    },
    "contracts/util/ECDSALib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * Copied from @openzeppelin/contracts/cryptography/ECDSA.sol\n * Due to the fact that the 0.5.x versions of the OZ contract do not accept v, r, and s separately\n *\n */\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <=\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ECDSA: invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n}\n"
    },
    "contracts/base/TToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// Utils\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n// Interfaces\nimport \"../interfaces/ITToken.sol\";\nimport \"../interfaces/LendingPoolInterface.sol\";\n\n// Contracts\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"./upgradeable/DynamicUpgradeable.sol\";\n\n/**\n * @notice This contract represents a wrapped token within the Teller protocol\n *\n * @author develop@teller.finance\n */\ncontract TToken is ITToken, DynamicUpgradeable, ERC20Upgradeable {\n    using Address for address;\n\n    /* State Variables */\n\n    // The LendingPool linked to this Teller Token.\n    LendingPoolInterface private _lendingPool;\n\n    // The underlying asset for this Teller Token.\n    ERC20 private _underlying;\n\n    /* Modifiers */\n\n    modifier onlyLendingPool() {\n        require(\n            msg.sender == address(_lendingPool),\n            \"Teller: must be lending pool\"\n        );\n        _;\n    }\n\n    /* Public Functions */\n\n    function decimals() public view override returns (uint8) {\n        return _underlying.decimals();\n    }\n\n    function lendingPool()\n        external\n        view\n        override\n        returns (LendingPoolInterface)\n    {\n        return _lendingPool;\n    }\n\n    function underlying() external view override returns (ERC20) {\n        return _underlying;\n    }\n\n    function mint(address account, uint256 amount)\n        external\n        override\n        onlyLendingPool\n    {\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice Reduce account supply of specified token amount\n     * @param account The account to burn tokens from\n     * @param amount The amount of tokens to burn\n     */\n    function burn(address account, uint256 amount)\n        external\n        override\n        onlyLendingPool\n    {\n        _burn(account, amount);\n    }\n\n    /**\n     * @param lendingPoolAddress the address of the lending pool this token is linked to. It is only used to add it as a minter.\n     */\n    function initialize(address lendingPoolAddress) external override {\n        require(\n            lendingPoolAddress.isContract(),\n            \"Teller: lending pool not contract\"\n        );\n        _lendingPool = LendingPoolInterface(lendingPoolAddress);\n        _underlying = _lendingPool.lendingToken();\n\n        __ERC20_init(\n            string(abi.encodePacked(\"Teller \", _underlying.name())),\n            string(abi.encodePacked(\"t\", _underlying.symbol()))\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overloaded;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/base/loans/LoanData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\n// Interfaces\nimport \"../../interfaces/loans/ILoanData.sol\";\nimport \"../../interfaces/SettingsInterface.sol\";\nimport \"../../interfaces/escrow/IEscrow.sol\";\nimport \"../../interfaces/loans/ILoanManager.sol\";\n\n// Contracts\nimport \"../Base.sol\";\nimport \"./LoanStorage.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\n/**  contract that this contract inherits from                                                      **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract stores the logic for calculating loan information.\n * @dev It is used by the LoanManager contract to delegatecall from.\n *\n * @author develop@teller.finance.\n */\ncontract LoanData is ILoanData, Base, LoanStorage {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using NumbersLib for uint256;\n    using NumbersLib for int256;\n\n    /**\n     * @notice Checks whether the status of a loan is Active or has Terms Set\n     * @param loanID The loan ID for which to check the status\n     * @return bool value indicating if the loan is active or has terms set\n     */\n    function isActiveOrSet(uint256 loanID) public view override returns (bool) {\n        return\n            loans[loanID].status == TellerCommon.LoanStatus.Active ||\n            loans[loanID].status == TellerCommon.LoanStatus.TermsSet;\n    }\n\n    /**\n     * @notice Checks whether a loan is allowed to be deposited to an Externally Owned Account.\n     * @param loanID The loan ID to check the collateral ratio for.\n     * @return bool indicating whether the loan with specified parameters can be deposited to an EOA.\n     */\n    function canGoToEOA(uint256 loanID) public view override returns (bool) {\n        uint256 overCollateralizedBuffer =\n            settings.getOverCollateralizedBufferValue();\n        return\n            loans[loanID].loanTerms.collateralRatio >= overCollateralizedBuffer;\n    }\n\n    /**\n     * @notice Checks whether the loan's collateral ratio is considered to be secured based on the settings collateral buffer value.\n     * @param loanID The loan ID to check.\n     * @return bool value of it being secured or not.\n     */\n    function isLoanSecured(uint256 loanID) public view override returns (bool) {\n        return\n            loans[loanID].loanTerms.collateralRatio >=\n            settings.getCollateralBufferValue();\n    }\n\n    /**\n     * @notice Returns the total amount owed for a specified loan.\n     * @param loanID The loan ID to get the total amount owed.\n     * @return uint256 The total owed amount.\n     */\n    function getTotalOwed(uint256 loanID)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (loans[loanID].status == TellerCommon.LoanStatus.TermsSet) {\n            uint256 interestOwed =\n                getInterestOwedFor(\n                    loanID,\n                    loans[loanID].loanTerms.maxLoanAmount\n                );\n            return loans[loanID].loanTerms.maxLoanAmount.add(interestOwed);\n        } else if (loans[loanID].status == TellerCommon.LoanStatus.Active) {\n            return loans[loanID].principalOwed.add(loans[loanID].interestOwed);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Returns the total amount owed for a specified loan.\n     * @param loanID The loan ID to get the total amount owed.\n     * @return uint256 The amount owed.\n     */\n    function getLoanAmount(uint256 loanID)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (loans[loanID].status == TellerCommon.LoanStatus.TermsSet) {\n            return loans[loanID].loanTerms.maxLoanAmount;\n        } else if (loans[loanID].status == TellerCommon.LoanStatus.Active) {\n            return loans[loanID].borrowedAmount;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Returns the amount of interest owed for a given loan and loan amount.\n     * @param loanID The loan ID to get the owed interest.\n     * @param amountBorrow The principal of the loan to take out.\n     * @return uint256 The interest owed.\n     */\n    function getInterestOwedFor(uint256 loanID, uint256 amountBorrow)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return amountBorrow.percent(getInterestRatio(loanID));\n    }\n\n    /**\n     * @notice Returns the interest ratio based on the loan interest rate for the loan duration.\n     * @dev The interest rate on the loan terms is APY.\n     * @param loanID The loan ID to get the interest rate for.\n     */\n    function getInterestRatio(uint256 loanID)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            loans[loanID]\n                .loanTerms\n                .interestRate\n                .mul(loans[loanID].loanTerms.duration)\n                .div(SECONDS_PER_YEAR);\n    }\n\n    /**\n     * @notice Returns the collateral needed for a loan, in the lending token, needed to take out the loan or for it be liquidated.\n     * @param loanID The loan ID for which to get collateral information for\n     * @return uint256 Collateral needed in lending token value\n     */\n    function getCollateralInLendingTokens(uint256 loanID)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (!isActiveOrSet(loanID)) {\n            return 0;\n        }\n        return\n            settings.priceAggregator().valueFor(\n                collateralToken,\n                lendingToken,\n                loans[loanID].collateral\n            );\n    }\n\n    /**\n     * @notice Get information on the collateral needed for the loan.\n     * @param loanID The loan ID to get collateral info for.\n     * @return neededInLendingTokens int256 Collateral needed in Lending tokens.\n     * @return neededInCollateralTokens int256 Collateral needed in Collateral tokens (wei)\n     * @return escrowLoanValue uint256 The value of the loan held in the escrow contract\n     */\n    function getCollateralNeededInfo(uint256 loanID)\n        public\n        view\n        override\n        returns (\n            int256 neededInLendingTokens,\n            int256 neededInCollateralTokens,\n            uint256 escrowLoanValue\n        )\n    {\n        // Get collateral needed in lending tokens.\n        (neededInLendingTokens, escrowLoanValue) = getCollateralNeededInTokens(\n            loanID\n        );\n\n        if (neededInLendingTokens == 0) {\n            neededInCollateralTokens = 0;\n        } else {\n            uint256 value =\n                settings.priceAggregator().valueFor(\n                    lendingToken,\n                    collateralToken,\n                    uint256(\n                        neededInLendingTokens < 0\n                            ? -neededInLendingTokens\n                            : neededInLendingTokens\n                    )\n                );\n            neededInCollateralTokens = int256(value);\n            if (neededInLendingTokens < 0) {\n                neededInCollateralTokens = neededInCollateralTokens.mul(-1);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the minimum collateral value threshold, in the lending token, needed to take out the loan or for it be liquidated.\n     * @dev If the loan status is TermsSet, then the value is whats needed to take out the loan.\n     * @dev If the loan status is Active, then the value is the threshold at which the loan can be liquidated at.\n     * @param loanID The loan ID to get needed collateral info for.\n     * @return neededInLendingTokens int256 The minimum collateral value threshold required.\n     * @return escrowLoanValue uint256 The value of the loan held in the escrow contract.\n     */\n    function getCollateralNeededInTokens(uint256 loanID)\n        public\n        view\n        override\n        returns (int256 neededInLendingTokens, uint256 escrowLoanValue)\n    {\n        if (\n            !isActiveOrSet(loanID) ||\n            loans[loanID].loanTerms.collateralRatio == 0\n        ) {\n            return (0, 0);\n        }\n\n        /*\n            The collateral to principal owed ratio is the sum of:\n                * collateral buffer percent\n                * loan interest rate\n                * liquidation reward percent\n                * X factor of additional collateral\n        */\n        // * To take out a loan (if status == TermsSet), the required collateral is (max loan amount * the collateral ratio).\n        // * For the loan to not be liquidated (when status == Active), the minimum collateral is (principal owed * (X collateral factor + liquidation reward)).\n        // * If the loan has an escrow account, the minimum collateral is ((principal owed - escrow value) * (X collateral factor + liquidation reward)).\n        if (loans[loanID].status == TellerCommon.LoanStatus.TermsSet) {\n            neededInLendingTokens = int256(getLoanAmount(loanID)).percent(\n                loans[loanID].loanTerms.collateralRatio\n            );\n        } else {\n            neededInLendingTokens = int256(loans[loanID].principalOwed);\n            uint256 bufferPercent = settings.getCollateralBufferValue();\n            uint256 requiredRatio =\n                loans[loanID]\n                    .loanTerms\n                    .collateralRatio\n                    .sub(getInterestRatio(loanID))\n                    .sub(bufferPercent);\n            if (loans[loanID].escrow != address(0)) {\n                escrowLoanValue = IEscrow(loans[loanID].escrow)\n                    .calculateTotalValue();\n                neededInLendingTokens = neededInLendingTokens.add(\n                    neededInLendingTokens.sub(int256(escrowLoanValue))\n                );\n            }\n            neededInLendingTokens = neededInLendingTokens\n                .add(int256(loans[loanID].interestOwed))\n                .percent(requiredRatio);\n        }\n    }\n\n    /**\n     * @notice It checks if a loan can be liquidated.\n     * @param loanID The loan ID to check.\n     * @return true if the loan is liquidable.\n     */\n    function isLiquidable(uint256 loanID) public view override returns (bool) {\n        // Check if loan can be liquidated\n        if (loans[loanID].status != TellerCommon.LoanStatus.Active) {\n            return false;\n        }\n\n        if (loans[loanID].loanTerms.collateralRatio > 0) {\n            // If loan has a collateral ratio, check how much is needed\n            (, int256 neededInCollateral, ) = getCollateralNeededInfo(loanID);\n            return neededInCollateral > int256(loans[loanID].collateral);\n        } else {\n            // Otherwise, check if the loan has expired\n            return\n                block.timestamp >=\n                loans[loanID].loanStartTime.add(\n                    loans[loanID].loanTerms.duration\n                );\n        }\n    }\n\n    /**\n     * @notice It gets the current liquidation reward for a given loan.\n     * @param loanID The loan ID to get the info.\n     * @return The value the liquidator will receive denoted in collateral tokens.\n     */\n    function getLiquidationReward(uint256 loanID)\n        public\n        view\n        override\n        returns (int256)\n    {\n        uint256 amountToLiquidate = getTotalOwed(loanID);\n        uint256 availableValue =\n            getCollateralInLendingTokens(loanID).add(\n                IEscrow(loans[loanID].escrow).calculateTotalValue()\n            );\n        uint256 maxReward =\n            amountToLiquidate.percent(\n                settings.getLiquidateEthPriceValue().diffOneHundredPercent()\n            );\n        if (availableValue < amountToLiquidate + maxReward) {\n            return int256(availableValue);\n        } else {\n            return int256(maxReward).add(int256(amountToLiquidate));\n        }\n    }\n}\n"
    },
    "contracts/base/escrow/Escrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"./BaseEscrowDapp.sol\";\n\n// Interfaces\nimport \"../../interfaces/escrow/IEscrow.sol\";\nimport \"../../interfaces/IBaseProxy.sol\";\nimport \"../../providers/compound/CErc20Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../util/TellerCommon.sol\";\nimport \"../../util/NumbersLib.sol\";\nimport \"../../interfaces/loans/ILoans.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract is used by borrowers to call Dapp functions (using delegate calls).\n * @notice This contract should only be constructed using it's upgradeable Proxy contract.\n * @notice In order to call a Dapp function, the Dapp must be added in the DappRegistry instance.\n *\n * @author develop@teller.finance\n */\ncontract Escrow is IEscrow, Base, BaseEscrowDapp {\n    using SafeMath for uint256;\n    using NumbersLib for uint256;\n    using SafeERC20 for IERC20;\n    using AddressArrayLib for AddressArrayLib.AddressArray;\n\n    /** External Functions **/\n\n    /**\n     * @notice It calls a given dapp using a delegatecall function by a borrower owned the current loan id associated to this escrow contract.\n     * @param dappData the current dapp data to be executed.\n     */\n    function callDapp(TellerCommon.DappData calldata dappData)\n        external\n        override\n        updateImpIfNeeded\n        onlyBorrower\n        whenNotPaused\n    {\n        TellerCommon.Dapp memory dapp =\n            settings.dappRegistry().dapps(dappData.location);\n        require(dapp.exists, \"DAPP_NOT_WHITELISTED\");\n        require(\n            dapp.unsecured || loanManager.isLoanSecured(loanID),\n            \"DAPP_UNSECURED_NOT_ALLOWED\"\n        );\n\n        address _impl = IBaseProxy(dappData.location).implementation();\n        (bool success, ) = _impl.delegatecall(dappData.data);\n\n        if (!success) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate the value of the loan by getting the value of all tokens the Escrow owns.\n     * @return Escrow total value denoted in the lending token.\n     */\n    function calculateTotalValue() public view override returns (uint256) {\n        uint256 valueInEth;\n        address[] memory tokens = getTokens();\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (tokens[i] == settings.WETH_ADDRESS()) {\n                valueInEth = valueInEth.add(_balanceOf(tokens[i]));\n            } else {\n                valueInEth = valueInEth.add(\n                    _valueOfIn(\n                        tokens[i],\n                        settings.ETH_ADDRESS(),\n                        _balanceOf(tokens[i])\n                    )\n                );\n            }\n        }\n\n        return _valueOfIn(settings.ETH_ADDRESS(), lendingToken, valueInEth);\n    }\n\n    /**\n     * @notice Repay this Escrow's loan.\n     * @dev If the Escrow's balance of the borrowed token is less than the amount to repay, transfer tokens from the sender's wallet.\n     * @dev Only the owner of the Escrow can call this. If someone else wants to make a payment, they should call the loan manager directly.\n     */\n    function repay(uint256 amount)\n        external\n        override\n        updateImpIfNeeded\n        onlyBorrower\n        whenNotPaused\n    {\n        IERC20 token = IERC20(lendingToken);\n        uint256 balance = _balanceOf(address(token));\n        uint256 totalOwed = loanManager.getTotalOwed(loanID);\n        if (balance < totalOwed && amount > balance) {\n            uint256 amountNeeded =\n                amount > totalOwed\n                    ? totalOwed.sub(balance)\n                    : amount.sub(balance);\n\n            token.safeTransferFrom(msg.sender, address(this), amountNeeded);\n        }\n        token.safeApprove(lendingPool, amount);\n\n        loanManager.repay(amount, loanID);\n    }\n\n    /**\n     * @notice Sends the tokens owned by this escrow to the owner.\n     * @dev The loan must not be active.\n     * @dev The recipient must be the loan borrower AND the loan must be already liquidated.\n     */\n    function claimTokens()\n        external\n        override\n        updateImpIfNeeded\n        onlyBorrower\n        whenNotPaused\n    {\n        require(\n            loanManager.status(loanID) == TellerCommon.LoanStatus.Closed,\n            \"LOAN_NOT_CLOSED\"\n        );\n\n        address[] memory tokens = getTokens();\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 balance = _balanceOf(tokens[i]);\n            if (balance > 0) {\n                IERC20(tokens[i]).safeTransfer(msg.sender, balance);\n            }\n        }\n\n        emit TokensClaimed(msg.sender);\n    }\n\n    /**\n     * @notice Send the equivilant of tokens owned by this escrow (in collateral value) to the recipient,\n     * @dev The loan must not be active\n     * @dev The loan must be liquidated\n     * @dev The recipeient must be the loan manager\n     * @param recipient address to send the tokens to\n     * @param value The value of escrow held tokens, to be claimed based on collateral value\n     */\n    function claimTokensByCollateralValue(address recipient, uint256 value)\n        external\n        override\n        updateImpIfNeeded\n        whenNotPaused\n    {\n        require(\n            loanManager.status(loanID) == TellerCommon.LoanStatus.Closed,\n            \"LOAN_NOT_CLOSED\"\n        );\n        require(loanManager.liquidated(loanID), \"LOAN_NOT_LIQUIDATED\");\n        require(msg.sender == address(loanManager), \"CALLER_MUST_BE_LOANS\");\n\n        address[] memory tokens = getTokens();\n        uint256 valueLeftToTransfer = value;\n        // cycle through tokens\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (valueLeftToTransfer == 0) {\n                break;\n            }\n\n            uint256 balance = _balanceOf(tokens[i]);\n            // get value of token balance in collateral value\n            if (balance > 0) {\n                uint256 valueInCollateralToken =\n                    (tokens[i] == loanManager.collateralToken())\n                        ? balance\n                        : _valueOfIn(\n                            tokens[i],\n                            loanManager.collateralToken(),\n                            balance\n                        );\n                // if <= value, transfer tokens\n                if (valueInCollateralToken <= valueLeftToTransfer) {\n                    IERC20(tokens[i]).safeTransfer(\n                        recipient,\n                        valueInCollateralToken\n                    );\n                    valueLeftToTransfer = valueLeftToTransfer.sub(\n                        valueInCollateralToken\n                    );\n                } else {\n                    IERC20(tokens[i]).safeTransfer(\n                        recipient,\n                        valueLeftToTransfer\n                    );\n                    valueLeftToTransfer = 0;\n                }\n                _tokenUpdated(tokens[i]);\n            }\n        }\n        emit TokensClaimed(recipient);\n    }\n\n    /**\n     * @notice It initializes this escrow instance for a given loan manager address and loan id.\n     * @param settingsAddress The address of the settings contract.\n     * @param lendingPoolAddress e\n     * @param aLoanID the loan ID associated to this escrow instance.\n     * @param lendingTokenAddress The token that the Escrow loan will be for.\n     * @param borrowerAddress e\n     */\n    function initialize(\n        address settingsAddress,\n        address lendingPoolAddress,\n        uint256 aLoanID,\n        address lendingTokenAddress,\n        address borrowerAddress\n    ) external override {\n        Base._initialize(settingsAddress);\n\n        loanManager = ILoans(msg.sender);\n        lendingPool = lendingPoolAddress;\n        loanID = aLoanID;\n        lendingToken = lendingTokenAddress;\n        borrower = borrowerAddress;\n\n        // Initialize tokens list with the borrowed token.\n        tokens.add(lendingTokenAddress);\n    }\n\n    /** Internal Functions */\n\n    /**\n     * @notice Calculate a value of a token amount.\n     * @param baseAddress base token address.\n     * @param quoteAddress quote token address.\n     * @param baseAmount amount of base token.\n     * @return Value of baseAmount in quote token.\n     */\n    function _valueOfIn(\n        address baseAddress,\n        address quoteAddress,\n        uint256 baseAmount\n    ) internal view returns (uint256) {\n        bool success;\n        bytes memory returnData;\n        // call function to base address for function signature of underlying\n        (success, returnData) = baseAddress.staticcall(\n            abi.encodeWithSignature(\"exchangeRateStored()\")\n        );\n        require(success, \"EXCHANGE_RATE_CALL_FAIL\");\n        if (returnData.length > 0) {\n            uint8 cTokenDecimals = CErc20Interface(baseAddress).decimals();\n            uint256 exchangeRate = abi.decode(returnData, (uint256));\n            uint256 diffFactor =\n                uint256(10)**uint256(18).diff(uint256(cTokenDecimals));\n\n            if (cTokenDecimals > uint256(18)) {\n                exchangeRate = exchangeRate.mul(diffFactor);\n            } else {\n                exchangeRate = exchangeRate.div(diffFactor);\n            }\n\n            uint8 assetDecimals;\n            if (baseAddress == settings.CETH_ADDRESS()) {\n                baseAddress = settings.ETH_ADDRESS();\n                assetDecimals = uint8(18);\n            } else {\n                baseAddress = CErc20Interface(baseAddress).underlying();\n                assetDecimals = ERC20(baseAddress).decimals();\n            }\n\n            baseAmount = baseAmount.mul(exchangeRate).div(\n                uint256(10)**assetDecimals\n            );\n        }\n        return\n            settings.priceAggregator().valueFor(\n                baseAddress,\n                quoteAddress,\n                baseAmount\n            );\n    }\n}\n"
    },
    "contracts/base/escrow/BaseEscrowDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"../Base.sol\";\nimport \"../escrow/EscrowStorage.sol\";\n\n// Interfaces\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/escrow/IBaseEscrowDapp.sol\";\nimport \"../../interfaces/loans/ILoanManager.sol\";\n\n// Libraries\nimport \"../../util/AddressArrayLib.sol\";\n\n/**\n * @notice This contract defines functionality for all Dapp contracts MUST inherit.\n * @dev If any token balances are modified during a function call, you MUST call _tokenUpdate with the token address.\n *\n * @author develop@teller.finance\n */\ncontract BaseEscrowDapp is IBaseEscrowDapp, Base, EscrowStorage {\n    using Address for address;\n    using AddressArrayLib for AddressArrayLib.AddressArray;\n\n    /* Modifiers */\n\n    modifier onlyBorrower() {\n        require(msg.sender == borrower, \"NOT_BORROWER\");\n        _;\n    }\n\n    /* Public Functions */\n\n    /**\n     * @notice Returns an array of token addresses, for which this Escrow contract has a balance.\n     * @return The list of all tokens held by this contract.\n     */\n    function getTokens() public view override returns (address[] memory) {\n        return tokens.array;\n    }\n\n    /* Internal Functions */\n\n    /**\n     * @notice Returns this contract's balance for the specified token.\n     * @param tokenAddress token address.\n     * @return The token balance of the tokenAddress held by this Escrow contract.\n     */\n    function _balanceOf(address tokenAddress) internal view returns (uint256) {\n        return IERC20(tokenAddress).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Adds or removes tokens held by the Escrow contract\n     * @param tokenAddress The token address to be added or removed\n     */\n    function _tokenUpdated(address tokenAddress) internal {\n        (bool found, uint256 index) = tokens.getIndex(tokenAddress);\n        if (_balanceOf(tokenAddress) > 0) {\n            if (!found) {\n                tokens.add(tokenAddress);\n                emit TokenAdded(tokenAddress, index);\n            }\n        } else if (found) {\n            tokens.remove(index);\n            emit TokenRemoved(tokenAddress, index);\n        }\n    }\n}\n"
    },
    "contracts/base/escrow/EscrowStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport \"../../util/AddressArrayLib.sol\";\n\n// Interfaces\nimport \"../../interfaces/loans/ILoans.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                        THIS CONTRACT IS AN UPGRADEABLE STORAGE CONTRACT!                        **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions            **/\n/**  of this contract as this will cause a ripple affect to the storage slots of all child          **/\n/**  contracts that inherit from this contract to be overwritten on the deployed proxy contract!!   **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n * @notice This contract is used by borrowers to call Dapp functions (using delegate calls).\n * @notice This contract should only be constructed using it's upgradeable Proxy contract.\n * @notice In order to call a Dapp function, the Dapp must be added in the DappRegistry instance.\n *\n * @author develop@teller.finance\n */\ncontract EscrowStorage {\n    /* State Variables */\n\n    /**\n        @notice Holds the instance of the associated LoanManager contract for this Escrow loan.\n     */\n    ILoans public loanManager;\n\n    /**\n     * @notice Holds the address of the LendingPool used for this Escrow loan.\n     */\n    address public lendingPool;\n\n    /**\n     * @notice Holds the loan ID of the loan for this Escrow in the LoansManager contract.\n     */\n    uint256 public loanID;\n\n    /**\n     * @notice Holds the token that this Escrow loan was taken out with.\n     */\n    address public lendingToken;\n\n    /**\n     * @notice Holds the borrower's address that owns this Escrow loan.\n     */\n    address public borrower;\n\n    // An array of tokens that are owned by this escrow.\n    AddressArrayLib.AddressArray internal tokens;\n}\n"
    },
    "contracts/interfaces/escrow/IBaseEscrowDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBaseEscrowDapp {\n    /* Public Functions */\n\n    /**\n     * @notice Returns an array of token addresses, for which this Escrow contract has a balance.\n     * @return The list of all tokens held by this contract.\n     */\n    function getTokens() external view returns (address[] memory);\n\n    /* Events */\n\n    /**\n     * @notice This event is emitted when a new token is added to this Escrow.\n     * @param tokenAddress address of the new token.\n     * @param index Index of the added token.\n     */\n    event TokenAdded(address tokenAddress, uint256 index);\n\n    /**\n     * @notice This event is emitted when a new token is removed from this Escrow.\n     * @param tokenAddress address of the removed token.\n     * @param index Index of the removed token.\n     */\n    event TokenRemoved(address tokenAddress, uint256 index);\n}\n"
    },
    "contracts/base/escrow/dapps/YearnDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"../../escrow/BaseEscrowDapp.sol\";\n\n// Common\nimport \"../../../util/AddressLib.sol\";\n\n// External Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Interfaces\nimport \"./IYearnDapp.sol\";\nimport \"../../../providers/yearn/IVault.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                      DAPP CONTRACT IS AN EXTENSION OF THE ESCROW CONTRACT                       **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Because there are multiple dApp contracts, and they all extend the Escrow contract that is     **/\n/**  itself upgradeable, they cannot have their own storage variables as they would cause the the   **/\n/**  storage slots to be overwritten on the Escrow proxy contract!                                  **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract is used to define the yVault dApp actions available. All dapp actions are invoked via\n        delegatecalls from Escrow contract, so this contract's state is really Escrow.\n    @author develop@teller.finance\n */\ncontract YearnDapp is IYearnDapp, BaseEscrowDapp {\n    using AddressLib for address;\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /** External Functions */\n    /**\n        @notice Deposits the specified amount of the native unwrapped token (same as token() returns) into the Vault\n        @param tokenAddress The address of the token being deposited\n        @param amount The amount of tokens to be deposited into the vault\n     */\n    function deposit(address tokenAddress, uint256 amount)\n        public\n        override\n        onlyBorrower\n    {\n        IVault iVault = _getYVault(tokenAddress);\n        uint256 tokenBalanceBeforeDeposit = iVault.balanceOf(address(this));\n        IERC20(tokenAddress).safeApprove(address(iVault), amount);\n        iVault.deposit(amount);\n        uint256 tokenBalanceAfterDeposit = iVault.balanceOf(address(this));\n        require(\n            tokenBalanceAfterDeposit > tokenBalanceBeforeDeposit,\n            \"YEARN_BALANCE_NOT_INCREASED\"\n        );\n        _tokenUpdated(tokenAddress);\n        emit YearnDeposited(\n            tokenAddress,\n            address(iVault),\n            amount,\n            tokenBalanceBeforeDeposit,\n            tokenBalanceAfterDeposit\n        );\n    }\n\n    /**\n        @notice Withdraws the specified amount of the native unwrapped token (same as token() returns) from the Vault\n        @param tokenAddress The address of the token being deposited\n        @param amount The amount of tokens to be deposited into the vault\n     */\n    function withdraw(address tokenAddress, uint256 amount)\n        public\n        override\n        onlyBorrower\n    {\n        IVault iVault = _getYVault(tokenAddress);\n        uint256 price = iVault.getPricePerShare();\n        uint256 shares = amount / price;\n        uint256 tokenBalanceBeforeWithdrawal =\n            IERC20(tokenAddress).balanceOf(address(this));\n        require(\n            shares >= iVault.balanceOf(address(this)),\n            \"INSUFFICIENT_DEPOSIT\"\n        );\n        iVault.withdraw(shares);\n        uint256 tokenBalanceAfterWithdrawal =\n            IERC20(tokenAddress).balanceOf(address(this));\n        require(\n            tokenBalanceAfterWithdrawal > tokenBalanceBeforeWithdrawal,\n            \"WITHDRAWAL_UNSUCCESSFUL\"\n        );\n\n        _tokenUpdated(address(iVault));\n\n        emit YearnWithdrawn(\n            iVault.token(),\n            address(iVault),\n            amount,\n            tokenBalanceBeforeWithdrawal,\n            tokenBalanceAfterWithdrawal\n        );\n    }\n\n    /**\n        @notice Redeems all funds from a yVault from a previous deposit\n        @param tokenAddress The address of the token being deposited\n     */\n    function withdrawAll(address tokenAddress) public override onlyBorrower {\n        IVault iVault = _getYVault(tokenAddress);\n        uint256 tokenBalanceBeforeWithdrawal =\n            IERC20(tokenAddress).balanceOf(address(this));\n        iVault.withdraw();\n        uint256 tokenBalanceAfterWithdrawal =\n            IERC20(tokenAddress).balanceOf(address(this));\n        require(\n            tokenBalanceAfterWithdrawal > tokenBalanceBeforeWithdrawal,\n            \"WITHDRAWAL_UNSUCCESSFUL\"\n        );\n        emit YearnWithdrawn(\n            iVault.token(),\n            address(iVault),\n            tokenBalanceBeforeWithdrawal,\n            tokenBalanceBeforeWithdrawal,\n            tokenBalanceAfterWithdrawal\n        );\n    }\n\n    /**\n        @notice Returns the price of the Vault's wrapped token, denominated in the unwrapped native token\n        @notice Calculation is: nativeTokenBalance/yTokenTotalSupply,\n            - nativeTokenBalance is the current balance of the native token (example DAI) in the Vault\n            - yTokenTotalSupply is the total supply of the Vault's wrapped token (example yDAI)\n        @param tokenAddress The address of the underlying token for the associated yVault\n        @return The token price\n     */\n    function getPricePerFullShare(address tokenAddress)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        IVault iVault = _getYVault(tokenAddress);\n        return iVault.getPricePerFullShare();\n    }\n\n    /** Internal Functions */\n\n    /**\n        @notice Grabs the yVault address for a token from the asset settings\n        @param tokenAddress The underlying token address for the associated yVault\n        @return yVault instance\n     */\n    function _getYVault(address tokenAddress) internal view returns (IVault) {\n        return IVault(settings.assetSettings().getYVaultAddress(tokenAddress));\n    }\n}\n"
    },
    "contracts/base/escrow/dapps/IYearnDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    @notice Yearn dApp interface.\n\n    @author develop@teller.finance\n */\ninterface IYearnDapp {\n    /**\n        @notice Deposits the specified amount of the native unwrapped token (same as token() returns) into the Vault\n        @param tokenAddress The address of the token being deposited\n        @param amount The amount of tokens to be deposited into the vault\n     */\n    function deposit(address tokenAddress, uint256 amount) external;\n\n    /**\n        @notice Withdraws the specified amount of the native unwrapped token (same as token() returns) from the Vault\n        @param tokenAddress The address of the underlying token being withdrawn\n        @param amount The amount of tokens to be withdrawn into the vault\n     */\n    function withdraw(address tokenAddress, uint256 amount) external;\n\n    /**\n        @notice Withdraws all the deposited tokens (same as token() returns) from the Vault\n        @param tokenAddress The address of the underlying token being withdrawn\n     */\n    function withdrawAll(address tokenAddress) external;\n\n    /**\n        @notice Returns the price of the Vault's wrapped token, denominated in the unwrapped native token\n        @notice Calculation is: nativeTokenBalance/yTokenTotalSupply,\n            - nativeTokenBalance is the current balance of the native token (example DAI) in the Vault\n            - yTokenTotalSupply is the total supply of the Vault's wrapped token (example yDAI)\n        @param tokenAddress The address of the underlying token for the associated yVault\n        @return uint256 The token price\n     */\n    function getPricePerFullShare(address tokenAddress)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @notice This event is emitted when a yVault deposit is invoked successfully\n        @param iVault The address of the yVault\n        @param amount The amount of funds to deposit\n        @param tokenBalanceBeforeDeposit The balance of tokens held after depositing\n        @param tokenBalanceAfterDeposit The balance of tokens held after depositing\n     */\n    event YearnDeposited(\n        address tokenAddress,\n        address iVault,\n        uint256 amount,\n        uint256 tokenBalanceBeforeDeposit,\n        uint256 tokenBalanceAfterDeposit\n    );\n\n    /**\n        @notice This event is emitted when a yVault withdraw is invoked successfully\n        @param underlyingToken The address of the underlying token of the vault\n        @param iVault The address of the yVault\n        @param amount The amount of funds to withdraw\n        @param tokenBalanceBeforeWithdrawal The balance of tokens held before withdrawal\n        @param tokenBalanceAfterWithdrawal The balance of tokens held after withdrawal\n     */\n    event YearnWithdrawn(\n        address underlyingToken,\n        address iVault,\n        uint256 amount,\n        uint256 tokenBalanceBeforeWithdrawal,\n        uint256 tokenBalanceAfterWithdrawal\n    );\n}\n"
    },
    "contracts/providers/yearn/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    @notice This interface defines the different functions available for a Yearn Vault\n    @author develop@teller.finance\n */\n\ninterface IVault {\n    /**\n        @notice Returns the unwrapped native token address that the Vault takes as deposit\n        @return The address of the unwrapped token\n     */\n    function token() external view returns (address);\n\n    /**\n        @notice Returns the vault's wrapped token name as a string, example 'yearn Dai Stablecoin'\n        @return The name of the wrapped token\n     */\n    function name() external view returns (string memory);\n\n    /**\n        @notice Returns the vault's wrapped token symbol as a string, example 'yDai'\n        @return The symbol of the wrapped token\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n        @notice Returns the amount of decimals for this vault's wrapped token as a uin8\n        @return The number of decimals for the token\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n        @notice Returns the address of the Vault's controller\n        @return The address of the controller contract\n     */\n    function controller() external view returns (address);\n\n    /**\n        @notice Returns the address of the Vault's governance contract\n        @return The contract address\n     */\n    function governance() external view returns (address);\n\n    /**\n        @notice Returns the price of the Vault's wrapped token, denominated in the unwrapped native token\n        @notice Calculation is: nativeTokenBalance/yTokenTotalSupply,\n            - nativeTokenBalance is the current balance of the native token (example DAI) in the Vault\n            - yTokenTotalSupply is the total supply of the Vault's wrapped token (example yDAI)\n        @return The token price\n     */\n    function getPricePerFullShare() external view returns (uint256); // v1 vaults\n\n    /**\n        @notice Returns the price of the Vault's wrapped token, denominated in the unwrapped native token\n        @notice Calculation is: nativeTokenBalance/yTokenTotalSupply,\n            - nativeTokenBalance is the current balance of the native token (example DAI) in the Vault\n            - yTokenTotalSupply is the total supply of the Vault's wrapped token (example yDAI)\n        @return The token price\n     */\n    function getPricePerShare() external view returns (uint256); // v2 vaults\n\n    /**\n        @notice Deposits the specified amount of the native unwrapped token (same as token() returns) into the Vault\n        @param amountToDeposit The amount of tokens to deposit\n     */\n    function deposit(uint256 amountToDeposit) external;\n\n    /**\n        @notice Deposits the maximum available amount of the native wrapped token (same as token()) into the Vault\n     */\n    function depositAll() external;\n\n    /**\n        @notice Withdraws the specified amount of the native unwrapped token (same as token() returns) from the Vault\n        @param amountToWithdraw The amount to withdraw\n     */\n    function withdraw(uint256 amountToWithdraw) external;\n\n    /**\n        @notice Withdraws all to the sender.\n     */\n    function withdraw() external;\n\n    /**\n        @notice Withdraws the maximum available amount of native unwrapped token (same as token()) from the Vault\n     */\n    function withdrawAll() external;\n}\n"
    },
    "contracts/base/escrow/dapps/UniswapDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// External Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Common\nimport \"../../../util/AddressLib.sol\";\n\n// Contracts\nimport \"../../escrow/BaseEscrowDapp.sol\";\n\n// Interfaces\nimport \"./IUniswapDapp.sol\";\nimport \"../../../providers/uniswap/IUniswapV2Router02.sol\";\nimport \"../../../providers/uniswap/UniSwapper.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                      DAPP CONTRACT IS AN EXTENSION OF THE ESCROW CONTRACT                       **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Because there are multiple dApp contracts, and they all extend the Escrow contract that is     **/\n/**  itself upgradeable, they cannot have their own storage variables as they would cause the the   **/\n/**  storage slots to be overwritten on the Escrow proxy contract!                                  **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract is used to define Uniswap dApp actions available. All dapp actions are invoked via\n        delegatecalls from Escrow contract, so this contract's state is really Escrow.\n    @author develop@teller.finance\n */\ncontract UniswapDapp is IUniswapDapp, UniSwapper, BaseEscrowDapp {\n    /**\n        @notice Swaps ETH/Tokens for Tokens/ETH using different Uniswap v2 Router 02 methods.\n        @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.\n        @param sourceAmount amount of source token to swap.\n        @param minDestination The minimum amount of output tokens that must be received for the transaction not to revert.\n     */\n    function swap(\n        address[] memory path,\n        uint256 sourceAmount,\n        uint256 minDestination\n    ) public override onlyBorrower {\n        uint256 destinationAmount =\n            _uniswap(path, sourceAmount, minDestination);\n\n        _tokenUpdated(path[0]);\n        _tokenUpdated(path[path.length - 1]);\n\n        emit UniswapSwapped(\n            path[0],\n            path[path.length - 1],\n            sourceAmount,\n            destinationAmount\n        );\n    }\n}\n"
    },
    "contracts/base/escrow/dapps/IUniswapDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    @notice This defines the functions available to use in the Uniswap Dapp.\n    @author develop@teller.finance\n */\ninterface IUniswapDapp {\n    /**\n        @notice Swaps tokens using the Uniswap protocol.\n        @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.\n        @param sourceAmount amount of source token to swap.\n        @param minDestination The minimum amount of output tokens that must be received for the transaction not to revert.\n        @dev This function mainly invokes 3 Uniswap external functions:\n            https://uniswap.org/docs/v2/smart-contracts/router02/#swapexactethfortokens\n            https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensforeth\n            https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens\n     */\n    function swap(\n        address[] calldata path,\n        uint256 sourceAmount,\n        uint256 minDestination\n    ) external;\n\n    /**\n        @notice Event emmitted every time a successful swap has taken place.\n        @param sourceToken source token address.\n        @param destinationToken destination address.\n        @param sourceAmount source amount sent.\n        @param destinationAmount destination amount received.\n     */\n    event UniswapSwapped(\n        address indexed sourceToken,\n        address indexed destinationToken,\n        uint256 sourceAmount,\n        uint256 destinationAmount\n    );\n}\n"
    },
    "contracts/base/escrow/dapps/PoolTogetherDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// External Libraries\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n// Common\nimport \"../../../util/AddressLib.sol\";\n\n//Contracts\nimport \"../BaseEscrowDapp.sol\";\n\n// Interfaces\nimport \"./IPoolTogetherDapp.sol\";\nimport \"../../../providers/pooltogether/PrizePoolInterface.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                      DAPP CONTRACT IS AN EXTENSION OF THE ESCROW CONTRACT                       **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Because there are multiple dApp contracts, and they all extend the Escrow contract that is     **/\n/**  itself upgradeable, they cannot have their own storage variables as they would cause the the   **/\n/**  storage slots to be overwritten on the Escrow proxy contract!                                  **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n\n/**\n    @notice This contract is used to define the Pool Together dApp actions available. All dapp actions are invoked via\n        delegatecalls from Escrow contract, so this contract's state is really Escrow.\n    @author develop@teller.finance\n */\ncontract PoolTogetherDapp is IPoolTogetherDapp, BaseEscrowDapp {\n    using AddressLib for address;\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    /** State Variables */\n\n    /** External Functions */\n\n    /**\n        @notice This function deposits the users funds into a Pool Together Prize Pool for a ticket.\n        @param tokenAddress address of the token.\n        @param amount of tokens to deposit.\n    */\n    function depositTicket(address tokenAddress, uint256 amount)\n        public\n        override\n        onlyBorrower\n    {\n        require(\n            _balanceOf(tokenAddress) >= amount,\n            \"POOL_INSUFFICIENT_UNDERLYING\"\n        );\n\n        PrizePoolInterface prizePool = _getPrizePool(tokenAddress);\n\n        address ticketAddress = _getTicketAddress(tokenAddress);\n        uint256 balanceBefore = _balanceOf(ticketAddress);\n        IERC20(tokenAddress).safeApprove(address(prizePool), amount);\n\n        prizePool.depositTo(\n            address(this),\n            amount,\n            ticketAddress,\n            address(this)\n        );\n\n        uint256 balanceAfter = _balanceOf(ticketAddress);\n        require(balanceAfter > balanceBefore, \"DEPOSIT_ERROR\");\n\n        _tokenUpdated(address(ticketAddress));\n        _tokenUpdated(tokenAddress);\n\n        emit PoolTogetherDeposited(\n            tokenAddress,\n            ticketAddress,\n            amount,\n            _balanceOf(tokenAddress),\n            balanceAfter\n        );\n    }\n\n    /**\n        @notice This function withdraws the users funds from a Pool Together Prize Pool.\n        @param tokenAddress address of the token.\n        @param amount The amount of tokens to withdraw.\n    */\n    function withdraw(address tokenAddress, uint256 amount)\n        public\n        override\n        onlyBorrower\n    {\n        PrizePoolInterface prizePool = _getPrizePool(tokenAddress);\n\n        address ticketAddress = _getTicketAddress(tokenAddress);\n        uint256 balanceBefore = _balanceOf(ticketAddress);\n\n        (\n            uint256 maxExitFee, /* uint256 burnedCredit */\n\n        ) =\n            prizePool.calculateEarlyExitFee(\n                address(this),\n                ticketAddress,\n                amount\n            );\n        prizePool.withdrawInstantlyFrom(\n            address(this),\n            amount,\n            ticketAddress,\n            maxExitFee\n        );\n\n        uint256 balanceAfter = _balanceOf(ticketAddress);\n        require(balanceAfter < balanceBefore, \"WITHDRAW_ERROR\");\n\n        _tokenUpdated(address(ticketAddress));\n        _tokenUpdated(tokenAddress);\n\n        emit PoolTogetherWithdrawal(\n            tokenAddress,\n            ticketAddress,\n            amount,\n            _balanceOf(tokenAddress),\n            balanceAfter\n        );\n    }\n\n    /**\n        @notice This function withdraws the users funds from a Pool Together Prize Pool.\n        @param tokenAddress address of the token.\n    */\n    function withdrawAll(address tokenAddress) public override onlyBorrower {\n        PrizePoolInterface prizePool = _getPrizePool(tokenAddress);\n\n        address ticketAddress = _getTicketAddress(tokenAddress);\n\n        uint256 balanceBefore = _balanceOf(ticketAddress);\n\n        (uint256 maxExitFee, ) =\n            prizePool.calculateEarlyExitFee(\n                address(this),\n                ticketAddress,\n                balanceBefore\n            );\n        prizePool.withdrawInstantlyFrom(\n            address(this),\n            balanceBefore,\n            ticketAddress,\n            maxExitFee\n        );\n\n        uint256 balanceAfter = _balanceOf(ticketAddress);\n        require(balanceAfter < balanceBefore, \"WITHDRAW_ERROR\");\n\n        _tokenUpdated(address(ticketAddress));\n        _tokenUpdated(tokenAddress);\n\n        emit PoolTogetherWithdrawal(\n            tokenAddress,\n            ticketAddress,\n            balanceBefore,\n            _balanceOf(tokenAddress),\n            balanceAfter\n        );\n    }\n\n    /** Internal Functions */\n    /**\n        @notice Grabs the Pool Together Prize Pool address for an token from the asset settings.\n        @notice The pool underlying address must match the supplied token address.\n        @param tokenAddress The token address to get the cToken for.\n        @return PrizePool instance.\n     */\n    function _getPrizePool(address tokenAddress)\n        internal\n        view\n        returns (PrizePoolInterface)\n    {\n        return\n            PrizePoolInterface(\n                settings.assetSettings().getPrizePoolAddress(tokenAddress)\n            );\n    }\n\n    /**\n        @notice Grabs the controlled ticket token address for the prize pool\n        @notice The pool underlying address must match the supplied token address.\n        @param tokenAddress The token address to get the cToken for.\n        @return The address of the ticket token contract.\n    */\n    function _getTicketAddress(address tokenAddress)\n        internal\n        view\n        returns (address)\n    {\n        return _getPrizePool(tokenAddress).tokens()[1];\n    }\n}\n"
    },
    "contracts/base/escrow/dapps/IPoolTogetherDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    @notice Pool Together dApp interface.\n\n    @author develop@teller.finance\n */\ninterface IPoolTogetherDapp {\n    /**\n        @notice This function deposits the users funds into a Pool Together Prize Pool for a ticket.\n        @param tokenAddress address of the token.\n        @param amount of tokens to deposit.\n    */\n    function depositTicket(address tokenAddress, uint256 amount) external;\n\n    /**\n        @notice This function withdraws the users funds from a Pool Together Prize Pool.\n        @param tokenAddress address of the token.\n        @param amount The amount of tokens to withdraw.\n    */\n    function withdraw(address tokenAddress, uint256 amount) external;\n\n    /**\n        @notice This function withdraws the users funds from a Pool Together Prize Pool.\n        @param tokenAddress address of the token.\n    */\n    function withdrawAll(address tokenAddress) external;\n\n    /**\n        @notice This event is emitted every time Pool Together depositTo is invoked successfully.\n        @param tokenAddress address of the underlying token.\n        @param ticketAddress pool ticket token address.\n        @param amount amount of tokens deposited.\n        @param tokenBalance underlying token balance after depositing.\n        @param creditBalanceAfter pool together credit after depositing.\n     */\n    event PoolTogetherDeposited(\n        address indexed tokenAddress,\n        address indexed ticketAddress,\n        uint256 amount,\n        uint256 tokenBalance,\n        uint256 creditBalanceAfter\n    );\n\n    /**\n        @notice This event is emitted every time Pool Together withdrawInstantlyFrom is invoked successfully.\n        @param tokenAddress address of the underlying token.\n        @param ticketAddress pool ticket token address.\n        @param amount amount of tokens to Redeem.\n        @param tokenBalance underlying token balance after Redeem.\n        @param creditBalanceAfter pool together credit after depositing.\n     */\n    event PoolTogetherWithdrawal(\n        address indexed tokenAddress,\n        address indexed ticketAddress,\n        uint256 amount,\n        uint256 tokenBalance,\n        uint256 creditBalanceAfter\n    );\n}\n"
    },
    "contracts/providers/pooltogether/PrizePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.\n/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.\n/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens\ninterface PrizePoolInterface {\n    /// @notice Deposit assets into the Prize Pool in exchange for tokens\n    /// @param to The address receiving the newly minted tokens\n    /// @param amount The amount of assets to deposit\n    /// @param controlledToken The address of the type of token the user is minting\n    /// @param referrer The referrer of the deposit\n    function depositTo(\n        address to,\n        uint256 amount,\n        address controlledToken,\n        address referrer\n    ) external;\n\n    /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.\n    /// @param from The address to redeem tokens from.\n    /// @param amount The amount of tokens to redeem for assets.\n    /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)\n    /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.\n    /// @return The actual exit fee paid\n    function withdrawInstantlyFrom(\n        address from,\n        uint256 amount,\n        address controlledToken,\n        uint256 maximumExitFee\n    ) external returns (uint256);\n\n    /// @notice Returns the balance that is available to award.\n    /// @dev captureAwardBalance() should be called first\n    /// @return The total amount of assets to be awarded for the current prize\n    function awardBalance() external view returns (uint256);\n\n    /// @notice Calculates the early exit fee for the given amount\n    /// @param from The user who is withdrawing\n    /// @param controlledToken The type of collateral being withdrawn\n    /// @param amount The amount of collateral to be withdrawn\n    /// @return exitFee The exit fee\n    /// @return burnedCredit The user's credit that was burned\n    function calculateEarlyExitFee(\n        address from,\n        address controlledToken,\n        uint256 amount\n    ) external returns (uint256 exitFee, uint256 burnedCredit);\n\n    /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit.\n    /// @param _principal The principal amount on which interest is accruing\n    /// @param _interest The amount of interest that must accrue\n    /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.\n    function estimateCreditAccrualTime(\n        address _controlledToken,\n        uint256 _principal,\n        uint256 _interest\n    ) external view returns (uint256 durationSeconds);\n\n    /// @notice Returns the credit balance for a given user.  Not that this includes both minted credit and pending credit.\n    /// @param user The user whose credit balance should be returned\n    /// @return The balance of the users credit\n    function balanceOfCredit(address user, address controlledToken)\n        external\n        returns (uint256);\n\n    /// @notice Returns the credit rate of a controlled token\n    /// @param controlledToken The controlled token to retrieve the credit rates for\n    /// @return creditLimitMantissa The credit limit fraction.  This number is used to calculate both the credit limit and early exit fee.\n    /// @return creditRateMantissa The credit rate. This is the amount of tokens that accrue per second.\n    function creditPlanOf(address controlledToken)\n        external\n        view\n        returns (uint128 creditLimitMantissa, uint128 creditRateMantissa);\n\n    /// @dev Returns the address of the underlying ERC20 asset\n    /// @return The address of the asset\n    function token() external view returns (address);\n\n    /// @notice An array of the Tokens controlled by the Prize Pool (ie. Tickets, Sponsorship)\n    /// @return An array of controlled token addresses\n    function tokens() external view returns (address[] memory);\n\n    /// @notice The total of all controlled tokens and timelock.\n    /// @return The current total of all tokens and timelock.\n    function accountedBalance() external view returns (uint256);\n}\n"
    },
    "contracts/base/escrow/dapps/CompoundDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// External Libraries\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n// Common\nimport \"../../../util/AddressLib.sol\";\n\n//Contracts\nimport \"../../escrow/BaseEscrowDapp.sol\";\n\n// Interfaces\nimport \"./ICompoundDapp.sol\";\nimport \"../../../providers/compound/CErc20Interface.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                      DAPP CONTRACT IS AN EXTENSION OF THE ESCROW CONTRACT                       **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Because there are multiple dApp contracts, and they all extend the Escrow contract that is     **/\n/**  itself upgradeable, they cannot have their own storage variables as they would cause the the   **/\n/**  storage slots to be overwritten on the Escrow proxy contract!                                  **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract is used to define Compound dApp actions available. All dapp actions are invoked via\n        delegatecalls from Escrow contract, so this contract's state is really Escrow.\n    @author develop@teller.finance\n */\ncontract CompoundDapp is ICompoundDapp, BaseEscrowDapp {\n    using AddressLib for address;\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    /* State Variables */\n\n    /* Error Codes */\n\n    uint256 public constant NO_ERROR = 0;\n\n    // @notice Caller does not have sufficient balance in the ERC-20 contract to complete the desired action.\n    uint256 public constant TOKEN_INSUFFICIENT_BALANCE = 13;\n\n    // State is shared with Escrow contract as it uses delegateCall() to interact with this contract.\n\n    /**\n        @notice To lend we first have to approve the cToken to access the token balance then mint.\n        @param tokenAddress address of the token.\n        @param amount amount of tokens to mint.\n    */\n    function lend(address tokenAddress, uint256 amount)\n        public\n        override\n        onlyBorrower\n    {\n        require(\n            _balanceOf(tokenAddress) >= amount,\n            \"COMPOUND_INSUFFICIENT_UNDERLYING\"\n        );\n\n        CErc20Interface cToken = _getCToken(tokenAddress);\n        IERC20(tokenAddress).safeApprove(address(cToken), amount);\n        uint256 result = cToken.mint(amount);\n        require(result == NO_ERROR, \"COMPOUND_DEPOSIT_ERROR\");\n\n        _tokenUpdated(address(cToken));\n        _tokenUpdated(tokenAddress);\n\n        emit CompoundLended(\n            tokenAddress,\n            address(cToken),\n            amount,\n            _balanceOf(tokenAddress),\n            cToken.balanceOf(address(this))\n        );\n    }\n\n    /**\n        @notice This function redeems the user's cTokens for a specific amount of the underlying token.\n        @param tokenAddress address of the token.\n        @param amount amount of underlying tokens to redeem.\n    */\n    function redeem(address tokenAddress, uint256 amount)\n        public\n        override\n        onlyBorrower\n    {\n        CErc20Interface cToken = _getCToken(tokenAddress);\n        _redeem(cToken, amount, true);\n    }\n\n    /**\n        @notice This function redeems the complete cToken balance.\n        @param tokenAddress address of the token.\n    */\n    function redeemAll(address tokenAddress) public override onlyBorrower {\n        CErc20Interface cToken = _getCToken(tokenAddress);\n        _redeem(cToken, cToken.balanceOf(address(this)), false);\n    }\n\n    /* Internal Functions */\n\n    /**\n        @notice This function calls on Compound cToken to redeem an amount of the underlying token.\n        @param cToken the instance of the cToken.\n        @param amount amount of cToken or underlying token to redeem.\n        @param isUnderlying boolean indicating if the amount to redeem is in the underlying token amount.\n    */\n    function _redeem(\n        CErc20Interface cToken,\n        uint256 amount,\n        bool isUnderlying\n    ) internal {\n        address tokenAddress = cToken.underlying();\n        uint256 result =\n            isUnderlying\n                ? cToken.redeemUnderlying(amount)\n                : cToken.redeem(amount);\n        require(\n            result != TOKEN_INSUFFICIENT_BALANCE,\n            \"COMPOUND_INSUFFICIENT_BALANCE\"\n        );\n        require(result == NO_ERROR, \"COMPOUND_WITHDRAWAL_ERROR\");\n\n        _tokenUpdated(address(cToken));\n        _tokenUpdated(tokenAddress);\n\n        emit CompoundRedeemed(\n            tokenAddress,\n            address(cToken),\n            amount,\n            isUnderlying,\n            _balanceOf(tokenAddress),\n            cToken.balanceOf(address(this))\n        );\n    }\n\n    /**\n        @notice Grabs the cToken address for an token from the asset settings.\n        @notice The cToken underlying address must match the supplied token address.\n        @param tokenAddress The token address to get the cToken for.\n        @return cToken instance\n     */\n    function _getCToken(address tokenAddress)\n        internal\n        view\n        returns (CErc20Interface)\n    {\n        return CErc20Interface(settings.getCTokenAddress(tokenAddress));\n    }\n}\n"
    },
    "contracts/base/escrow/dapps/ICompoundDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    @notice Compound dApp interface.\n\n    @author develop@teller.finance\n */\ninterface ICompoundDapp {\n    /**\n        @notice To lend we first have to approve the cToken to access the token balance then mint.\n        @param tokenAddress address of the token.\n        @param amount amount of tokens to mint.\n    */\n    function lend(address tokenAddress, uint256 amount) external;\n\n    /**\n        @notice This function calls Compound redeemUnderlying().\n        @param tokenAddress address of the token.\n        @param amount amount of underlying tokens to redeem.\n    */\n    function redeem(address tokenAddress, uint256 amount) external;\n\n    /**\n        @notice This function redeems complete token balance.\n        @param tokenAddress address of the token.\n    */\n    function redeemAll(address tokenAddress) external;\n\n    /**\n        @notice This event is emitted every time Compound lend is invoked successfully.\n        @param tokenAddress address of the underlying token.\n        @param cTokenAddress compound token address.\n        @param amount amount of tokens to Lend.\n        @param tokenBalance underlying token balance after Lend.\n        @param cTokenBalance cTokens balance after Lend.\n     */\n    event CompoundLended(\n        address indexed tokenAddress,\n        address indexed cTokenAddress,\n        uint256 amount,\n        uint256 tokenBalance,\n        uint256 cTokenBalance\n    );\n\n    /**\n        @notice This event is emitted every time Compound redeem is invoked successfully.\n        @param tokenAddress address of the underlying token.\n        @param cTokenAddress compound token address.\n        @param amount amount of tokens to Redeem.\n        @param isUnderlyingAmount boolean indicating if the amount was in the underlying token.\n        @param tokenBalance underlying token balance after Redeem.\n        @param cTokenBalance cTokens balance after Redeem.\n     */\n    event CompoundRedeemed(\n        address indexed tokenAddress,\n        address indexed cTokenAddress,\n        uint256 amount,\n        bool isUnderlyingAmount,\n        uint256 tokenBalance,\n        uint256 cTokenBalance\n    );\n}\n"
    },
    "contracts/base/escrow/dapps/AaveDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// External Libraries\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n//Contracts\nimport \"../../escrow/BaseEscrowDapp.sol\";\n\n// Common\nimport \"../../../util/AddressLib.sol\";\n\n// Interfaces\nimport \"./IAaveDapp.sol\";\nimport \"../../../providers/aave/IAToken.sol\";\nimport \"../../../providers/aave/IAaveLendingPoolAddressesProvider.sol\";\nimport \"../../../providers/aave/IAaveLendingPool.sol\";\n\n/*****************************************************************************************************/\n/**                                             WARNING                                             **/\n/**                      DAPP CONTRACT IS AN EXTENSION OF THE ESCROW CONTRACT                       **/\n/**  ---------------------------------------------------------------------------------------------  **/\n/**  Because there are multiple dApp contracts, and they all extend the Escrow contract that is     **/\n/**  itself upgradeable, they cannot have their own storage variables as they would cause the the   **/\n/**  storage slots to be overwritten on the Escrow proxy contract!                                  **/\n/**                                                                                                 **/\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\n/**  more information.                                                                              **/\n/*****************************************************************************************************/\n/**\n    @notice This contract is used to define Aave dApp actions available. All dapp actions are invoked via\n        delegatecalls from Escrow contract, so this contract's state is really Escrow.\n    @author develop@teller.finance\n */\ncontract AaveDapp is IAaveDapp, BaseEscrowDapp {\n    using AddressLib for address;\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    /**\n        @notice The deposit, the aToken needs to be approved to have access to the token balance\n        @param tokenAddress address of the token\n        @param amount amount of tokens to deposit\n     */\n    function deposit(address tokenAddress, uint256 amount)\n        public\n        override\n        onlyBorrower\n    {\n        IAaveLendingPool aaveLendingPool = _getAaveLendingPool();\n        IAToken aToken = _getAToken(tokenAddress);\n        uint256 aTokenBalanceBeforeDeposit = aToken.balanceOf(address(this));\n        IERC20(tokenAddress).safeApprove(address(aaveLendingPool), amount);\n        aaveLendingPool.deposit(tokenAddress, amount, address(this), 0);\n        uint256 aTokenBalanceAfterDeposit = aToken.balanceOf(address(this));\n        require(\n            aTokenBalanceAfterDeposit > aTokenBalanceBeforeDeposit,\n            \"AAVE_BALANCE_NOT_INCREASED\"\n        );\n\n        _tokenUpdated(address(aToken));\n        _tokenUpdated(tokenAddress);\n\n        emit AaveDeposited(\n            tokenAddress,\n            address(aToken),\n            amount,\n            aTokenBalanceBeforeDeposit,\n            aTokenBalanceAfterDeposit\n        );\n    }\n\n    /**\n        @notice This function withdraws the user's aTokens for a specific amount\n        @param tokenAddress address of the token\n        @param amount amount of the underlying tokens to withdraw\n     */\n    function withdraw(address tokenAddress, uint256 amount)\n        public\n        override\n        onlyBorrower\n    {\n        IAToken aToken = _getAToken(tokenAddress);\n        IAaveLendingPool aaveLendingPool = _getAaveLendingPool();\n        uint256 aTokenBalanceBeforeWithdraw = aToken.balanceOf(address(this));\n        require(\n            aTokenBalanceBeforeWithdraw >= amount,\n            \"NO_BALANCE_TO_WITHDRAW\"\n        );\n        aaveLendingPool.withdraw(tokenAddress, amount, address(this));\n        uint256 aTokenBalanceAfterWithdraw = aToken.balanceOf(address(this));\n        require(\n            aTokenBalanceAfterWithdraw < aTokenBalanceBeforeWithdraw,\n            \"AAVE_WITHDRAWAL_ERROR\"\n        );\n\n        _tokenUpdated(address(aToken));\n        _tokenUpdated(tokenAddress);\n\n        emit AaveWithdrawn(\n            tokenAddress,\n            address(aToken),\n            amount,\n            aTokenBalanceBeforeWithdraw,\n            aTokenBalanceAfterWithdraw\n        );\n    }\n\n    /**\n        @notice This function withdraws all the user's aTokens from previous deposits\n        @param tokenAddress address of the token\n     */\n    function withdrawAll(address tokenAddress) public override onlyBorrower {\n        IAToken aToken = _getAToken(tokenAddress);\n\n        uint256 aTokenBalanceBeforeWithdraw = aToken.balanceOf(address(this));\n        require(aTokenBalanceBeforeWithdraw >= 0, \"NO_BALANCE_TO_WITHDRAW\");\n\n        IAaveLendingPool aaveLendingPool = _getAaveLendingPool();\n        aaveLendingPool.withdraw(\n            tokenAddress,\n            aTokenBalanceBeforeWithdraw,\n            address(this)\n        );\n        uint256 aTokenBalanceAfterWithdraw = aToken.balanceOf(address(this));\n        require(aTokenBalanceAfterWithdraw == 0, \"AAVE_WITHDRAWAL_ERROR\");\n\n        _tokenUpdated(address(aToken));\n        _tokenUpdated(tokenAddress);\n\n        emit AaveWithdrawn(\n            tokenAddress,\n            address(aToken),\n            aTokenBalanceBeforeWithdraw,\n            aTokenBalanceBeforeWithdraw,\n            aTokenBalanceAfterWithdraw\n        );\n    }\n\n    /**\n        @notice Grabs the Aave lending pool instance from the Aave lending pool address provider\n        @return IAaveLendingPool instance address\n     */\n    function _getAaveLendingPool() internal view returns (IAaveLendingPool) {\n        return\n            IAaveLendingPool(\n                IAaveLendingPoolAddressesProvider(\n                    0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5\n                )\n                    .getLendingPool()\n            ); // LP address provider contract is immutable and the address will never change\n    }\n\n    /**\n        @notice Grabs the aToken instance from the lending pool\n        @param tokenAddress The underlying asset address to get the aToken for\n        @return IAToken instance\n     */\n    function _getAToken(address tokenAddress) internal view returns (IAToken) {\n        return\n            IAToken(\n                _getAaveLendingPool().getReserveData(tokenAddress).aTokenAddress\n            );\n    }\n}\n"
    },
    "contracts/base/escrow/dapps/IAaveDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    @notice Aave dApp interface.\n\n    @author develop@teller.finance\n */\ninterface IAaveDapp {\n    /**\n        @notice This event is emitted every time Aave deposit is invoked successfully.\n        @param tokenAddress address of the underlying token.\n        @param aTokenAddress aave token address.\n        @param amount amount of tokens to Deposit.\n        @param aTokenBalanceBeforeDeposit aTokens balance after Deposit.\n        @param aTokenBalanceAfterDeposit aTokens balance after Deposit.\n     */\n    event AaveDeposited(\n        address indexed tokenAddress,\n        address indexed aTokenAddress,\n        uint256 amount,\n        uint256 aTokenBalanceBeforeDeposit,\n        uint256 aTokenBalanceAfterDeposit\n    );\n\n    /**\n        @notice This event is emitted every time Aave redeem is invoked successfully.\n        @param tokenAddress address of the underlying token.\n        @param aTokenAddress aave token address.\n        @param amount amount of tokens to Withdrawal.\n        @param aTokenBalanceBeforeDeposit aTokens balance after Withdrawal.\n        @param aTokenBalanceAfterWithdrawal aTokens balance after Withdrawal.\n     */\n    event AaveWithdrawn(\n        address indexed tokenAddress,\n        address indexed aTokenAddress,\n        uint256 amount,\n        uint256 aTokenBalanceBeforeDeposit,\n        uint256 aTokenBalanceAfterWithdrawal\n    );\n\n    /**\n        @notice The deposit, the aToken needs to be approved to have access to the token balance\n        @param tokenAddress address of the token\n        @param amount amount of tokens to deposit\n     */\n    function deposit(address tokenAddress, uint256 amount) external;\n\n    /**\n        @notice This function withdraws the user's aTokens for a specific amount\n        @param tokenAddress address of the token\n        @param amount amount of the underlying tokens to withdraw\n     */\n    function withdraw(address tokenAddress, uint256 amount) external;\n\n    /**\n        @notice This function withdraws all the user's aTokens from previous deposits\n        @param tokenAddress address of the token\n     */\n    function withdrawAll(address tokenAddress) external;\n}\n"
    },
    "contracts/providers/aave/IAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IAToken {\n    /**\n     * @dev Mints `amount` aTokens to `user`\n     * @param user The address receiving the minted tokens\n     * @param amount The amount of tokens getting minted\n     * @param index The new liquidity index of the reserve\n     * @return `true` if the the previous balance of the user was 0\n     */\n    function mint(\n        address user,\n        uint256 amount,\n        uint256 index\n    ) external returns (bool);\n\n    /**\n     * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n     * @param user The owner of the aTokens, getting them burned\n     * @param receiverOfUnderlying The address that will receive the underlying\n     * @param amount The amount being burned\n     * @param index The new liquidity index of the reserve\n     **/\n    function burn(\n        address user,\n        address receiverOfUnderlying,\n        uint256 amount,\n        uint256 index\n    ) external;\n\n    /**\n     * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n     * assets in borrow(), withdraw() and flashLoan()\n     * @param user The recipient of the aTokens\n     * @param amount The amount getting transferred\n     * @return The amount transferred\n     **/\n    function transferUnderlyingTo(address user, uint256 amount)\n        external\n        returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n     * updated stored balance divided by the reserve's liquidity index at the moment of the update\n     * @param user The user whose balance is calculated\n     * @return The scaled balance of the user\n     **/\n    function scaledBalanceOf(address user) external view returns (uint256);\n\n    /**\n     * @dev Returns the scaled balance of the user and the scaled total supply.\n     * @param user The address of the user\n     * @return The scaled balance of the user\n     * @return The scaled balance and the scaled total supply\n     **/\n    function getScaledUserBalanceAndSupply(address user)\n        external\n        view\n        returns (uint256, uint256);\n\n    /**\n     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n     * @return The scaled total supply\n     **/\n    function scaledTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/providers/aave/IAaveLendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface IAaveLendingPoolAddressesProvider {\n    function getMarketId() external view returns (string memory);\n\n    function getAddress(bytes32 id) external view returns (address);\n\n    function getLendingPool() external view returns (address);\n\n    function getPriceOracle() external view returns (address);\n\n    function getLendingRateOracle() external view returns (address);\n}\n"
    },
    "contracts/providers/aave/IAaveLendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./IAaveLendingPoolAddressesProvider.sol\";\nimport \"./DataTypes.sol\";\n\ninterface IAaveLendingPool {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n     * @param asset The address of the underlying asset borrowed\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n    /**\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n     *        borrowed at a stable rate and depositors are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     **/\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n        external;\n\n    /**\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralETH the total collateral in ETH of the user\n     * @return totalDebtETH the total debt in ETH of the user\n     * @return availableBorrowsETH the borrowing power left of the user\n     * @return currentLiquidationThreshold the liquidation threshold of the user\n     * @return ltv the loan to value of the user\n     * @return healthFactor the current health factor of the user\n     **/\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset)\n        external\n        view\n        returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @dev Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     **/\n    function getUserConfiguration(address user)\n        external\n        view\n        returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset)\n        external\n        view\n        returns (DataTypes.ReserveData memory);\n\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromAfter,\n        uint256 balanceToBefore\n    ) external;\n\n    function getReservesList() external view returns (address[] memory);\n\n    function getAddressesProvider()\n        external\n        view\n        returns (IAaveLendingPoolAddressesProvider);\n\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/providers/aave/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n    // refer to the aave whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode { NONE, STABLE, VARIABLE }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true,
        "orderLiterals": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
