{
  "address": "0xb7F9b3E67D8cE32342Ace6B975F3c44EB716Ffaf",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "contractURI",
          "type": "string"
        }
      ],
      "name": "setContractURI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x85715a0309ea5a225c95508593db924a49cbbb199eb558f213c89ddb1cc71e4f",
  "receipt": {
    "to": null,
    "from": "0xAFe87013dc96edE1E116a288D80FcaA0eFFE5fe5",
    "contractAddress": "0xb7F9b3E67D8cE32342Ace6B975F3c44EB716Ffaf",
    "transactionIndex": 1,
    "gasUsed": "222422",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd3ab95962a19dade05b2bc1fa681842cb46b46435e3a9a96517f4e7bd1413b06",
    "transactionHash": "0x85715a0309ea5a225c95508593db924a49cbbb199eb558f213c89ddb1cc71e4f",
    "logs": [],
    "blockNumber": 8362832,
    "cumulativeGasUsed": "286103",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "7dfea193bf8d74dddd4fadb38960c81e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.3+commit.8d00100c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"setContractURI(string)\":{\"params\":{\"contractURI\":\"The link to the initial contract level metadata.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"setContractURI(string)\":{\"notice\":\"Sets the contract level metadata URI.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"diamonds/domains/nft/entry/set-contract-uri.sol\":\"ent_setContractURI_NFT\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x62d306ff0499a11913bc60b5939eec619509b5c67b30e86ebf8b8bda0b7a7fee\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\",\"keccak256\":\"0x71e0d1cc75b67306382e055b789b6d3ffe34a9e2e55380d3c9895a36a42229e1\",\"license\":\"MIT\"},\"diamonds/contexts/access-control/data.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct RoleData {\\n    mapping(address => bool) members;\\n    bytes32 adminRole;\\n}\\n\\nabstract contract dat_AccessControl_v1 {\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    event OwnerSet(address indexed owner);\\n\\n    event OwnerTransferred(address indexed owner, address indexed prevOwner);\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n}\\n\\nabstract contract dat_AccessControl is dat_AccessControl_v1 {}\\n\",\"keccak256\":\"0x9709b886deef806c2e7b13219f12a7a2b5a83d68023291b0d1191872e0c9b6f2\",\"license\":\"MIT\"},\"diamonds/contexts/access-control/internal/has-role.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../storage/roles.sol\\\";\\n\\nabstract contract int_hasRole_AccessControl_v1 is sto_AccessControl_Roles {\\n    function _hasRole(bytes32 role, address account)\\n        internal\\n        view\\n        returns (bool hasRole_)\\n    {\\n        hasRole_ = accessControlRolesStore().roles[role].members[account];\\n    }\\n}\\n\",\"keccak256\":\"0x631c0c260f7de64c32a205405e3ec424a6b34aec27987ced91a0254fdabfb1a7\",\"license\":\"MIT\"},\"diamonds/contexts/access-control/internal/require-authorization.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./has-role.sol\\\";\\n\\nabstract contract int_requireAuthorization_AccessControl_v1 is\\n    int_hasRole_AccessControl_v1\\n{\\n    function _requireAuthorization(bytes32 role, address account)\\n        internal\\n        view\\n    {\\n        require(_hasRole(role, account), \\\"AccessControl: unauthorized\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x5c3bc56480df5bf9e9d37962f00dc46ddd4df10e8eddcb45a8ad6c9538c86d67\",\"license\":\"MIT\"},\"diamonds/contexts/access-control/modifiers/authorized.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {\\n    int_requireAuthorization_AccessControl_v1\\n} from \\\"../internal/require-authorization.sol\\\";\\n\\nabstract contract mod_authorized_AccessControl_v1 is\\n    int_requireAuthorization_AccessControl_v1\\n{\\n    modifier authorized(bytes32 role, address account) {\\n        _requireAuthorization(role, account);\\n        _;\\n    }\\n}\\n\\nabstract contract mod_authorized_AccessControl is\\n    mod_authorized_AccessControl_v1\\n{}\\n\",\"keccak256\":\"0x07b59ca25af7579afacf46fd29c611a89928dc3df8381f6a3dd5ba8ded407d61\",\"license\":\"MIT\"},\"diamonds/contexts/access-control/storage/roles.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { RoleData } from \\\"../data.sol\\\";\\n\\nabstract contract sto_AccessControl_Roles {\\n    bytes32 internal constant POS =\\n        keccak256(\\\"teller_protocol.storage.access_control.roles\\\");\\n\\n    struct AccessControlRolesStorage {\\n        mapping(bytes32 => RoleData) roles;\\n    }\\n\\n    function accessControlRolesStore()\\n        internal\\n        pure\\n        returns (AccessControlRolesStorage storage s)\\n    {\\n        bytes32 position = POS;\\n\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf6ed7f621fbdc1dbfafd54e35097030415310a38798397f61b5b230a2e128768\",\"license\":\"MIT\"},\"diamonds/domains/nft/data/tier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct Tier {\\n    uint256 baseLoanSize;\\n    string[] hashes;\\n    address contributionAsset;\\n    uint256 contributionSize;\\n    uint8 contributionMultiplier;\\n}\\n\",\"keccak256\":\"0x20ae7b004b8ab4b7b31b62265c4cee1e8851223c333c2e603d8d3f90a43c1f70\",\"license\":\"MIT\"},\"diamonds/domains/nft/entry/set-contract-uri.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"../storage/tier.sol\\\";\\nimport {\\n    mod_authorized_AccessControl\\n} from \\\"../../../contexts/access-control/modifiers/authorized.sol\\\";\\nimport { ADMIN } from \\\"../roles.sol\\\";\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"../internal/set-contract-uri.sol\\\";\\n\\ncontract ent_setContractURI_NFT_v1 is\\n    sto_Tier,\\n    mod_authorized_AccessControl,\\n    int_setContractURI_NFT\\n{\\n    /**\\n     * @notice Sets the contract level metadata URI.\\n     * @param contractURI The link to the initial contract level metadata.\\n     */\\n    function setContractURI(string memory contractURI)\\n        external\\n        authorized(ADMIN, msg.sender)\\n    {\\n        _setContractURI(contractURI);\\n    }\\n}\\n\\ncontract ent_setContractURI_NFT is ent_setContractURI_NFT_v1 {}\\n\",\"keccak256\":\"0x515374186f97b134450601bbb58a04acfa61d493bac5ec9612eee99c6595bb76\",\"license\":\"MIT\"},\"diamonds/domains/nft/internal/set-contract-uri.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"../storage/token.sol\\\";\\n\\nabstract contract int_setContractURI_NFT_v1 is sto_Token {\\n    /**\\n     * @notice Sets the contract level metadata URI.\\n     * @param contractURI The link to the initial contract level metadata.\\n     */\\n    function _setContractURI(string memory contractURI) internal {\\n        tokenStore().contractURI = contractURI;\\n    }\\n}\\n\\nabstract contract int_setContractURI_NFT is int_setContractURI_NFT_v1 {}\\n\",\"keccak256\":\"0xee01c2b6e97889783e1a602ea9f75ab78372336a4be86aaef9e3dbcee3754452\",\"license\":\"MIT\"},\"diamonds/domains/nft/roles.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nbytes32 constant ADMIN = keccak256(\\\"ADMIN\\\");\\nbytes32 constant MINTER = keccak256(\\\"MINTER\\\");\\n\",\"keccak256\":\"0xa5fecccb2dd77a6b8af8615bc5ef2bfdd19492c67ad72dcc38bec4ceff07905c\",\"license\":\"MIT\"},\"diamonds/domains/nft/storage/tier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport { Tier } from \\\"../data/tier.sol\\\";\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\nabstract contract sto_Tier {\\n    struct TierStorage {\\n        // It holds the total number of tiers.\\n        Counters.Counter tierCounter;\\n        // It holds the total number of tokens minted.\\n        Counters.Counter tokenCounter;\\n        // It holds the information about a tier.\\n        mapping(uint256 => Tier) tiers;\\n        // It holds which tier a token ID is in.\\n        mapping(uint256 => uint256) tokenTierMap;\\n    }\\n\\n    function tierStore() internal pure returns (TierStorage storage s) {\\n        bytes32 POSITION = keccak256(\\\"teller_nft.tier\\\");\\n\\n        assembly {\\n            s.slot := POSITION\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7a07327e0debd277688204fcfc16c3abf9608b5d538fcaa6095e684f6acc8a71\",\"license\":\"MIT\"},\"diamonds/domains/nft/storage/token.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nabstract contract sto_Token {\\n    bytes32 internal constant POSITION = keccak256(\\\"teller_nft.token\\\");\\n\\n    struct TokenStorage {\\n        // It holds a set of token IDs for an owner address.\\n        mapping(address => EnumerableSet.UintSet) ownerTokenIDs;\\n        // Link to the contract metadata\\n        string contractURI;\\n    }\\n\\n    function tokenStore() internal pure returns (TokenStorage storage s) {\\n        bytes32 position = POSITION;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfeb61db52732fd6187c59fc5f88e09c24c118a96520b912bb9f743996b1f2536\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061030f806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063938e3d7b14610030575b600080fd5b61004361003e3660046101de565b610045565b005b7fdf8b4c520ffe197c5343c6f5aec59570151ef9a492f2c624fd45ddde6135ec4233610071828261007f565b61007a83610118565b505050565b60008281527f337c29a31b05a860fb532911919dbe85ab303a7465176333f1deb496e9fdd19e602090815260408083206001600160a01b038516845290915290205460ff166101145760405162461bcd60e51b815260206004820152601b60248201527f416363657373436f6e74726f6c3a20756e617574686f72697a65640000000000604482015260640160405180910390fd5b5050565b8051610114907f7d831add1cfdac9c9a7c42498fe0e1d396f2a23a5826619aec75af6873a5888590602084019082805461015190610288565b90600052602060002090601f01602090048101928261017357600085556101b9565b82601f1061018c57805160ff19168380011785556101b9565b828001600101855582156101b9579182015b828111156101b957825182559160200191906001019061019e565b506101c59291506101c9565b5090565b5b808211156101c557600081556001016101ca565b6000602082840312156101ef578081fd5b813567ffffffffffffffff80821115610206578283fd5b818401915084601f830112610219578283fd5b81358181111561022b5761022b6102c3565b604051601f8201601f19908116603f01168101908382118183101715610253576102536102c3565b8160405282815287602084870101111561026b578586fd5b826020860160208301379182016020019490945295945050505050565b600181811c9082168061029c57607f821691505b602082108114156102bd57634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052604160045260246000fdfea2646970667358221220e2912232f5361ac0a2700822f33622b8bdd81b569108534af95ad66f3d69f16a64736f6c63430008030033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063938e3d7b14610030575b600080fd5b61004361003e3660046101de565b610045565b005b7fdf8b4c520ffe197c5343c6f5aec59570151ef9a492f2c624fd45ddde6135ec4233610071828261007f565b61007a83610118565b505050565b60008281527f337c29a31b05a860fb532911919dbe85ab303a7465176333f1deb496e9fdd19e602090815260408083206001600160a01b038516845290915290205460ff166101145760405162461bcd60e51b815260206004820152601b60248201527f416363657373436f6e74726f6c3a20756e617574686f72697a65640000000000604482015260640160405180910390fd5b5050565b8051610114907f7d831add1cfdac9c9a7c42498fe0e1d396f2a23a5826619aec75af6873a5888590602084019082805461015190610288565b90600052602060002090601f01602090048101928261017357600085556101b9565b82601f1061018c57805160ff19168380011785556101b9565b828001600101855582156101b9579182015b828111156101b957825182559160200191906001019061019e565b506101c59291506101c9565b5090565b5b808211156101c557600081556001016101ca565b6000602082840312156101ef578081fd5b813567ffffffffffffffff80821115610206578283fd5b818401915084601f830112610219578283fd5b81358181111561022b5761022b6102c3565b604051601f8201601f19908116603f01168101908382118183101715610253576102536102c3565b8160405282815287602084870101111561026b578586fd5b826020860160208301379182016020019490945295945050505050565b600181811c9082168061029c57607f821691505b602082108114156102bd57634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052604160045260246000fdfea2646970667358221220e2912232f5361ac0a2700822f33622b8bdd81b569108534af95ad66f3d69f16a64736f6c63430008030033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "setContractURI(string)": {
        "params": {
          "contractURI": "The link to the initial contract level metadata."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "setContractURI(string)": {
        "notice": "Sets the contract level metadata URI."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
