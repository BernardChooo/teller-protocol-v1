{
  "address": "0x015857A8D6D91525b25fE39dd1434a113f21b1eC",
  "abi": [
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "address",
          "name": "src",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "dst",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "aggregator",
          "type": "address"
        }
      ],
      "name": "add",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "src",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "dst",
          "type": "address"
        }
      ],
      "name": "aggregatorFor",
      "outputs": [
        {
          "internalType": "contract AggregatorV2V3Interface",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        }
      ],
      "name": "getTokensSupportedBy",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "implementationStored",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [],
      "name": "initialize",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        }
      ],
      "name": "isTokenSupported",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "src",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "dst",
          "type": "address"
        }
      ],
      "name": "latestAnswerFor",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "logicName",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "logicRegistry",
      "outputs": [
        {
          "internalType": "contract LogicVersionsRegistryInterface",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        }
      ],
      "name": "remove",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "address",
          "name": "src",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "dst",
          "type": "address"
        }
      ],
      "name": "remove",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "settings",
      "outputs": [
        {
          "internalType": "contract SettingsInterface",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "strictDynamic",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "upgradeProxyTo",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "src",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "dst",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "srcAmount",
          "type": "uint256"
        }
      ],
      "name": "valueFor",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xcc99f03952fa08250b7e2ccd30fa64c5d151f3a44eac6bb0d9d1b9ae28449468",
  "receipt": {
    "to": null,
    "from": "0xAFe87013dc96edE1E116a288D80FcaA0eFFE5fe5",
    "contractAddress": "0x015857A8D6D91525b25fE39dd1434a113f21b1eC",
    "transactionIndex": 0,
    "gasUsed": "1436743",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x28dc4cf27eab1531ea20757c3315d45a1f44040b5bf0a3f926cff2e087551c4c",
    "transactionHash": "0xcc99f03952fa08250b7e2ccd30fa64c5d151f3a44eac6bb0d9d1b9ae28449468",
    "logs": [],
    "blockNumber": 8298714,
    "cumulativeGasUsed": "1436743",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "3790d34ca1d72794863015ffe08f35de",
  "metadata": "{\"compiler\":{\"version\":\"0.5.17+commit.d19bba13\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"aggregatorFor\",\"outputs\":[{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokensSupportedBy\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementationStored\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"isTokenSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"latestAnswerFor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicName\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicRegistry\",\"outputs\":[{\"internalType\":\"contract LogicVersionsRegistryInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settings\",\"outputs\":[{\"internalType\":\"contract SettingsInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strictDynamic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeProxyTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"}],\"name\":\"valueFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"develop@teller.finance\",\"details\":\"It tries to find an aggregator using the token addresses supplied. If unable, it uses ETH as a pass through asset to construct a path conversion.\",\"methods\":{\"add(address,address,address)\":{\"params\":{\"aggregator\":\"Price aggregator address.\",\"dst\":\"Destination token address.\",\"src\":\"Source token address.\"}},\"aggregatorFor(address,address)\":{\"params\":{\"dst\":\"Destination token address.\",\"src\":\"Source token address.\"},\"return\":\"AggregatorV2V3Interface The Chainlink Aggregator address.bool whether or not the values from the Aggregator should be considered inverted.\"},\"isTokenSupported(address)\":{\"params\":{\"tokenAddress\":\"Token address to check support for.\"},\"return\":\"bool whether or not the token is supported.\"},\"latestAnswerFor(address,address)\":{\"details\":\"It tries to use ETH as a pass through asset if the direct pair is not supported.\",\"params\":{\"dst\":\"Destination token address.\",\"src\":\"Source token address.\"},\"return\":\"int256 The latest answer as given from Chainlink.\"},\"remove(address)\":{\"params\":{\"tokenAddress\":\"Token to remove all markets for.\"}},\"remove(address,address)\":{\"params\":{\"dst\":\"Destination token address.\",\"src\":\"Source token address.\"}},\"valueFor(address,address,uint256)\":{\"params\":{\"dst\":\"Destination token address.\",\"src\":\"Source token address.\",\"srcAmount\":\"Amount of the source token to convert into the destination token.\"},\"return\":\"uint256 Value of the source token amount in destination tokens.\"}}},\"userdoc\":{\"methods\":{\"add(address,address,address)\":{\"notice\":\"It allows for additional Chainlink Aggregators to be supported.\"},\"aggregatorFor(address,address)\":{\"notice\":\"It grabs the Chainlink Aggregator contract address for the token pair if it is supported.\"},\"initialize()\":{\"notice\":\"It initializes this ChainlinkAggregator instance.\"},\"isTokenSupported(address)\":{\"notice\":\"It checks if the token is supported.\"},\"latestAnswerFor(address,address)\":{\"notice\":\"It returns the price of the token pair as given from the Chainlink Aggregator.\"},\"remove(address)\":{\"notice\":\"It removes support for a Chainlink Aggregator.\"},\"remove(address,address)\":{\"notice\":\"It removes support for a Chainlink Aggregator pair.\"},\"valueFor(address,address,uint256)\":{\"notice\":\"It calculates the value of a token amount into another.\"}},\"notice\":\"This contract is used to fetch and calculate prices and values from one token to another through Chainlink Aggregators.\"}},\"settings\":{\"compilationTarget\":{\"contracts/providers/chainlink/ChainlinkAggregator.sol\":\"ChainlinkAggregator\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":true,\"yulDetails\":{\"stackAllocation\":true}},\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.5/interfaces/AggregatorInterface.sol\":{\"content\":\"pragma solidity >=0.5.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n  function latestRound() external view returns (uint256);\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\",\"keccak256\":\"0x64fa8b255860b1cf2661a2d87ca287c21479edf18673ca694a770b6498e2de39\"},\"@chainlink/contracts/src/v0.5/interfaces/AggregatorV2V3Interface.sol\":{\"content\":\"pragma solidity >=0.5.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\n/**\\n * @title The V2 & V3 Aggregator Interface\\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\\n * and v0.5 AggregatorV3Interface.sol.\\n */\\ninterface AggregatorV2V3Interface {\\n  //\\n  // V2 Interface:\\n  //\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n  function latestRound() external view returns (uint256);\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n\\n  //\\n  // V3 Interface:\\n  //\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\",\"keccak256\":\"0xacc87fdd0c5891084d0a2d801bb968d864f6bebacad14767a399b5b0ad3511f3\"},\"@chainlink/contracts/src/v0.5/interfaces/AggregatorV3Interface.sol\":{\"content\":\"pragma solidity >=0.5.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\",\"keccak256\":\"0x636b9f52b4ef5795c35a189a94e95a8f909ed1f7ef799e0218b71d97b3a780a0\"},\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0x640b6dee7a4b830bdfd52b5031a07fc2b12209f5b2e29e5d364a7d37f69d8076\"},\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is Initializable, IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\",\"keccak256\":\"0x704e0cb521f0b571096a72266a34d9a2a59a89853b5b271bc97fa307a4cc4dcc\"},\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xe5bb0f57cff3e299f360052ba50f1ea0fff046df2be070b6943e0e3c3fdad8a9\"},\"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\":{\"content\":\"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x1a8e5072509c5ea7365eb1d48030b9be865140c8fb779968da0a459a0e174a11\"},\"@openzeppelin/upgrades/contracts/Initializable.sol\":{\"content\":\"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\",\"keccak256\":\"0x9bfec92e36234ecc99b5d37230acb6cd1f99560233753162204104a4897e8721\"},\"contracts/base/Base.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\\\";\\n\\n// Commons\\n\\n// Interfaces\\nimport \\\"../interfaces/SettingsInterface.sol\\\";\\n\\n// Contracts\\nimport \\\"./upgradeable/DynamicUpgradeable.sol\\\";\\nimport \\\"./BaseStorage.sol\\\";\\n\\n/*****************************************************************************************************/\\n/**                                             WARNING                                             **/\\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\\n/**  ---------------------------------------------------------------------------------------------  **/\\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\\n/**  contract that this contract inherits from                                                      **/\\n/**                                                                                                 **/\\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\\n/**  more information.                                                                              **/\\n/*****************************************************************************************************/\\n/**\\n    @notice This contract is used as a base contract for most most of the contracts in the platform.\\n    @notice It allows contracts to have access to the platform settings, and common modifiers.\\n\\n    @author develop@teller.finance.\\n */\\ncontract Base is DynamicUpgradeable, BaseStorage {\\n    using AddressLib for address;\\n    using Address for address;\\n\\n    /** Modifiers */\\n\\n    /**\\n          @notice Checks if sender has a pauser role\\n          @dev Throws an error if the sender has not a pauser role.\\n       */\\n    modifier onlyPauser() {\\n        settings.requirePauserRole(msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyAuthorized() {\\n        settings.requireAuthorization(msg.sender);\\n        _;\\n    }\\n\\n    /**\\n    @notice Checks whether the platform is paused or not.\\n    @dev It throws a require error if platform is paused.\\n */\\n    modifier whenNotPaused() {\\n        require(!_isPaused(), \\\"PLATFORM_IS_PAUSED\\\");\\n        _;\\n    }\\n\\n    /**\\n        @notice Checks whether a specific lending pool address is paused or not.\\n        @dev It throws a require error if the lending pool is paused.\\n        @param lendingPoolAddress lending pool address to check.\\n     */\\n    modifier whenLendingPoolNotPaused(address lendingPoolAddress) {\\n        require(!_isPoolPaused(lendingPoolAddress), \\\"LENDING_POOL_IS_PAUSED\\\");\\n        _;\\n    }\\n\\n    /* Constructor */\\n\\n    /** External Functions */\\n\\n    /** Internal functions */\\n\\n    /**\\n        @notice It initializes the current contract instance setting the required parameters.\\n        @param settingsAddress settings contract address.\\n     */\\n    function _initialize(address settingsAddress) internal {\\n        settingsAddress.requireNotEmpty(\\\"SETTINGS_MUST_BE_PROVIDED\\\");\\n\\n        settings = SettingsInterface(settingsAddress);\\n    }\\n\\n    /**\\n        @notice Checks if a specific lending pool address is paused or not.\\n        @param poolAddress lending pool address to check.\\n        @return true if the lending pool address is  paused. Otherwise it returns false.\\n     */\\n    function _isPoolPaused(address poolAddress) internal view returns (bool) {\\n        return settings.lendingPoolPaused(poolAddress);\\n    }\\n\\n    /**\\n        @notice Checks if the platform is paused or not.\\n        @return true if platform is paused. Otherwise it returns false.\\n     */\\n    function _isPaused() internal view returns (bool) {\\n        return settings.isPaused();\\n    }\\n\\n    /** Private functions */\\n}\\n\",\"keccak256\":\"0xb24f5c05a5470ae264892d6b059a33c2043a7f7e72c0846d19b408682d09ac8d\"},\"contracts/base/BaseStorage.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Interfaces\\nimport \\\"../interfaces/SettingsInterface.sol\\\";\\n\\n// Contracts\\nimport \\\"./upgradeable/DynamicUpgradeableStorage.sol\\\";\\n\\n/*****************************************************************************************************/\\n/**                                             WARNING                                             **/\\n/**                        THIS CONTRACT IS A NON UPGRADEABLE STORAGE CONTRACT!                     **/\\n/**  ---------------------------------------------------------------------------------------------  **/\\n/**  Do NOT change the order of, PREPEND, or APPEND any storage variables to this or new versions   **/\\n/**  of this contract as this will cause a ripple affect to the storage slots of all child          **/\\n/**  contracts that inherit from this contract to be overwritten on the deployed proxy contract!!   **/\\n/**                                                                                                 **/\\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\\n/**  more information.                                                                              **/\\n/*****************************************************************************************************/\\n/**\\n * @notice This contract is used as the base storage contract for most of the contracts in the platform.\\n * @notice It allows contracts to have access to the platform settings instance.\\n *\\n * @author develop@teller.finance.\\n */\\ncontract BaseStorage is DynamicUpgradeableStorage {\\n    /**\\n     * @notice It holds the platform Settings instance.\\n     */\\n    SettingsInterface public settings;\\n\\n    /**\\n     * @notice This allocates additional storage slots in the event that additional state variables are added.\\n     */\\n    uint256[10] internal __gap;\\n}\\n\",\"keccak256\":\"0x8ee303c21aaaedc1daef3131403051e2bae1b56bd2378eb51a85fb24a91f6864\"},\"contracts/base/upgradeable/DynamicUpgradeable.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Contracts\\nimport \\\"./DynamicUpgradeableStorage.sol\\\";\\n\\n/*****************************************************************************************************/\\n/**                                             WARNING                                             **/\\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\\n/**  ---------------------------------------------------------------------------------------------  **/\\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\\n/**  contract that this contract inherits from                                                      **/\\n/**                                                                                                 **/\\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\\n/**  more information.                                                                              **/\\n/*****************************************************************************************************/\\n/**\\n * @notice This contract is used define the DynamicUpgradeable contracts logic.\\n *\\n * @author develop@teller.finance\\n */\\ncontract DynamicUpgradeable is DynamicUpgradeableStorage {\\n    /* External Functions */\\n\\n    function upgradeProxyTo(address newImplementation) public {\\n        require(msg.sender == address(logicRegistry), \\\"MUST_BE_LOGIC_REGISTRY\\\");\\n        implementationStored = newImplementation;\\n        _implementationBlockUpdated = block.number;\\n    }\\n\\n    /* Internal Functions **/\\n\\n    /**\\n     * @notice Returns the current implementation used by the proxy to delegate a call to.\\n     * @return address of the current implementation\\n     */\\n    function _implementation() internal view returns (address) {\\n        return implementationStored;\\n    }\\n\\n    /**\\n     * @notice Updates the current implementation logic address for the stored logic name.\\n     * @dev It uses the LogicVersionsRegistry contract to get the logic address or the cached address if valid.\\n     * @dev It caches the current logic address for the proxy to reduce gas on subsequent calls within the same block.\\n     */\\n    function _updateImplementationStored() internal {\\n        (, , address currentLogic) = logicRegistry.getLogicVersion(logicName);\\n\\n        if (implementationStored != currentLogic) {\\n            implementationStored = currentLogic;\\n        }\\n        _implementationBlockUpdated = block.number;\\n    }\\n\\n    /**\\n     * @notice It is called by the OZ proxy contract before calling the internal _implementation() function.\\n     */\\n    function _willFallback() internal {\\n        if (strictDynamic && _implementationBlockUpdated + 50 <= block.number) {\\n            _updateImplementationStored();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x187d73536e18c3cb563599aba5523ec746c8e507c2b49ca3df23a6db4657ff0b\"},\"contracts/base/upgradeable/DynamicUpgradeableStorage.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Interfaces\\nimport \\\"../../interfaces/LogicVersionsRegistryInterface.sol\\\";\\n\\n/*****************************************************************************************************/\\n/**                                             WARNING                                             **/\\n/**                        THIS CONTRACT IS A NON UPGRADEABLE STORAGE CONTRACT!                     **/\\n/**  ---------------------------------------------------------------------------------------------  **/\\n/**  Do NOT change the order of, PREPEND, or APPEND any storage variables to this or new versions   **/\\n/**  of this contract as this will cause a ripple affect to the storage slots of all child          **/\\n/**  contracts that inherit from this contract to be overwritten on the deployed proxy contract!!   **/\\n/**                                                                                                 **/\\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\\n/**  more information.                                                                              **/\\n/*****************************************************************************************************/\\n/**\\n    @notice This contract is used define the storage variables for all DynamicUpgradeable contracts.\\n\\n    @author develop@teller.finance\\n */\\ncontract DynamicUpgradeableStorage {\\n    /**\\n     * @notice It returns the logic registry that is used to determine the implementation logic for this proxy.\\n     * @dev See LogicVersionsRegistry contract.\\n     * @return LogicVersionsRegistryInterface\\n     */\\n    LogicVersionsRegistryInterface public logicRegistry;\\n\\n    /**\\n     * @notice It represent the logic name (key) used for this proxy.\\n     * @dev It is used by LogicVersionsRegistry to get the logic address for the given logic name.\\n     * @dev It must NOT change over time.\\n     * @return bytes32 the logic name.\\n     */\\n    bytes32 public logicName;\\n\\n    /**\\n     * @param strictDynamic Boolean indicating if the proxy must check the registry for a new implementation.\\n     */\\n    bool public strictDynamic;\\n\\n    /**\\n     * @notice It stores the last known logic address locally to reduce gas costs.\\n     */\\n    address public implementationStored;\\n\\n    /**\\n     * @notice It is the block number which the last time the proxy implementation was checked.\\n     */\\n    uint256 internal _implementationBlockUpdated;\\n}\\n\",\"keccak256\":\"0x41d7840d94fac9d313772d0add8654db2e256515070b7e1c516e1bf6819bc448\"},\"contracts/interfaces/AssetSettingsInterface.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../util/CacheLib.sol\\\";\\n\\n/**\\n    @notice This interface defines all function to manage the asset settings on the platform.\\n\\n    @author develop@teller.finance\\n */\\ninterface AssetSettingsInterface {\\n    /**\\n        @notice This event is emitted when a new asset settings is created.\\n        @param sender the transaction sender address.\\n        @param assetAddress the asset address used to create the settings.\\n        @param cTokenAddress cToken address to configure for the asset.\\n        @param maxLoanAmount max loan amount to configure for the asset.\\n     */\\n    event AssetSettingsCreated(\\n        address indexed sender,\\n        address indexed assetAddress,\\n        address cTokenAddress,\\n        uint256 maxLoanAmount\\n    );\\n\\n    /**\\n        @notice This event is emitted when an asset settings is removed.\\n        @param sender the transaction sender address.\\n        @param assetAddress the asset address used to remove the settings.\\n     */\\n    event AssetSettingsRemoved(\\n        address indexed sender,\\n        address indexed assetAddress\\n    );\\n\\n    /**\\n        @notice This event is emitted when an asset settings (address type) is updated.\\n        @param assetSettingName asset setting name updated.\\n        @param sender the transaction sender address.\\n        @param assetAddress the asset address used to update the asset settings.\\n        @param oldValue old value used for the asset setting.\\n        @param newValue the value updated.\\n     */\\n    event AssetSettingsAddressUpdated(\\n        bytes32 indexed assetSettingName,\\n        address indexed sender,\\n        address indexed assetAddress,\\n        address oldValue,\\n        address newValue\\n    );\\n\\n    /**\\n        @notice This event is emitted when an asset settings (uint256 type) is updated.\\n        @param assetSettingName asset setting name updated.\\n        @param sender the transaction sender address.\\n        @param assetAddress the asset address used to update the asset settings.\\n        @param oldValue old value used for the asset setting.\\n        @param newValue the value updated.\\n     */\\n    event AssetSettingsUintUpdated(\\n        bytes32 indexed assetSettingName,\\n        address indexed sender,\\n        address indexed assetAddress,\\n        uint256 oldValue,\\n        uint256 newValue\\n    );\\n\\n    //   function initialize(address settingsAddress) external;\\n    /**\\n        @notice It creates an asset with the given parameters.\\n        @param assetAddress asset address used to create the new setting.\\n        @param cTokenAddress cToken address used to configure the asset setting.\\n        @param maxLoanAmount the initial max loan amount.\\n        @param maxTVLAmount the initial max total value locked amount.\\n        @param maxDebtRatio the initial max debt ratio amount.\\n    */\\n    function createAssetSetting(\\n        address assetAddress,\\n        address cTokenAddress,\\n        uint256 maxLoanAmount,\\n        uint256 maxTVLAmount,\\n        uint256 maxDebtRatio\\n    ) external;\\n\\n    /**\\n     * @notice It checks if the settings have been initialized for an asset address.\\n     */\\n    function isInitialized(address assetAddress) external view returns (bool);\\n\\n    /**\\n        @notice It updates the cToken address associted with an asset.\\n        @param assetAddress asset address to configure.\\n        @param cTokenAddress the new cToken address to configure.\\n     */\\n    function updateCTokenAddress(address assetAddress, address cTokenAddress)\\n        external;\\n\\n    /**\\n        @notice It returns the cToken address associted with an asset.\\n        @param assetAddress asset address to get the associated cToken for.\\n        @return The associated cToken address\\n     */\\n    function getCTokenAddress(address assetAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n        @notice It updates the yearn vault address associted with an asset.\\n        @param assetAddress asset address to configure.\\n        @param yVaultAddress the new yVault address to configure.\\n     */\\n    function updateYVaultAddressSetting(\\n        address assetAddress,\\n        address yVaultAddress\\n    ) external;\\n\\n    /**\\n        @notice It returns the yearn vault address associted with an asset.\\n        @param assetAddress asset address to get the associated yearn vault address for.\\n        @return The address of the yearn vault.\\n     */\\n    function getYVaultAddress(address assetAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n     @notice It updates the aToken address associated with an asset.\\n     @param assetAddress asset address to configure.\\n     @param aTokenAddress the new aToken address to configure.\\n     */\\n    function updateATokenAddress(address assetAddress, address aTokenAddress)\\n        external;\\n\\n    /**\\n      @notice It returns the aToken address associated with an asset.\\n      @param assetAddress asset address to get the associated aToken for.\\n      @return The associated aToken address\\n      */\\n    function getATokenAddress(address assetAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n        @notice It updates the max loan amount for a given asset.\\n        @param assetAddress asset address used to update the max loan amount.\\n        @param newMaxLoanAmount the new max loan amount to set.\\n     */\\n    function updateMaxLoanAmount(address assetAddress, uint256 newMaxLoanAmount)\\n        external;\\n\\n    /**\\n        @notice Returns the max loan amount for a given asset.\\n        @param assetAddress asset address to retrieve the max loan amount.\\n     */\\n    function getMaxLoanAmount(address assetAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n        @notice Tests whether a given amount is greater than the current max loan amount.\\n        @param assetAddress asset address used to return the max loan amount setting.\\n        @param amount the loan amount to check.\\n        @return true if the given amount is greater than the current max loan amount. Otherwise it returns false.\\n     */\\n    function exceedsMaxLoanAmount(address assetAddress, uint256 amount)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n        @notice It updates the max total vaule locked amount for a given asset.\\n        @param assetAddress asset address used to update the max loan amount.\\n        @param newMaxTVLAmount the new max total vault locked amount to set.\\n     */\\n    function updateMaxTVL(address assetAddress, uint256 newMaxTVLAmount)\\n        external;\\n\\n    /**\\n        @notice Returns the max total value locked amount for a given asset.\\n        @param assetAddress asset address to retrieve the max total value locked amount.\\n     */\\n    function getMaxTVLAmount(address assetAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n    @notice It updates the max debt ratio for a given asset.\\n    @dev The ratio value has 2 decimal places. I.e 100 = 1%\\n    @param assetAddress asset address used to update the max debt ratio.\\n    @param newMaxDebtRatio the new max debt ratio to set.\\n    */\\n    function updateMaxDebtRatio(address assetAddress, uint256 newMaxDebtRatio)\\n        external;\\n\\n    /**\\n    @notice Returns the max debt ratio for a given asset.\\n    @dev The ratio value has 2 decimal places. I.e 100 = 1%\\n    @param assetAddress asset address to retrieve the max debt ratio.\\n    */\\n    function getMaxDebtRatio(address assetAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n        @notice It removes a configuration for a given asset on the platform.\\n        @param assetAddress asset address to remove.\\n     */\\n    function removeAsset(address assetAddress) external;\\n\\n    function initialize() external;\\n}\\n\",\"keccak256\":\"0xb3c0d3b1d0d8bbee288a96839d5ba1748f9a8991853e667e1a79aa0d42fdecb1\"},\"contracts/interfaces/IDappRegistry.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../util/TellerCommon.sol\\\";\\n\\n/**\\n    @notice This interface defines the functions to manage the Escrow contracts associated to borrowers and loans.\\n\\n    @author develop@teller.finance\\n */\\ninterface IDappRegistry {\\n    /**\\n        @notice It gets a dapp configuration based on its contract address.\\n        @param dapp dapp address.\\n        @return TellerCommon.Dapp dapp configuration.\\n     */\\n    function dapps(address dapp)\\n        external\\n        view\\n        returns (TellerCommon.Dapp memory);\\n\\n    /**\\n        @notice It adds a new dapp to the factory.\\n        @param dapp address to add in this factory.\\n        @param unsecured boolean to describe if the dapp is allowed to be used with unsecured loans.\\n     */\\n    function addDapp(address dapp, bool unsecured) external;\\n\\n    /**\\n        @notice It updates a dapp configuration.\\n        @param dapp address to add in this factory.\\n        @param unsecured boolean that describes if the dapp can be used by with an unsecured loan.\\n     */\\n    function updateDapp(address dapp, bool unsecured) external;\\n\\n    /**\\n        @notice It removes a current dapp from the factory.\\n        @param dapp address to remove.\\n     */\\n    function removeDapp(address dapp) external;\\n\\n    /**\\n        @notice Gets all the dapps in the factory.\\n        @return an array of dapps (addresses).\\n     */\\n    function getDapps() external view returns (address[] memory);\\n\\n    /**\\n        @notice It initializes this escrow contract factory instance.\\n     */\\n    function initialize() external;\\n\\n    /**\\n        @notice This event is emitted when a new Escrow contract is created.\\n        @param borrower address associated to the new escrow.\\n        @param loansAddress loan manager contract address.\\n        @param loanID loan id associated to the borrower and escrow contract.\\n        @param escrowAddress the new escrow contract address.\\n     */\\n    event EscrowCreated(\\n        address indexed borrower,\\n        address indexed loansAddress,\\n        uint256 indexed loanID,\\n        address escrowAddress\\n    );\\n\\n    /**\\n        @notice This event is emitted when a new dapp is added to the factory.\\n        @param sender address.\\n        @param dapp address added to the factory.\\n        @param unsecured boolean that describes if the dapp can be used by with an unsecured loan.\\n     */\\n    event NewDappAdded(\\n        address indexed sender,\\n        address indexed dapp,\\n        bool unsecured\\n    );\\n\\n    /**\\n        @notice This event is emitted when a dapp is updated.\\n        @param sender address.\\n        @param dapp address of dapp contract.\\n        @param unsecured boolean that describes if the dapp can be used by with an unsecured loan.\\n     */\\n    event DappUpdated(\\n        address indexed sender,\\n        address indexed dapp,\\n        bool unsecured\\n    );\\n\\n    /**\\n        @notice This event is emitted when a current dapp is removed from the factory.\\n        @param sender address.\\n        @param dapp address removed from the factory.\\n     */\\n    event DappRemoved(address indexed sender, address indexed dapp);\\n}\\n\",\"keccak256\":\"0x7884516cf2e99022dc8c1529baa0e14f59ff4aae0c9b193fbd05a8900d25e5bb\"},\"contracts/interfaces/IMarketFactory.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../util/TellerCommon.sol\\\";\\nimport \\\"./IMarketRegistry.sol\\\";\\n\\n/**\\n    @notice\\n\\n    @author develop@teller.finance\\n */\\n\\ninterface IMarketFactory {\\n    /** External Functions */\\n\\n    function marketRegistry() external returns (IMarketRegistry);\\n\\n    function createMarket(address lendingToken, address collateralToken)\\n        external;\\n\\n    function initialize() external;\\n\\n    /** Events */\\n\\n    event NewMarketCreated(\\n        address indexed sender,\\n        address indexed lendingToken,\\n        address indexed collateralToken,\\n        address loans,\\n        address lendingPool\\n    );\\n}\\n\",\"keccak256\":\"0xe91226faf677383caa881c9b4fa19aca1136fa7e0ff73b7d946cd0f97f5060cf\"},\"contracts/interfaces/IMarketRegistry.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n// Utils\\nimport \\\"../util/AddressArrayLib.sol\\\";\\n\\n// Interfaces\\nimport \\\"./LendingPoolInterface.sol\\\";\\nimport \\\"./loans/ILoanManager.sol\\\";\\n\\n/**\\n    @notice It defines all the functions for the TToken registry\\n\\n    @author develop@teller.finance\\n */\\n\\ninterface IMarketRegistry {\\n    /**\\n        @notice It fetches an array of collateral tokens that a given lending token supports.\\n        @param lendingTokenAddress a token that the protocol lends.\\n        @return an array of collateral tokens supported by the lending token market.\\n     */\\n    function getMarkets(address lendingTokenAddress)\\n        external\\n        view\\n        returns (address[] memory);\\n\\n    /**\\n        @notice It maps a lending token to the associated LendingPool contract.\\n        @param lendingTokenAddress the lending token used in a LendingPool.\\n        @return the LendingPool contract for the given token.\\n     */\\n    function lendingPools(address lendingTokenAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n        @notice It maps a lending token and collateral token to the associated LoanManager contract.\\n        @param lendingTokenAddress a token the protocol lends out.\\n        @param collateralTokenAddress a token that is used as collateral.\\n        @return the Loans contract for the given token pair.\\n     */\\n    function loanManagers(\\n        address lendingTokenAddress,\\n        address collateralTokenAddress\\n    ) external view returns (address);\\n\\n    /**\\n        @notice It represents a mapping to identify a LendingPool's LoanManager contract address.\\n        @param lendingPoolAddress a LendingPool contract.\\n        @param loanManagerAddress a Loans contract.\\n        @return true if the Loans contract address is registered to the LendingPool contract.\\n     */\\n    function loanManagerRegistry(\\n        address lendingPoolAddress,\\n        address loanManagerAddress\\n    ) external view returns (bool);\\n\\n    /**\\n        @notice It registers a new market with a LendingPool and Loans contract pair.\\n        @param lendingPoolAddress a lending pool contract used to borrow assets.\\n        @param loanManagerAddress a loan manager contract that stores all the relevant loans info and functionality.\\n     */\\n    function registerMarket(\\n        address lendingPoolAddress,\\n        address loanManagerAddress\\n    ) external;\\n\\n    /**\\n        @notice It checks if a market already exists.\\n        @param lendingTokenAddress The lending token address.\\n        @param collateralTokenAddress The collateral token address.\\n     */\\n    function marketExists(\\n        address lendingTokenAddress,\\n        address collateralTokenAddress\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice It initializes the MarketRegistry contract by setting the owner of the caller.\\n     * @dev This contract is constructed and initialized by the MarketFactory.\\n     */\\n    function initialize() external;\\n}\\n\",\"keccak256\":\"0x0e05afdd9c13c1f9d0674f4c752b523b0c20f718a3875ca6544377ee0dc5c954\"},\"contracts/interfaces/ITToken.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Interfaces\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./LendingPoolInterface.sol\\\";\\n\\n/**\\n    @notice This contract acts as an interface for the Teller token (TToken).\\n\\n    @author develop@teller.finance\\n */\\ncontract ITToken is IERC20 {\\n    /**\\n     * @notice The LendingPool linked to this Teller Token.\\n     */\\n    function lendingPool() external view returns (LendingPoolInterface);\\n\\n    /**\\n     * @notice The token that is the underlying assets for this Teller token.\\n     */\\n    function underlying() external view returns (address);\\n\\n    /**\\n     * @notice Increase account supply of specified token amount.\\n     * @param account The account to mint tokens to.\\n     * @param amount The amount of tokens to mint.\\n     * @return true if successful.\\n     */\\n    function mint(address account, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice Reduce account supply of specified token amount.\\n     * @param account The account to burn tokens from.\\n     * @param amount The amount of tokens to burn.\\n     * @return true if successful.\\n     */\\n    function burn(address account, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @param lendingPoolAddress the address of the lending pool this token is linked to. It is only used to add it as a minter.\\n     */\\n    function initialize(address lendingPoolAddress) external;\\n}\\n\",\"keccak256\":\"0x76df326806616879ae9f06ce801dc9e800eba74a50b735bbb295618fe1c5d670\"},\"contracts/interfaces/LendingPoolInterface.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Utils\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\\\";\\n\\n// Interfaces\\nimport \\\"./IMarketRegistry.sol\\\";\\nimport \\\"./ITToken.sol\\\";\\nimport \\\"../providers/compound/CErc20Interface.sol\\\";\\n\\n/**\\n    @notice This interface defines the functions for a lending pool that holds all of the tokens\\n    that lenders transfer into the protocol.\\n\\n    @author develop@teller.finance\\n */\\ninterface LendingPoolInterface {\\n    /**\\n        @notice It allows users to deposit tokens into the pool.\\n        @dev the user must call ERC20.approve function previously.\\n        @param amount of tokens to deposit in the pool.\\n    */\\n    function deposit(uint256 amount) external;\\n\\n    /**\\n        @notice It allows any tToken holder to burn their tToken tokens and withdraw their tokens.\\n        @param amount of tokens to withdraw.\\n        @dev It throws a require error if the contract hasn't enough tokens balance.\\n        @dev It throws a require error if the holder hasn't enough tToken balance.\\n     */\\n    function withdraw(uint256 amount) external;\\n\\n    /**\\n        @notice It allows a borrower repaying their loan.\\n        @dev This function can be called ONLY by the LoanManager contract.\\n        @dev It requires a ERC20.approve call before calling it.\\n        @dev It throws a require error if borrower called ERC20.approve function before calling it.\\n        @param principalAmount amount of tokens towards the principal.\\n        @param interestAmount amount of tokens towards the interest.\\n        @param borrower address that is repaying the loan.\\n     */\\n    function repay(\\n        uint256 principalAmount,\\n        uint256 interestAmount,\\n        address borrower\\n    ) external;\\n\\n    /**\\n        @notice Once the loan is created, it transfers the amount of tokens to the borrower.\\n        @param amount of tokens to transfer.\\n        @param borrower address which will receive the tokens.\\n        @dev This function only can be invoked by the LoanManager implementation.\\n        @dev It throws a require error if current ERC20 balance isn't enough to transfer the tokens.\\n     */\\n    function createLoan(uint256 amount, address borrower) external;\\n\\n    /**\\n        @notice It gets the lending token address.\\n        @return the ERC20 lending token address.\\n    */\\n    function lendingToken() external view returns (ERC20Detailed);\\n\\n    /**\\n        @notice It initializes the contract state variables.\\n        @param aMarketRegistry the MarketRegistry contract.\\n        @param aLendingToken The underlying token that is used for lending.\\n        @param aTToken the Teller token to link to the lending pool.\\n        @param settingsAddress Settings contract address.\\n        @dev It throws a require error if the contract is already initialized.\\n     */\\n    function initialize(\\n        IMarketRegistry aMarketRegistry,\\n        address aLendingToken,\\n        address aTToken,\\n        address settingsAddress\\n    ) external;\\n\\n    /**\\n        @notice It gets the cToken address.\\n        @return the cToken address.\\n    */\\n    function cToken() external view returns (CErc20Interface);\\n\\n    /**\\n        @notice It gets the tToken address.\\n        @return the tToken address.\\n    */\\n    function tToken() external view returns (ITToken);\\n\\n    /**\\n        @notice It returns the balance of underlying tokens a lender owns with the amount\\n        of TTokens owned and the current exchange rate.\\n        @return a lender's balance of the underlying token in the pool.\\n     */\\n    function balanceOfUnderlying(address lender) external returns (uint256);\\n\\n    /**\\n        @notice Returns the total amount of interest earned by a lender.\\n        @dev This value includes already claimed + unclaimed interest earned.\\n        @return total interest earned by lender.\\n     */\\n    function getLenderInterestEarned(address lender) external returns (uint256);\\n\\n    /**\\n        @notice Returns the amount of claimable interest a lender has earned.\\n        @return claimable interest value.\\n     */\\n    function getClaimableInterestEarned(address lender)\\n        external\\n        returns (uint256);\\n\\n    /**\\n        @notice Returns the total amount of interest the pool has earned from repaying loans.\\n        @return total interest earned from loans.\\n     */\\n    function totalInterestEarned() external view returns (uint256);\\n\\n    /**\\n        @notice It calculates the market state values across all markets.\\n        @return values that represent the global state across all markets.\\n     */\\n    function getMarketState()\\n        external\\n        view\\n        returns (\\n            uint256 totalSupplied,\\n            uint256 totalBorrowed,\\n            uint256 totalRepaid,\\n            uint256 totalOnLoan\\n        );\\n\\n    /**\\n        @notice It gets the debt-to-supply (DtS) ratio for a given market, including a new loan amount.\\n        @notice The formula to calculate DtS ratio (including a new loan amount) is:\\n\\n            DtS = (SUM(total borrowed) - SUM(total repaid) + NewLoanAmount) / SUM(total supplied)\\n\\n        @notice The value has 2 decimal places.\\n            Example:\\n                100 => 1%\\n        @param loanAmount a new loan amount to consider in the ratio.\\n        @return the debt-to-supply ratio value.\\n     */\\n    function getDebtRatioFor(uint256 loanAmount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n        @notice This event is emitted when an user deposits tokens into the pool.\\n        @param sender address.\\n        @param amount of tokens.\\n     */\\n    event TokenDeposited(\\n        address indexed sender,\\n        uint256 amount,\\n        uint256 tTokenAmount\\n    );\\n\\n    /**\\n        @notice This event is emitted when an user withdraws tokens from the pool.\\n        @param sender address that withdrew the tokens.\\n        @param amount of tokens.\\n     */\\n    event TokenWithdrawn(\\n        address indexed sender,\\n        uint256 amount,\\n        uint256 tTokenAmount\\n    );\\n\\n    /**\\n        @notice This event is emitted when an borrower repaid a loan.\\n        @param borrower address.\\n        @param amount of tokens.\\n     */\\n    event TokenRepaid(address indexed borrower, uint256 amount);\\n\\n    /**\\n        @notice This event is emitted when an lender withdraws interests.\\n        @param lender address.\\n        @param amount of tokens.\\n     */\\n    event InterestWithdrawn(address indexed lender, uint256 amount);\\n\\n    /**\\n        @notice This event is emitted when the interest validator is updated.\\n        @param sender account that sends the transaction.\\n        @param oldInterestValidator the old validator address.\\n        @param newInterestValidator the new validator address.\\n     */\\n    event InterestValidatorUpdated(\\n        address indexed sender,\\n        address indexed oldInterestValidator,\\n        address indexed newInterestValidator\\n    );\\n}\\n\",\"keccak256\":\"0x39b1adda7725d55a0e96be437f39508fd9cdb9c68bcd0726eba222e03b0b0d4f\"},\"contracts/interfaces/LogicVersionsRegistryInterface.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Commons\\nimport \\\"../util/LogicVersionLib.sol\\\";\\nimport \\\"../util/TellerCommon.sol\\\";\\n\\n/**\\n    @notice It defines all the functions to manage the logic contract versions.\\n\\n    @author develop@teller.finance\\n */\\ninterface LogicVersionsRegistryInterface {\\n    /**\\n        @notice This event is emitted when a new logic version is created.\\n        @param logicName new logic name.\\n        @param logic address where the logic is.\\n        @param version initial version for the logic address.\\n     */\\n    event LogicVersionCreated(\\n        bytes32 indexed logicName,\\n        address indexed logic,\\n        uint256 version\\n    );\\n\\n    /**\\n        @notice This event is emitted when a logic version is rollbacked.\\n        @param logicName the logic name.\\n        @param oldLogic the old logic address.\\n        @param newLogic the new (or previous) logic address.\\n        @param oldVersion the old version.\\n        @param newVersion the new (previous) version.\\n     */\\n    event LogicVersionRollbacked(\\n        bytes32 indexed logicName,\\n        address oldLogic,\\n        address newLogic,\\n        uint256 oldVersion,\\n        uint256 newVersion\\n    );\\n\\n    /**\\n        @notice This event is emitted when a new logic version is upgraded.\\n        @param logicName new logic name.\\n        @param oldLogic the old logic address.\\n        @param newLogic the new logic address.\\n        @param oldVersion the old version.\\n        @param newVersion the new version.\\n     */\\n    event LogicVersionUpgraded(\\n        bytes32 indexed logicName,\\n        address oldLogic,\\n        address newLogic,\\n        uint256 oldVersion,\\n        uint256 newVersion\\n    );\\n\\n    /** External Functions */\\n\\n    /**\\n        @notice It creates multiple logic versions.\\n        @param newLogicVersions lists of the new logic versions to create.\\n     */\\n    function createLogicVersions(\\n        TellerCommon.CreateLogicVersionRequest[] calldata newLogicVersions\\n    ) external;\\n\\n    /**\\n        @notice It upgrades multiple logic addresses.\\n        @param newLogicVersions lists of the new logic versions to create.\\n     */\\n    function upgradeLogicVersions(\\n        TellerCommon.UpgradeLogicVersionRequest[] calldata newLogicVersions\\n    ) external;\\n\\n    /**\\n        @notice It upgrades a logic version given a logic name.\\n        @param logicName logic name to upgrade.\\n        @param newLogic the new logic address to set.\\n        @param proxy The (optional) DynamicUpgradeable proxy address to attempt to directly upgrade.\\n     */\\n    function upgradeLogicVersion(\\n        bytes32 logicName,\\n        address newLogic,\\n        address proxy\\n    ) external;\\n\\n    /**\\n        @notice It rollbacks a logic to a previous version.\\n        @param logicName logic name to rollback.\\n        @param previousVersion the previous version to be used.\\n     */\\n    function rollbackLogicVersion(bytes32 logicName, uint256 previousVersion)\\n        external;\\n\\n    /**\\n        @notice It gets the current logic version for a given logic name.\\n        @param logicName to get.\\n        @return the current logic version.\\n     */\\n    function getLogicVersion(bytes32 logicName)\\n        external\\n        view\\n        returns (\\n            uint256 currentVersion,\\n            uint256 latestVersion,\\n            address logic\\n        );\\n\\n    /**\\n        @notice It tests whether a logic name is already configured.\\n        @param logicName logic name to test.\\n        @return true if the logic version is already configured. Otherwise it returns false.\\n     */\\n    function hasLogicVersion(bytes32 logicName) external view returns (bool);\\n\\n    /**\\n        @notice It initializes this logic versions registry contract instance.\\n        @param aOwner address of the owner of the registry.\\n        @param initialLogicVersions lists of the new logic versions to create.\\n     */\\n    function initialize(\\n        address aOwner,\\n        TellerCommon.CreateLogicVersionRequest[] calldata initialLogicVersions\\n    ) external;\\n}\\n\",\"keccak256\":\"0x7e5eca5bb178277eefa1b09e8a53741fbdddf486ad9805f040ef87aa5b3d0fb0\"},\"contracts/interfaces/SettingsInterface.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../util/PlatformSettingsLib.sol\\\";\\nimport \\\"./IDappRegistry.sol\\\";\\nimport \\\"../providers/chainlink/IChainlinkAggregator.sol\\\";\\nimport \\\"../interfaces/AssetSettingsInterface.sol\\\";\\nimport \\\"./IMarketFactory.sol\\\";\\n\\n/**\\n    @notice This interface defines all function to manage the platform configuration.\\n\\n    @author develop@teller.finance\\n */\\ninterface SettingsInterface {\\n    /**\\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\\n     */\\n    event Unpaused(address account);\\n\\n    event PauserAdded(address indexed account);\\n    event PauserRemoved(address indexed account);\\n\\n    /**\\n        @notice This event is emitted when a new platform setting is created.\\n        @param settingName new setting name.\\n        @param sender address that created it.\\n        @param value value for the new setting.\\n     */\\n    event PlatformSettingCreated(\\n        bytes32 indexed settingName,\\n        address indexed sender,\\n        uint256 value,\\n        uint256 minValue,\\n        uint256 maxValue\\n    );\\n\\n    /**\\n        @notice This event is emitted when a current platform setting is removed.\\n        @param settingName setting name removed.\\n        @param sender address that removed it.\\n     */\\n    event PlatformSettingRemoved(\\n        bytes32 indexed settingName,\\n        uint256 lastValue,\\n        address indexed sender\\n    );\\n\\n    /**\\n        @notice This event is emitted when a platform setting is updated.\\n        @param settingName settings name updated.\\n        @param sender address that updated it.\\n        @param oldValue old value for the setting.\\n        @param newValue new value for the setting.\\n     */\\n    event PlatformSettingUpdated(\\n        bytes32 indexed settingName,\\n        address indexed sender,\\n        uint256 oldValue,\\n        uint256 newValue\\n    );\\n\\n    /**\\n        @notice This event is emitted when a lending pool is paused.\\n        @param account address that paused the lending pool.\\n        @param lendingPoolAddress lending pool address which was paused.\\n     */\\n    event LendingPoolPaused(\\n        address indexed account,\\n        address indexed lendingPoolAddress\\n    );\\n\\n    /**\\n        @notice This event is emitted when a lending pool is unpaused.\\n        @param account address that paused the lending pool.\\n        @param lendingPoolAddress lending pool address which was unpaused.\\n     */\\n    event LendingPoolUnpaused(\\n        address indexed account,\\n        address indexed lendingPoolAddress\\n    );\\n\\n    /**\\n        @notice This event is emitted when the platform restriction is switched\\n        @param restriction Boolean representing the state of the restriction\\n        @param pauser address of the pauser flipping the switch\\n    */\\n    event PlatformRestricted(bool restriction, address indexed pauser);\\n\\n    /**\\n        @notice This event is emitted when an address is given authorization\\n        @param user The address being authorized\\n        @param pauser address of the pauser adding the address\\n    */\\n    event AuthorizationGranted(address indexed user, address indexed pauser);\\n\\n    /**\\n        @notice This event is emitted when an address has authorization revoked\\n        @param user The address being revoked\\n        @param pauser address of the pauser removing the address\\n    */\\n    event AuthorizationRevoked(address indexed user, address indexed pauser);\\n\\n    /**\\n        @notice It creates a new platform setting given a setting name, value, min and max values.\\n        @param settingName setting name to create.\\n        @param value the initial value for the given setting name.\\n        @param minValue the min value for the setting.\\n        @param maxValue the max value for the setting.\\n     */\\n    function createPlatformSetting(\\n        bytes32 settingName,\\n        uint256 value,\\n        uint256 minValue,\\n        uint256 maxValue\\n    ) external;\\n\\n    function assetSettings() external view returns (AssetSettingsInterface);\\n\\n    /**\\n     * @notice It holds the address of a deployed InitializeableDynamicProxy contract.\\n     * @dev It is used to deploy a new proxy contract with minimal gas cost using the logic in the Factory contract.\\n     */\\n    function initDynamicProxyLogic() external view returns (address);\\n\\n    /**\\n        @notice It updates an existent platform setting given a setting name.\\n        @notice It only allows to update the value (not the min or max values).\\n        @notice In case you need to update the min or max values, you need to remove it, and create it again.\\n        @param settingName setting name to update.\\n        @param newValue the new value to set.\\n     */\\n    function updatePlatformSetting(bytes32 settingName, uint256 newValue)\\n        external;\\n\\n    /**\\n        @notice Removes a current platform setting given a setting name.\\n        @param settingName to remove.\\n     */\\n    function removePlatformSetting(bytes32 settingName) external;\\n\\n    /**\\n        @notice It gets the current \\\"RequiredSubmissionsPercentage\\\" setting's value\\n        @return the current value.\\n     */\\n    function getRequiredSubmissionsPercentageValue()\\n        external\\n        view\\n        returns (uint256 value);\\n\\n    /**\\n        @notice It gets the current \\\"MaximumTolerance\\\" setting's value\\n        @return the current value.\\n     */\\n    function getMaximumToleranceValue() external view returns (uint256 value);\\n\\n    /**\\n        @notice It gets the current \\\"ResponseExpiryLength\\\" setting's value\\n        @return the current value.\\n     */\\n    function getResponseExpiryLengthValue()\\n        external\\n        view\\n        returns (uint256 value);\\n\\n    /**\\n        @notice It gets the current \\\"SafetyInterval\\\" setting's value\\n        @return the current value.\\n     */\\n    function getSafetyIntervalValue() external view returns (uint256 value);\\n\\n    /**\\n        @notice It gets the current \\\"TermsExpiryTime\\\" setting's value\\n        @return the current value.\\n     */\\n    function getTermsExpiryTimeValue() external view returns (uint256 value);\\n\\n    /**\\n        @notice It gets the current \\\"LiquidateEthPrice\\\" setting's value\\n        @return the current value.\\n     */\\n    function getLiquidateEthPriceValue() external view returns (uint256 value);\\n\\n    /**\\n        @notice It gets the current \\\"MaximumLoanDuration\\\" setting's value\\n        @return the current value.\\n     */\\n    function getMaximumLoanDurationValue()\\n        external\\n        view\\n        returns (uint256 value);\\n\\n    /**\\n        @notice It gets the current \\\"RequestLoanTermsRateLimit\\\" setting's value\\n        @return the current value.\\n     */\\n    function getRequestLoanTermsRateLimitValue()\\n        external\\n        view\\n        returns (uint256 value);\\n\\n    /**\\n        @notice It gets the current \\\"CollateralBuffer\\\" setting's value\\n        @return the current value.\\n     */\\n    function getCollateralBufferValue() external view returns (uint256 value);\\n\\n    /**\\n        @notice It gets the current \\\"OverCollateralizedBuffer\\\" setting's value\\n        @return the current value.\\n     */\\n    function getOverCollateralizedBufferValue()\\n        external\\n        view\\n        returns (uint256 value);\\n\\n    /**\\n        @notice It tests whether a setting name is already configured.\\n        @param settingName setting name to test.\\n        @return true if the setting is already configured. Otherwise it returns false.\\n     */\\n    function hasPlatformSetting(bytes32 settingName)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n        @notice It gets whether the platform is paused or not.\\n        @return true if platform is paused. Otherwise it returns false.\\n     */\\n    function isPaused() external view returns (bool);\\n\\n    /**\\n        @notice It gets whether a lending pool is paused or not.\\n        @param lendingPoolAddress lending pool address to test.\\n        @return true if the lending pool is paused. Otherwise it returns false.\\n     */\\n    function lendingPoolPaused(address lendingPoolAddress)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n        @notice It pauses a specific lending pool.\\n        @param lendingPoolAddress lending pool address to pause.\\n     */\\n    function pauseLendingPool(address lendingPoolAddress) external;\\n\\n    /**\\n        @notice It unpauses a specific lending pool.\\n        @param lendingPoolAddress lending pool address to unpause.\\n     */\\n    function unpauseLendingPool(address lendingPoolAddress) external;\\n\\n    function platformSettings(bytes32)\\n        external\\n        view\\n        returns (PlatformSettingsLib.PlatformSetting memory);\\n\\n    /**\\n        @notice Tests whether an account has the pauser role.\\n        @param account account to test.\\n        @return true if account has the pauser role. Otherwise it returns false.\\n     */\\n    function isPauser(address account) external view returns (bool);\\n\\n    /**\\n        @notice Requires an account to have the pauser role.\\n        @param account account to test.\\n     */\\n    function requirePauserRole(address account) external view;\\n\\n    /**\\n        @notice Restricts the use of the Teller protocol to authorized wallet addresses only\\n        @param restriction Bool turning the resitriction on or off\\n     */\\n    function restrictPlatform(bool restriction) external;\\n\\n    /**\\n        @notice Adds a wallet address to the list of authorized wallets\\n        @param addressToAdd The wallet address of the user being authorized\\n     */\\n    function addAuthorizedAddress(address addressToAdd) external;\\n\\n    /**\\n        @notice Adds a list of wallet addresses to the list of authorized wallets\\n        @param addressesToAdd The list of wallet addresses being authorized\\n     */\\n    function addAuthorizedAddressList(address[] calldata addressesToAdd)\\n        external;\\n\\n    function addEscrowAuthorized(address escrowAddress) external;\\n\\n    /**\\n        @notice Returns whether the platform is restricted or not\\n        @return bool True if the platform is restricted, false if not\\n     */\\n    function isPlatformRestricted() external view returns (bool);\\n\\n    /**\\n        @notice Tests whether an account has authorization\\n        @param account The account address to check for\\n        @return True if account has authorization, false if it does not\\n     */\\n    function hasAuthorization(address account) external view returns (bool);\\n\\n    /**\\n        @notice Requires an account to have platform authorization.\\n        @param account account to test.\\n     */\\n    function requireAuthorization(address account) external view;\\n\\n    /**\\n        @notice Removes a wallet address from the list of authorized wallets\\n        @param addressToRemove The wallet address of the user being unauthorized\\n     */\\n    function removeAuthorizedAddress(address addressToRemove) external;\\n\\n    /**\\n        @notice It is the global instance of the DappRegistry contract.\\n     */\\n    function dappRegistry() external view returns (IDappRegistry);\\n\\n    /**\\n        @notice It is the global instance of the ChainlinkAggregator contract.\\n     */\\n    function chainlinkAggregator() external view returns (IChainlinkAggregator);\\n\\n    /**\\n        @notice It is the global instance of the MarketFactory contract.\\n     */\\n    function marketFactory() external view returns (IMarketFactory);\\n\\n    /**\\n        @notice Gets the cToken address for a given asset address.\\n        @param assetAddress token address.\\n        @return the cToken address for a given asset address.\\n     */\\n    function getCTokenAddress(address assetAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n        @notice It initializes this settings contract instance.\\n        @param wethTokenAddress canonical WETH token address.\\n        @param cethTokenAddress compound CETH token address.\\n        @param initDynamicProxyAddress Address of a deployed InitializeableDynamicProxy contract.\\n     */\\n    function initialize(\\n        address wethTokenAddress,\\n        address cethTokenAddress,\\n        address initDynamicProxyAddress\\n    ) external;\\n\\n    /**\\n        @notice It gets the ETH address used in the platform.\\n        @return the ETH address used in the platform.\\n     */\\n    function ETH_ADDRESS() external view returns (address);\\n\\n    /**\\n        @notice It gets the canonical WETH address used in the platform.\\n        @return the canonical WETH address used in the platform.\\n     */\\n    function WETH_ADDRESS() external view returns (address);\\n\\n    /**\\n        @notice It gets the canonical CETH address used in the platform.\\n        @return the canonical CETH address used in the platform.\\n     */\\n    function CETH_ADDRESS() external view returns (address);\\n}\\n\",\"keccak256\":\"0x912ee57e48fb005b8a983123e8cfebd4bbb6181e1c47a9bce14a39dfd1f11071\"},\"contracts/interfaces/loans/ILoanData.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Commons\\nimport \\\"../../util/TellerCommon.sol\\\";\\n\\n// Interfaces\\nimport \\\"./ILoanStorage.sol\\\";\\nimport \\\"./ILoanTermsConsensus.sol\\\";\\nimport \\\"../SettingsInterface.sol\\\";\\nimport \\\"../LendingPoolInterface.sol\\\";\\nimport \\\"../../providers/compound/CErc20Interface.sol\\\";\\n\\n/**\\n * @notice This interface defines the functions to get and calculate information about loan data.\\n *\\n * @author develop@teller.finance\\n */\\ncontract ILoanData is ILoanStorage {\\n    /**\\n     * @notice Checks whether the status of a loan is Active or has Terms Set\\n     * @param loanID The loan ID for which to check the status\\n     * @return bool value indicating if the loan is active or has terms set\\n     */\\n    function isActiveOrSet(uint256 loanID) public view returns (bool);\\n\\n    /**\\n     * @notice Returns the total owed amount remaining for a specified loan\\n     * @param loanID The ID of the loan to be queried\\n     * @return uint256 The total amount owed remaining\\n     */\\n    function getTotalOwed(uint256 loanID) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the total amount owed for a specified loan.\\n     * @param loanID The loan ID to get the total amount owed.\\n     * @return uint256 The amount owed.\\n     */\\n    function getLoanAmount(uint256 loanID) external view returns (uint256);\\n\\n    /**\\n     * @notice Checks whether the loan's collateral ratio is considered to be secured based on the settings collateral buffer value.\\n     * @param loanID The loan ID to check.\\n     * @return bool value of it being secured or not.\\n     */\\n    function isLoanSecured(uint256 loanID) external view returns (bool);\\n\\n    /**\\n     * @notice Checks whether a loan is allowed to be deposited to an Externally Owned Account.\\n     * @param loanID The loan ID to check the collateral ratio for.\\n     * @return bool indicating whether the loan with specified parameters can be deposited to an EOA.\\n     */\\n    function canGoToEOA(uint256 loanID) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the amount of interest owed for a given loan and loan amount.\\n     * @param loanID The loan ID to get the owed interest.\\n     * @param amountBorrow The principal of the loan to take out.\\n     * @return uint256 The interest owed.\\n     */\\n    function getInterestOwedFor(uint256 loanID, uint256 amountBorrow)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Returns the interest ratio based on the loan interest rate for the loan duration.\\n     * @dev The interest rate on the loan terms is APY.\\n     * @param loanID The loan ID to get the interest rate for.\\n     */\\n    function getInterestRatio(uint256 loanID) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the collateral needed for a loan, in the lending token, needed to take out the loan or for it be liquidated.\\n     * @param loanID The loan ID for which to get collateral information for\\n     * @return uint256 Collateral needed in lending token value\\n     */\\n    function getCollateralInLendingTokens(uint256 loanID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Get information on the collateral needed for the loan.\\n     * @param loanID The loan ID to get collateral info for.\\n     * @return int256 Collateral needed in Lending tokens.\\n     * @return int256 Collateral needed in Collateral tokens (wei)\\n     * @return uint256 The value of the loan held in the escrow contract\\n     */\\n    function getCollateralNeededInfo(uint256 loanID)\\n        external\\n        view\\n        returns (\\n            int256 neededInLendingTokens,\\n            int256 neededInCollateralTokens,\\n            uint256 escrowLoanValue\\n        );\\n\\n    /**\\n     * @notice Returns the minimum collateral value threshold, in the lending token, needed to take out the loan or for it be liquidated.\\n     * @dev If the loan status is TermsSet, then the value is whats needed to take out the loan.\\n     * @dev If the loan status is Active, then the value is the threshold at which the loan can be liquidated at.\\n     * @param loanID The loan ID to get needed collateral info for.\\n     * @return int256 The minimum collateral value threshold required.\\n     * @return uint256 The value of the loan held in the escrow contract.\\n     */\\n    function getCollateralNeededInTokens(uint256 loanID)\\n        external\\n        view\\n        returns (int256 neededInLendingTokens, uint256 escrowLoanValue);\\n\\n    /**\\n     * @notice It checks if a loan can be liquidated.\\n     * @param loanID The loan ID to check.\\n     * @return true if the loan is liquidable.\\n     */\\n    function isLiquidable(uint256 loanID) public view returns (bool);\\n\\n    /**\\n     * @notice It gets the current liquidation reward for a given loan.\\n     * @param loanID The loan ID to get the info.\\n     * @return The value the liquidator will receive denoted in collateral tokens.\\n     */\\n    function getLiquidationReward(uint256 loanID) public view returns (int256);\\n}\\n\",\"keccak256\":\"0x6d99a2d5db1ee2cc383c930a768d833b11aae8ca58c208038fb3f3998eff2816\"},\"contracts/interfaces/loans/ILoanManager.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Commons\\nimport \\\"../../util/TellerCommon.sol\\\";\\n\\n// Interfaces\\nimport \\\"./ILoanStorage.sol\\\";\\nimport \\\"./ILoanData.sol\\\";\\nimport \\\"../SettingsInterface.sol\\\";\\n\\n/**\\n * @notice This interface defines the functions to work with the Teller loans protocol\\n *\\n * @author develop@teller.finance\\n */\\ncontract ILoanManager is ILoanStorage, ILoanData {\\n    /**\\n     * @notice Deposit collateral for a loan, unless it isn't allowed\\n     * @param borrower Account address of the borrower\\n     * @param loanID ID of loan from which collateral was withdrawn\\n     * @param amount Amount to be deposited as collateral\\n     */\\n    function depositCollateral(\\n        address borrower,\\n        uint256 loanID,\\n        uint256 amount\\n    ) external payable;\\n\\n    /**\\n     * @notice Withdraw collateral from a loan, unless this isn't allowed\\n     * @param amount The amount of collateral token or ether the caller is hoping to withdraw\\n     * @param loanID The ID of the loan the collateral is for\\n     */\\n    function withdrawCollateral(uint256 amount, uint256 loanID) external;\\n\\n    /**\\n     * @notice Create a loan with specified terms, if allowed\\n     * @param request Struct of the protocol loan request\\n     * @param responses List of structs of the protocol loan responses\\n     * @param collateralAmount Amount of collateral for the loan\\n     */\\n    function createLoanWithTerms(\\n        TellerCommon.LoanRequest calldata request,\\n        TellerCommon.LoanResponse[] calldata responses,\\n        uint256 collateralAmount\\n    ) external payable;\\n\\n    /**\\n     * @notice Take out a loan, if allowed\\n     * @param loanID The ID of the loan to be taken out\\n     * @param amountBorrow Amount of tokens to be taken out in the loan\\n     */\\n    function takeOutLoan(uint256 loanID, uint256 amountBorrow) external;\\n\\n    /**\\n     * @notice Make a payment to a specified loan\\n     * @param amount The amount of tokens to pay back to the loan\\n     * @param loanID The ID of the loan the payment is for\\n     */\\n    function repay(uint256 amount, uint256 loanID) external;\\n\\n    /**\\n     * @notice Liquidate a loan if has is expired or under collateralized\\n     * @param loanID The ID of the loan to be liquidated\\n     */\\n    function liquidateLoan(uint256 loanID) external;\\n\\n    /**\\n        @notice It adds a new account as a signer.\\n        @param account address to add.\\n        @dev The sender must be the owner.\\n        @dev It throws a require error if the sender is not the owner.\\n     */\\n    function addSigner(address account) external;\\n\\n    /**\\n        @notice It adds a list of account as signers.\\n        @param accounts addresses to add.\\n        @dev The sender must be the owner.\\n        @dev It throws a require error if the sender is not the owner.\\n     */\\n    function addSigners(address[] calldata accounts) external;\\n\\n    /**\\n     *  @notice It calls the LogicVersionRegistry to update the stored logic address for LoanData.\\n     */\\n    function updateLoanDataLogic() external;\\n\\n    /**\\n     *  @notice It calls the LogicVersionRegistry to update the stored logic address for LoanTermsConsensus.\\n     */\\n    function updateLoanTermsConsensusLogic() external;\\n\\n    /**\\n     * @notice Initializes the current contract instance setting the required parameters, if allowed\\n     * @param lendingPoolAddress Contract address of the lending pool\\n     * @param settingsAddress Contract address for the configuration of the platform\\n     * @param collateralTokenAddress Contract address for the collateral token\\n     * @param initDynamicProxyLogicAddress Address of a deployed InitializableDynamicProxy contract.\\n     */\\n    function initialize(\\n        address lendingPoolAddress,\\n        address settingsAddress,\\n        address collateralTokenAddress,\\n        address initDynamicProxyLogicAddress\\n    ) external;\\n\\n    /**\\n     * @notice This event is emitted when collateral has been deposited for the loan\\n     * @param loanID ID of the loan for which collateral was deposited\\n     * @param borrower Account address of the borrower\\n     * @param depositAmount Amount of collateral deposited\\n     */\\n    event CollateralDeposited(\\n        uint256 indexed loanID,\\n        address indexed borrower,\\n        uint256 depositAmount\\n    );\\n\\n    /**\\n     * @notice This event is emitted when collateral has been withdrawn\\n     * @param loanID ID of loan from which collateral was withdrawn\\n     * @param borrower Account address of the borrower\\n     * @param recipient Account address of the recipient\\n     * @param amount Value of collateral withdrawn\\n     */\\n    event CollateralWithdrawn(\\n        uint256 indexed loanID,\\n        address indexed borrower,\\n        address indexed recipient,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @notice This event is emitted when loan terms have been successfully set\\n     * @param loanID ID of loan from which collateral was withdrawn\\n     * @param borrower Account address of the borrower\\n     * @param recipient Account address of the recipient\\n     */\\n    event LoanTermsSet(\\n        uint256 indexed loanID,\\n        address indexed borrower,\\n        address indexed recipient\\n    );\\n\\n    /**\\n     * @notice This event is emitted when a loan has been successfully taken out\\n     * @param loanID ID of loan from which collateral was withdrawn\\n     * @param borrower Account address of the borrower\\n     * @param escrow Escrow address associated to this loan\\n     * @param amountBorrowed Total amount taken out in the loan\\n     */\\n    event LoanTakenOut(\\n        uint256 indexed loanID,\\n        address indexed borrower,\\n        address indexed escrow,\\n        uint256 amountBorrowed\\n    );\\n\\n    /**\\n     * @notice This event is emitted when a loan has been successfully repaid\\n     * @param loanID ID of loan from which collateral was withdrawn\\n     * @param borrower Account address of the borrower\\n     * @param amountPaid Amount of the loan paid back\\n     * @param payer Account address of the payer\\n     */\\n    event LoanRepaid(\\n        uint256 indexed loanID,\\n        address indexed borrower,\\n        uint256 amountPaid,\\n        address payer\\n    );\\n\\n    /**\\n     * @notice This event is emitted when a loan has been successfully liquidated\\n     * @param loanID ID of loan from which collateral was withdrawn\\n     * @param borrower Account address of the borrower\\n     * @param liquidator Account address of the liquidator\\n     * @param collateralOut Collateral that is sent to the liquidator\\n     * @param tokensIn Percentage of the collateral price paid by the liquidator to the lending pool\\n     */\\n    event LoanLiquidated(\\n        uint256 indexed loanID,\\n        address indexed borrower,\\n        address liquidator,\\n        int256 collateralOut,\\n        uint256 tokensIn\\n    );\\n}\\n\",\"keccak256\":\"0xd8a555b0f28546846803d9da391466147ba4dd8f0976513b6c0f4c54f37a1d8f\"},\"contracts/interfaces/loans/ILoanStorage.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\n// Commons\\nimport \\\"../../util/TellerCommon.sol\\\";\\n\\n// Interfaces\\nimport \\\"../SettingsInterface.sol\\\";\\nimport \\\"../LendingPoolInterface.sol\\\";\\nimport \\\"./ILoanTermsConsensus.sol\\\";\\nimport \\\"../../providers/compound/CErc20Interface.sol\\\";\\n\\n/**\\n * @notice This interface defines the functions to get and calculate information about loan data.\\n *\\n * @author develop@teller.finance\\n */\\ninterface ILoanStorage {\\n    /**\\n     * @notice It holds the instance of the platform Settings contract.\\n     * @return Instance of the platform Settings contract.\\n     */\\n    function settings() external view returns (SettingsInterface);\\n\\n    /**\\n     * @notice Holds the total amount of collateral held by the contract.\\n     */\\n    function totalCollateral() external view returns (uint256);\\n\\n    /**\\n     * @notice Holds the instance of the LendingPool used by the LoanManager.\\n     */\\n    function lendingPool() external view returns (LendingPoolInterface);\\n\\n    /**\\n     * @notice Holds the lending token used for creating loans by the LoanManager and LendingPool.\\n     */\\n    function lendingToken() external view returns (address);\\n\\n    /**\\n     * @notice Holds the collateral token.\\n     */\\n    function collateralToken() external view returns (address);\\n\\n    /**\\n     * @notice Holds the Compound cToken where the underlying token matches the lending token.\\n     */\\n    function cToken() external view returns (CErc20Interface);\\n\\n    /**\\n     * @notice Holds the ID of loans taken out\\n     * @dev Also the next available loan ID\\n     */\\n    function loanIDCounter() external view returns (uint256);\\n\\n    /**\\n     * @notice Holds the data of all loans for the lending token.\\n     * @param loanID Loan ID to get data for.\\n     */\\n    function loans(uint256 loanID)\\n        external\\n        view\\n        returns (TellerCommon.Loan memory);\\n}\\n\",\"keccak256\":\"0x9fe882c8dd724028e73637dd9f7bb7785699bb6b5550c98457c32044df4eaf01\"},\"contracts/interfaces/loans/ILoanTermsConsensus.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../util/TellerCommon.sol\\\";\\n\\n/**\\n    @notice This interface defines the function to process the loan terms through the Teller protocol\\n\\n    @author develop@teller.finance\\n */\\ninterface ILoanTermsConsensus {\\n    /**\\n        @notice Processes the loan request\\n        @param request Struct of the protocol loan request\\n        @param responses List of structs of the protocol loan responses\\n        @return uint256 Interest rate\\n        @return uint256 Collateral ratio\\n        @return uint256 Maximum loan amount\\n     */\\n    function processLoanTerms(\\n        TellerCommon.LoanRequest calldata request,\\n        TellerCommon.LoanResponse[] calldata responses\\n    )\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n}\\n\",\"keccak256\":\"0xd6248af274c6681c7a97d771abeb5d9de967a9d43a2c57db1788472b2ba2581a\"},\"contracts/providers/chainlink/ChainlinkAggregator.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n// Contracts\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\\\";\\nimport \\\"../../base/Base.sol\\\";\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"../openzeppelin/SignedSafeMath.sol\\\";\\nimport \\\"../../util/AddressArrayLib.sol\\\";\\n\\n// Interfaces\\nimport \\\"./IChainlinkAggregator.sol\\\";\\n\\n/*****************************************************************************************************/\\n/**                                             WARNING                                             **/\\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\\n/**  ---------------------------------------------------------------------------------------------  **/\\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\\n/**                                                                                                 **/\\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\\n/**  more information.                                                                              **/\\n/*****************************************************************************************************/\\n/**\\n    @notice This contract is used to fetch and calculate prices and values from one token to another through Chainlink Aggregators.\\n    @dev It tries to find an aggregator using the token addresses supplied. If unable, it uses ETH as a pass through asset to construct a path conversion.\\n\\n    @author develop@teller.finance\\n */\\ncontract ChainlinkAggregator is IChainlinkAggregator, Base {\\n    using Address for address;\\n    using AddressLib for address;\\n    using AddressArrayLib for AddressArrayLib.AddressArray;\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    /* State Variables */\\n\\n    uint256 internal constant TEN = 10;\\n\\n    /*\\n        @notice It is a mapping for Chainlink Aggregator contracts by baseTokenAddress => quoteTokenAddress => chainlinkAggregatorAddress\\n     */\\n    mapping(address => mapping(address => address)) internal aggregators;\\n\\n    mapping(address => AddressArrayLib.AddressArray) internal supportedTokens;\\n\\n    /* External Functions */\\n\\n    function getTokensSupportedBy(address tokenAddress)\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        return supportedTokens[tokenAddress].array;\\n    }\\n\\n    /**\\n        @notice It grabs the Chainlink Aggregator contract address for the token pair if it is supported.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n        @return AggregatorV2V3Interface The Chainlink Aggregator address.\\n        @return bool whether or not the values from the Aggregator should be considered inverted.\\n     */\\n    function aggregatorFor(address src, address dst)\\n        external\\n        view\\n        returns (AggregatorV2V3Interface, bool)\\n    {\\n        src = _normalizeTokenAddress(src);\\n        dst = _normalizeTokenAddress(dst);\\n\\n        return _aggregatorFor(src, dst);\\n    }\\n\\n    /**\\n        @notice It checks if the token is supported.\\n        @param tokenAddress Token address to check support for.\\n        @return bool whether or not the token is supported.\\n     */\\n    function isTokenSupported(address tokenAddress)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        tokenAddress = _normalizeTokenAddress(tokenAddress);\\n\\n        return supportedTokens[tokenAddress].length() > 0;\\n    }\\n\\n    /**\\n        @notice It calculates the value of a token amount into another.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n        @param srcAmount Amount of the source token to convert into the destination token.\\n        @return uint256 Value of the source token amount in destination tokens.\\n     */\\n    function valueFor(\\n        address src,\\n        address dst,\\n        uint256 srcAmount\\n    ) external view returns (uint256) {\\n        src = _normalizeTokenAddress(src);\\n        dst = _normalizeTokenAddress(dst);\\n\\n        return _valueFor(src, dst, srcAmount);\\n    }\\n\\n    /**\\n        @notice It returns the price of the token pair as given from the Chainlink Aggregator.\\n        @dev It tries to use ETH as a pass through asset if the direct pair is not supported.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n        @return int256 The latest answer as given from Chainlink.\\n     */\\n    function latestAnswerFor(address src, address dst)\\n        external\\n        view\\n        returns (int256)\\n    {\\n        src = _normalizeTokenAddress(src);\\n        dst = _normalizeTokenAddress(dst);\\n\\n        return _priceFor(src, dst);\\n    }\\n\\n    /**\\n        @notice It allows for additional Chainlink Aggregators to be supported.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n        @param aggregator Price aggregator address.\\n     */\\n    function add(\\n        address src,\\n        address dst,\\n        address aggregator\\n    ) external onlyPauser {\\n        src = _normalizeTokenAddress(src);\\n        dst = _normalizeTokenAddress(dst);\\n\\n        (AggregatorV2V3Interface agg, ) = _aggregatorFor(src, dst);\\n        require(address(agg).isEmpty(), \\\"CHAINLINK_PAIR_ALREADY_EXISTS\\\");\\n\\n        require(\\n            src.isContract() || src == settings.ETH_ADDRESS(),\\n            \\\"TOKEN_A_NOT_CONTRACT\\\"\\n        );\\n        require(\\n            dst.isContract() || dst == settings.ETH_ADDRESS(),\\n            \\\"TOKEN_B_NOT_CONTRACT\\\"\\n        );\\n        require(aggregator.isContract(), \\\"AGGREGATOR_NOT_CONTRACT\\\");\\n\\n        aggregators[src][dst] = aggregator;\\n        supportedTokens[src].add(dst);\\n        supportedTokens[dst].add(src);\\n    }\\n\\n    /**\\n        @notice It removes support for a Chainlink Aggregator pair.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n     */\\n    function remove(address src, address dst) external onlyPauser {\\n        src = _normalizeTokenAddress(src);\\n        dst = _normalizeTokenAddress(dst);\\n\\n        (AggregatorV2V3Interface agg, ) = _aggregatorFor(src, dst);\\n        if (address(agg).isEmpty()) {\\n            return;\\n        }\\n\\n        aggregators[src][dst] = address(0);\\n        supportedTokens[src].remove(dst);\\n        supportedTokens[dst].remove(src);\\n    }\\n\\n    /**\\n        @notice It removes support for a Chainlink Aggregator.\\n        @param tokenAddress Token to remove all markets for.\\n     */\\n    function remove(address tokenAddress) external onlyPauser {\\n        tokenAddress = _normalizeTokenAddress(tokenAddress);\\n\\n        address[] storage arr = supportedTokens[tokenAddress].array;\\n        for (uint256 i; i < arr.length; i++) {\\n            (AggregatorV2V3Interface agg, bool inverse) =\\n                _aggregatorFor(tokenAddress, arr[i]);\\n            if (inverse) {\\n                aggregators[arr[i]][tokenAddress] = address(0);\\n            } else {\\n                aggregators[tokenAddress][arr[i]] = address(0);\\n            }\\n        }\\n\\n        arr.length = 0;\\n    }\\n\\n    /**\\n        @notice It initializes this ChainlinkAggregator instance.\\n     */\\n    function initialize() external {\\n        _initialize(msg.sender);\\n    }\\n\\n    /* Internal Functions */\\n\\n    /**\\n        @notice It normalizes the token address to ETH if WETH.\\n        @param tokenAddress The address of the token to normalize.\\n    */\\n    function _normalizeTokenAddress(address tokenAddress)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return\\n            tokenAddress == settings.WETH_ADDRESS()\\n                ? settings.ETH_ADDRESS()\\n                : tokenAddress;\\n    }\\n\\n    /**\\n        @notice It gets the number of decimals for a given token.\\n        @param addr Token address to get decimals for.\\n        @return uint8 Number of decimals the given token.\\n     */\\n    function _decimalsFor(address addr) internal view returns (uint8) {\\n        return\\n            addr == settings.ETH_ADDRESS()\\n                ? 18\\n                : ERC20Detailed(addr).decimals();\\n    }\\n\\n    /**\\n        @notice It grabs the Chainlink Aggregator contract address for the token pair if it is supported.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n        @return AggregatorV2V3Interface The Chainlink Aggregator address.\\n        @return bool whether or not the values from the Aggregator should be considered inverted.\\n     */\\n    function _aggregatorFor(address src, address dst)\\n        internal\\n        view\\n        returns (AggregatorV2V3Interface aggregator, bool inverse)\\n    {\\n        inverse = aggregators[src][dst] == address(0);\\n        aggregator = AggregatorV2V3Interface(\\n            inverse ? aggregators[dst][src] : aggregators[src][dst]\\n        );\\n    }\\n\\n    /**\\n        @notice It calculates the value of a token amount into another.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n        @param srcAmount Amount of the source token to convert into the destination token.\\n        @return uint256 Value of the source token amount in destination tokens.\\n     */\\n    function _valueFor(\\n        address src,\\n        address dst,\\n        uint256 srcAmount\\n    ) internal view returns (uint256) {\\n        return\\n            (srcAmount.mul(uint256(_priceFor(src, dst)))).div(\\n                uint256(TEN**_decimalsFor(src))\\n            );\\n    }\\n\\n    /**\\n        @notice It returns the price of the token pair as given from the Chainlink Aggregator.\\n        @dev It tries to use ETH as a pass through asset if the direct pair is not supported.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n        @return int256 The latest answer as given from Chainlink.\\n     */\\n    function _priceFor(address src, address dst)\\n        internal\\n        view\\n        returns (int256)\\n    {\\n        (AggregatorV2V3Interface agg, bool inverse) = _aggregatorFor(src, dst);\\n        uint256 dstDecimals = _decimalsFor(dst);\\n        int256 dstFactor = int256(TEN**dstDecimals);\\n        if (address(agg) != address(0)) {\\n            int256 price = agg.latestAnswer();\\n            uint256 resDecimals = agg.decimals();\\n            if (inverse) {\\n                price = int256(TEN**(resDecimals.add(resDecimals))).div(price);\\n            }\\n            if (dstDecimals > resDecimals) {\\n                price = price.mul(int256(TEN**(dstDecimals.sub(resDecimals))));\\n            } else {\\n                price = price.div(int256(TEN**(resDecimals.sub(dstDecimals))));\\n            }\\n            int256 srcFactor = int256(TEN**_decimalsFor(src));\\n            return price;\\n        } else {\\n            for (uint256 i; i < supportedTokens[src].array.length; i++) {\\n                address routeToken = supportedTokens[src].array[i];\\n                (bool found, ) = supportedTokens[routeToken].getIndex(dst);\\n                if (found) {\\n                    int256 price1 = _priceFor(src, routeToken);\\n                    int256 price2 = _priceFor(dst, routeToken);\\n\\n                    return (price1.mul(dstFactor)).div(price2);\\n                }\\n            }\\n            revert(\\\"CANNOT_CALCULATE_VALUE\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x09fbad9145ad74003b24ba594ddd7374a53a44deb9a6d79d776fdef9d54ff56a\"},\"contracts/providers/chainlink/IChainlinkAggregator.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n// Interfaces\\nimport \\\"@chainlink/contracts/src/v0.5/interfaces/AggregatorV2V3Interface.sol\\\";\\n\\n/*****************************************************************************************************/\\n/**                                             WARNING                                             **/\\n/**                                  THIS CONTRACT IS UPGRADEABLE!                                  **/\\n/**  ---------------------------------------------------------------------------------------------  **/\\n/**  Do NOT change the order of or PREPEND any storage variables to this or new versions of this    **/\\n/**  contract as this will cause the the storage slots to be overwritten on the proxy contract!!    **/\\n/**                                                                                                 **/\\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\\n/**  more information.                                                                              **/\\n/*****************************************************************************************************/\\n/**\\n    @notice This contract is used to fetch and calculate prices and values from one token to another through Chainlink Aggregators.\\n    @dev It tries to find an aggregator using the token addresses supplied. If unable, it uses ETH as a pass through asset to construct a path conversion.\\n\\n    @author develop@teller.finance\\n */\\ninterface IChainlinkAggregator {\\n    /**\\n        @notice It grabs the Chainlink Aggregator contract address for the token pair if it is supported.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n        @return AggregatorV2V3Interface The Chainlink Aggregator address.\\n        @return bool whether or not the values from the Aggregator should be considered inverted.\\n     */\\n    function aggregatorFor(address src, address dst)\\n        external\\n        view\\n        returns (AggregatorV2V3Interface, bool);\\n\\n    function isTokenSupported(address tokenAddress) external view returns (bool);\\n\\n    /**\\n        @notice It calculates the value of a token amount into another.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n        @param srcAmount Amount of the source token to convert into the destination token.\\n        @return uint256 Value of the source token amount in destination tokens.\\n     */\\n    function valueFor(\\n        address src,\\n        address dst,\\n        uint256 srcAmount\\n    ) external view returns (uint256);\\n\\n    /**\\n        @notice It returns the price of the token pair as given from the Chainlink Aggregator.\\n        @dev It tries to use ETH as a pass through asset if the direct pair is not supported.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n        @return uint256 The latest answer as given from Chainlink.\\n     */\\n    function latestAnswerFor(address src, address dst) external view returns (int256);\\n\\n    /**\\n        @notice It allows for additional Chainlink Aggregators to be supported.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n     */\\n    function add(\\n        address src,\\n        address dst,\\n        address aggregator\\n    ) external;\\n\\n    /**\\n        @notice It removes support for a Chainlink Aggregator pair.\\n        @param src Source token address.\\n        @param dst Destination token address.\\n     */\\n    function remove(address src, address dst) external;\\n\\n    /**\\n        @notice It removes support for a Chainlink Aggregator.\\n        @param tokenAddress Token to remove all markets for.\\n     */\\n    function remove(address tokenAddress) external;\\n\\n    function initialize() external;\\n}\\n\",\"keccak256\":\"0x7bdd1d465f6ad5db93bbde2ca7dffdf10fbcfbbc6684010d7a93154cce4409ce\"},\"contracts/providers/compound/CErc20Interface.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\ninterface CErc20Interface {\\n    /*** User Interface ***/\\n\\n    /**\\n        @notice The mint function transfers an asset into the protocol, which begins accumulating interest based on the current Supply Rate for the asset. The user receives a quantity of cTokens equal to the underlying tokens supplied, divided by the current Exchange Rate.\\n        @param mintAmount The amount of the asset to be supplied, in units of the underlying asset.\\n        @return 0 on success, otherwise an Error code\\n        @dev msg.sender The account which shall supply the asset, and own the minted cTokens.\\n        @dev Before supplying an asset, users must first approve the cToken to access their token balance.\\n     */\\n    function mint(uint256 mintAmount) external returns (uint256);\\n\\n    /**\\n        @notice The redeem function converts a specified quantity of cTokens into the underlying asset, and returns them to the user. The amount of underlying tokens received is equal to the quantity of cTokens redeemed, multiplied by the current Exchange Rate. The amount redeemed must be less than the user's Account Liquidity and the market's available liquidity.\\n        @param redeemTokens The number of cTokens to be redeemed.\\n        @return 0 on success, otherwise an Error code\\n        @dev msg.sender The account to which redeemed funds shall be transferred.\\n     */\\n    function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n    /**\\n        @notice The redeem underlying function converts cTokens into a specified quantity of the underlying asset, and returns them to the user. The amount of cTokens redeemed is equal to the quantity of underlying tokens received, divided by the current Exchange Rate. The amount redeemed must be less than the user's Account Liquidity and the market's available liquidity.\\n        @param redeemAmount The amount of underlying to be redeemed.\\n        @return 0 on success, otherwise an Error code\\n        @dev msg.sender The account to which redeemed funds shall be transferred.\\n     */\\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n    /**\\n        @notice The borrow function transfers an asset from the protocol to the user, and creates a borrow balance which begins accumulating interest based on the Borrow Rate for the asset. The amount borrowed must be less than the user's Account Liquidity and the market's available liquidity.\\n        @param borrowAmount The amount of the underlying asset to be borrowed.\\n        @return 0 on success, otherwise an Error code\\n        @dev msg.sender The account to which borrowed funds shall be transferred.\\n     */\\n    function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n    /**\\n        @notice The repay function transfers an asset into the protocol, reducing the user's borrow balance.\\n        @param repayAmount The amount of the underlying borrowed asset to be repaid. A value of -1 (i.e. 2^256 - 1) can be used to repay the full amount.\\n        @return 0 on success, otherwise an Error code\\n        @dev msg.sender The account which borrowed the asset, and shall repay the borrow.\\n        @dev Before repaying an asset, users must first approve the cToken to access their token balance.\\n     */\\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\\n\\n    /**\\n        @notice The repay function transfers an asset into the protocol, reducing the target user's borrow balance.\\n        @param borrower The account which borrowed the asset to be repaid.\\n        @param repayAmount The amount of the underlying borrowed asset to be repaid. A value of -1 (i.e. 2^256 - 1) can be used to repay the full amount.\\n        @return 0 on success, otherwise an Error code\\n        @dev msg.sender The account which shall repay the borrow.\\n        @dev Before repaying an asset, users must first approve the cToken to access their token balance.\\n     */\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\\n        external\\n        returns (uint256);\\n\\n    /*** Admin Functions ***/\\n\\n    function _addReserves(uint256 addAmount) external returns (uint256);\\n\\n    /** End Admin Functions */\\n\\n    function underlying() external view returns (address);\\n\\n    /**\\n        @notice Each cToken is convertible into an ever increasing quantity of the underlying asset, as interest accrues in the market. The exchange rate between a cToken and the underlying asset is\\n        equal to: exchangeRate = (getCash() + totalBorrows() - totalReserves()) / totalSupply()\\n        @return The current exchange rate as an unsigned integer, scaled by 1e18.\\n     */\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    function exchangeRateStored() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n        @notice The user's underlying balance, representing their assets in the protocol, is equal to the user's cToken balance multiplied by the Exchange Rate.\\n        @param account The account to get the underlying balance of.\\n        @return The amount of underlying currently owned by the account.\\n     */\\n    function balanceOfUnderlying(address account) external returns (uint256);\\n}\\n\",\"keccak256\":\"0x71d8848e07844bbd0abb2c5fe617cd778c71cdf634700dab1db54fc38fac9fbe\"},\"contracts/providers/openzeppelin/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.17;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n * @dev This contract is similar to commit Hash: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/022f2bc177cdf02264bf38a9a73fef504f79b82f/contracts/math/SignedSafeMath.sol\\n * @dev It only differs in the solidity version. We use 0.5.17 instead of ^0.6.0.\\n */\\nlibrary SignedSafeMath {\\n    int256 private constant _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(\\n            !(a == -1 && b == _INT256_MIN),\\n            \\\"SignedSafeMath: multiplication overflow\\\"\\n        );\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require(\\n            (b >= 0 && c <= a) || (b < 0 && c > a),\\n            \\\"SignedSafeMath: subtraction overflow\\\"\\n        );\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require(\\n            (b >= 0 && c >= a) || (b < 0 && c < a),\\n            \\\"SignedSafeMath: addition overflow\\\"\\n        );\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0x82686232f4b4f17388d0bf3b50c94c7bb5436c21b9c2021850fef3cf551e8fc2\"},\"contracts/util/AddressArrayLib.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./AddressLib.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n    @notice Utility library of inline functions on the address arrays.\\n\\n    @author develop@teller.finance\\n */\\nlibrary AddressArrayLib {\\n    using AddressLib for address;\\n\\n    /**\\n        @notice This struct manages an array of addresses of the library instance.\\n        @param array An array of address values.\\n        @param indices A mapping of each address to its unit256 array index.\\n     */\\n    struct AddressArray {\\n        address[] array;\\n        mapping(address => uint256) indices;\\n    }\\n\\n    /**\\n        @notice It returns the length of an array\\n        @param self The current array\\n    */\\n    function length(AddressArray storage self) internal view returns (uint256) {\\n        return self.array.length;\\n    }\\n\\n    /**\\n      @notice It adds an address value to the array.\\n      @param self current array.\\n      @param newItem new item to add.\\n      @return index the item was added to.\\n    */\\n    function add(address[] storage self, address newItem)\\n        internal\\n        returns (uint256)\\n    {\\n        newItem.requireNotEmpty(\\\"EMPTY_ADDRESS_NOT_ALLOWED\\\");\\n        (bool found, ) = getIndex(self, newItem);\\n        require(!found, \\\"ADDRESS_EXISTS\\\");\\n        return self.push(newItem) - 1;\\n    }\\n\\n    /**\\n      @notice It adds an address value to the array.\\n      @param self current array.\\n      @param addr new address to add.\\n      @return index the item was added to.\\n    */\\n    function add(AddressArray storage self, address addr)\\n        internal\\n        returns (uint256 index)\\n    {\\n        addr.requireNotEmpty(\\\"EMPTY_ADDRESS_NOT_ALLOWED\\\");\\n        (bool found, uint256 i) = getIndex(self, addr);\\n        require(!found, \\\"ADDRESS_EXISTS\\\");\\n        index = self.array.push(addr) - 1;\\n        self.indices[addr] = index;\\n    }\\n\\n    /**\\n      @notice It removes the value at the given index in an array.\\n      @param self the current array.\\n      @param index remove an item in a specific index.\\n    */\\n    function removeAt(address[] storage self, uint256 index) internal {\\n        if (index >= self.length) return;\\n\\n        if (index != self.length - 1) {\\n            self[index] = self[self.length - 1];\\n        }\\n\\n        self.length--;\\n    }\\n\\n    /**\\n      @notice It removes an address value from the array.\\n      @param self the current array.\\n      @param index the index of the address to remove.\\n    */\\n    function remove(AddressArray storage self, uint256 index) internal {\\n        removeAt(self.array, index);\\n    }\\n\\n    /**\\n      @notice It removes an address value from the array.\\n      @param self the current array.\\n      @param addr the address to remove.\\n    */\\n    function remove(AddressArray storage self, address addr) internal {\\n        (bool found, uint256 index) = getIndex(self, addr);\\n\\n        if (!found) return;\\n\\n        removeAt(self.array, index);\\n    }\\n\\n    /**\\n      @notice It gets the index for a given item.\\n      @param self the current array.\\n      @param item to get the index.\\n      @return found true if the item was found. Otherwise it returns false.\\n      @return indexAt the current index for a given item.\\n    */\\n    function getIndex(address[] storage self, address item)\\n        internal\\n        view\\n        returns (bool found, uint256 indexAt)\\n    {\\n        for (indexAt = 0; indexAt < self.length; indexAt++) {\\n            found = self[indexAt] == item;\\n            if (found) {\\n                return (found, indexAt);\\n            }\\n        }\\n        return (found, indexAt);\\n    }\\n\\n    /**\\n      @notice It gets the index for a given item.\\n      @param self the current array.\\n      @param addr to get the index for.\\n      @return found true if the item was found. Otherwise it returns false.\\n      @return index the current index for a given address.\\n    */\\n    function getIndex(AddressArray storage self, address addr)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        if (self.array.length > 0) {\\n            index = self.indices[addr];\\n            found = self.array[index] == addr;\\n        }\\n    }\\n\\n    /**\\n      @notice It removes an address value from the array.\\n      @param self the current array.\\n      @param item the item to remove.\\n      @return the current array without the removed item.\\n    */\\n    function remove(address[] storage self, address item) internal {\\n        (bool found, uint256 indexAt) = getIndex(self, item);\\n        if (!found) return;\\n\\n        removeAt(self, indexAt);\\n    }\\n}\\n\",\"keccak256\":\"0x43a4ebe474b44fc018a86faa8edf29228cdd0706cf3b1598b71302baf50c8c70\"},\"contracts/util/AddressLib.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n * @dev Utility library of inline functions on addresses\\n *\\n * @author develop@teller.finance\\n */\\nlibrary AddressLib {\\n    address public constant ADDRESS_EMPTY = address(0x0);\\n\\n    /**\\n     * @dev Checks if this address is all 0s\\n     * @param self The address this function was called on\\n     * @return boolean\\n     */\\n    function isEmpty(address self) internal pure returns (bool) {\\n        return self == ADDRESS_EMPTY;\\n    }\\n\\n    /**\\n     * @dev Checks if this address is the same as another address\\n     * @param self The address this function was called on\\n     * @param other Address to check against itself\\n     * @return boolean\\n     */\\n    function isEqualTo(address self, address other) internal pure returns (bool) {\\n        return self == other;\\n    }\\n\\n    /**\\n     * @dev Checks if this address is different to another address\\n     * @param self The address this function was called on\\n     * @param other Address to check against itself\\n     * @return boolean\\n     */\\n    function isNotEqualTo(address self, address other) internal pure returns (bool) {\\n        return self != other;\\n    }\\n\\n    /**\\n     * @dev Checks if this address is not all 0s\\n     * @param self The address this function was called on\\n     * @return boolean\\n     */\\n    function isNotEmpty(address self) internal pure returns (bool) {\\n        return self != ADDRESS_EMPTY;\\n    }\\n\\n    /**\\n     * @dev Throws an error if address is all 0s\\n     * @param self The address this function was called on\\n     * @param message Error message if address is all 0s\\n     */\\n    function requireNotEmpty(address self, string memory message) internal pure {\\n        require(isNotEmpty(self), message);\\n    }\\n\\n    /**\\n     * @dev Throws an error if address is not the same as another address\\n     * @param self The address this function was called on\\n     * @param other The address to check against itself\\n     * @param message Error message if addresses are not the same\\n     */\\n    function requireEqualTo(\\n        address self,\\n        address other,\\n        string memory message\\n    ) internal pure {\\n        require(isEqualTo(self, other), message);\\n    }\\n\\n    /**\\n     * @dev Throws an error if address is the same as another address\\n     * @param self The address this function was called on\\n     * @param other The address to check against itself\\n     * @param message Error message if addresses are the same\\n     */\\n    function requireNotEqualTo(\\n        address self,\\n        address other,\\n        string memory message\\n    ) internal pure {\\n        require(isNotEqualTo(self, other), message);\\n    }\\n}\\n\",\"keccak256\":\"0xb6311a4caaab2cc3f783d476a1432e436d12b4ea45be92809b1adbeafc4d31c1\"},\"contracts/util/CacheLib.sol\":{\"content\":\"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\\\";\\nimport \\\"./AddressLib.sol\\\";\\n\\n/**\\n    @notice Utility library of inline functions on the Cache struct.\\n\\n    @author develop@teller.finance\\n */\\nlibrary CacheLib {\\n  using AddressLib for address;\\n  using Address for address;\\n\\n  enum CacheType { Address, Uint, Int, Byte, Bool }\\n\\n  /**\\n        @notice This struct manages the cache of the library instance.\\n        @param addresses A mapping of address values mapped to cache keys in bytes.\\n        @param uints A mapping of uint values mapped to cache keys names in bytes.\\n        @param ints A mapping of int values mapped to cache keys names in bytes.\\n        @param bites A mapping of bytes values mapped to cache keys names in bytes.\\n        @param bools A mapping of bool values mapped to cache keys names in bytes.\\n     */\\n\\n  struct Cache {\\n    // Mapping of cache keys names to address values.\\n    mapping(bytes32 => address) addresses;\\n    // Mapping of cache keys names to uint256 values.\\n    mapping(bytes32 => uint256) uints;\\n    // Mapping of cache keys names to int256 values.\\n    mapping(bytes32 => int256) ints;\\n    // Mapping of cache keys names to bytes32 values.\\n    mapping(bytes32 => bytes32) bites;\\n    // Mapping of cache keys names to bool values.\\n    mapping(bytes32 => bool) bools;\\n  }\\n\\n  /**\\n        @notice The constant for the initialization check\\n     */\\n//   bytes32 private constant INITIALIZED = keccak256(\\\"Initialized\\\");\\n\\n  /**\\n        @notice Initializes the cache instance.\\n        @param self The current cache\\n     */\\n  function initialize(Cache storage self) internal {\\n    requireNotExists(self);\\n    self.bools[keccak256(\\\"Initialized\\\")] = true;\\n  }\\n\\n  /**\\n        @notice Checks whether the current cache does not, throwing an error if it does.\\n        @param self The current cache\\n     */\\n  function requireNotExists(Cache storage self) internal view {\\n    require(!exists(self), \\\"CACHE_ALREADY_EXISTS\\\");\\n  }\\n\\n  /**\\n        @notice Checks whether the current cache exists, throwing an error if the cache does not.\\n        @param self The current cache\\n     */\\n  function requireExists(Cache storage self) internal view {\\n    require(exists(self), \\\"CACHE_DOES_NOT_EXIST\\\");\\n  }\\n\\n  /**\\n        @notice Tests whether the current cache exists or not.\\n        @param self The current cache.\\n        @return bool True if the cache exists.\\n     */\\n  function exists(Cache storage self) internal view returns (bool) {\\n    return self.bools[keccak256(\\\"Initialized\\\")];\\n  }\\n\\n  /**\\n        @notice Updates the address value for a given key name.\\n        @param self The current cache\\n        @param key The key for which the address value is being updated.\\n        @param newAddress The new address being set.\\n     */\\n  function updateAddress(\\n    Cache storage self,\\n    bytes32 key,\\n    address newAddress\\n  ) internal {\\n    requireExists(self);\\n    require(self.addresses[key] != newAddress, \\\"NEW_ADDRESS_REQUIRED\\\");\\n    self.addresses[key] = newAddress;\\n  }\\n\\n  /**\\n        @notice Updates the uint value for a given key name.\\n        @param self The current cache\\n        @param key The key for which the uint value is being updated.\\n        @param newValue The new value being set.\\n     */\\n  function updateUint(\\n    Cache storage self,\\n    bytes32 key,\\n    uint256 newValue\\n  ) internal {\\n    requireExists(self);\\n    require(self.uints[key] != newValue, \\\"NEW_UINT_REQUIRED\\\");\\n    self.uints[key] = newValue;\\n  }\\n\\n  /**\\n        @notice Tests whether a given uint value is greater than the current stored value for a given key.\\n        @param self The current cache\\n        @param key The key for which the uint value is being updated.\\n        @param amount The value being tested.\\n        @return bool True if the value exceed the stored value.\\n     */\\n  function exceedsUint(\\n    Cache storage self,\\n    bytes32 key,\\n    uint256 amount\\n  ) internal view returns (bool) {\\n    requireExists(self);\\n    return amount > self.uints[key];\\n  }\\n\\n  /**\\n        @notice Updates the int value for a given key name.\\n        @param self The current cache\\n        @param key The key for which the int value is being updated.\\n        @param newValue The new value being set.\\n     */\\n  function updateInt(\\n    Cache storage self,\\n    bytes32 key,\\n    int256 newValue\\n  ) internal {\\n    requireExists(self);\\n    require(self.ints[key] != newValue, \\\"NEW_INT_REQUIRED\\\");\\n    self.ints[key] = newValue;\\n  }\\n\\n  /**\\n        @notice Updates the bytes value for a given key name.\\n        @param self The current cache\\n        @param key The key for which the bytes value is being updated.\\n        @param newBites The new value being set.\\n     */\\n  function updateBites(\\n    Cache storage self,\\n    bytes32 key,\\n    bytes32 newBites\\n  ) internal {\\n    requireExists(self);\\n    require(self.bites[key] != newBites, \\\"NEW_BYTES_REQUIRED\\\");\\n    self.bites[key] = newBites;\\n  }\\n\\n  /**\\n        @notice Updates the bool value for a given key name.\\n        @param self The current cache\\n        @param key The key for which the bool value is being updated.\\n        @param newBool The new value being set.\\n     */\\n  function updateBool(\\n    Cache storage self,\\n    bytes32 key,\\n    bool newBool\\n  ) internal {\\n    requireExists(self);\\n    require(self.bools[key] != newBool, \\\"NEW_BOOLEAN_REQUIRED\\\");\\n    self.bools[key] = newBool;\\n  }\\n\\n  /**\\n   */\\n  function clearCache(\\n    Cache storage self,\\n    bytes32[5] memory keysToClear,\\n    CacheType[5] memory keyTypes\\n  ) internal {\\n    requireExists(self);\\n    require(keysToClear.length == keyTypes.length, \\\"ARRAY_LENGTHS_MISMATCH\\\");\\n    for (uint256 i; i <= keysToClear.length; i++) {\\n      if (keyTypes[i] == CacheType.Address) {\\n        delete self.addresses[keysToClear[i]];\\n      } else if (keyTypes[i] == CacheType.Uint) {\\n        delete self.uints[keysToClear[i]];\\n      } else if (keyTypes[i] == CacheType.Int) {\\n        delete self.ints[keysToClear[i]];\\n      } else if (keyTypes[i] == CacheType.Byte) {\\n        delete self.bites[keysToClear[i]];\\n      } else if (keyTypes[i] == CacheType.Bool) {\\n        delete self.bools[keysToClear[i]];\\n      }\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xa43ff6d740577dfeae4972671c9a60cdf9607d6e81cadc585955debe1ca38dd7\"},\"contracts/util/LogicVersionLib.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n    @notice This library manages the functions for the logic version struct.\\n\\n    @author develop@teller.finance\\n */\\nlibrary LogicVersionLib {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    /**\\n        @notice It stores all the versions for a given logic.\\n        @param currentVersion the current version.\\n        @param latestVersion the latest version.\\n        @param versions mapping version to logic address.\\n        @param exists boolean to test whether this logic version exists or not.\\n     */\\n    struct LogicVersion {\\n        uint256 currentVersion;\\n        uint256 latestVersion;\\n        mapping(uint256 => address) versions;\\n        bool exists;\\n    }\\n\\n    /**\\n        @notice It creates a new logic version.\\n        @param self the current logic version instance.\\n        @param logic initial logic address.\\n     */\\n    function initialize(LogicVersion storage self, address logic) internal {\\n        requireNotExists(self);\\n        require(logic.isContract(), \\\"LOGIC_MUST_BE_CONTRACT\\\");\\n        self.currentVersion = 0;\\n        self.latestVersion = 0;\\n        self.versions[self.currentVersion] = logic;\\n        self.exists = true;\\n    }\\n\\n    /**\\n        @notice It rollbacks a logic to a previous version.\\n        @param self the current logic version instance.\\n        @param previousVersion the previous version to be used.\\n     */\\n    function rollback(LogicVersion storage self, uint256 previousVersion)\\n        internal\\n        returns (\\n            uint256 currentVersion,\\n            address previousLogic,\\n            address newLogic\\n        )\\n    {\\n        requireExists(self);\\n        require(\\n            self.currentVersion != previousVersion,\\n            \\\"CURRENT_VERSION_MUST_BE_DIFF\\\"\\n        );\\n        require(\\n            self.latestVersion >= previousVersion,\\n            \\\"VERSION_MUST_BE_LTE_LATEST\\\"\\n        );\\n        currentVersion = self.currentVersion;\\n        previousLogic = self.versions[self.currentVersion];\\n        newLogic = self.versions[previousVersion];\\n\\n        self.currentVersion = previousVersion;\\n    }\\n\\n    /**\\n        @notice Checks whether the current logic version exists or not.\\n        @dev It throws a require error if the logic version already exists.\\n        @param self the current logic version.\\n     */\\n    function requireNotExists(LogicVersion storage self) internal view {\\n        require(!self.exists, \\\"LOGIC_ALREADY_EXISTS\\\");\\n    }\\n\\n    /**\\n        @notice Checks whether the current logic version exists or not.\\n        @dev It throws a require error if the current logic version doesn't exist.\\n        @param self the current logic version.\\n     */\\n    function requireExists(LogicVersion storage self) internal view {\\n        require(self.exists, \\\"LOGIC_NOT_EXISTS\\\");\\n    }\\n\\n    /**\\n        @notice It upgrades a logic version.\\n        @dev It throws a require error if:\\n            - The new logic is equal to the current logic.\\n        @param self the current logic version.\\n        @param newLogic the new logic to set in the logic version.\\n        @return oldLogic the old logic address.\\n        @return oldVersion the old version.\\n        @return newVersion the new version.\\n     */\\n    function upgrade(LogicVersion storage self, address newLogic)\\n        internal\\n        returns (\\n            address oldLogic,\\n            uint256 oldVersion,\\n            uint256 newVersion\\n        )\\n    {\\n        requireExists(self);\\n        require(\\n            self.versions[self.currentVersion] != newLogic,\\n            \\\"NEW_LOGIC_REQUIRED\\\"\\n        );\\n        require(newLogic.isContract(), \\\"LOGIC_MUST_BE_CONTRACT\\\");\\n        oldLogic = self.versions[self.currentVersion];\\n        oldVersion = self.currentVersion;\\n        newVersion = self.latestVersion.add(1);\\n\\n        self.currentVersion = newVersion;\\n        self.latestVersion = newVersion;\\n        self.versions[newVersion] = newLogic;\\n    }\\n}\\n\",\"keccak256\":\"0x51867a2eb496907d3017725a79ab887bf562eb13c6238e88d721348a1902c3d6\"},\"contracts/util/NumbersLib.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Utility library for uint256 numbers\\n *\\n * @author develop@teller.finance\\n */\\nlibrary NumbersLib {\\n    using SafeMath for uint256;\\n\\n    // It represents 100% with 2 decimal places.\\n    function ONE_HUNDRED_PERCENT() internal pure returns (uint256) {\\n        return 10000;\\n    }\\n\\n    /**\\n        @notice Returns the positive difference value of a number to another number\\n        @param self The number to return the difference value for\\n        @param other The other number to calucualte the difference against\\n        @return uint256 The difference value\\n     */\\n    function diff(uint256 self, uint256 other) internal pure returns (uint256) {\\n        return other > self ? other.sub(self) : self.sub(other);\\n    }\\n\\n    /**\\n        @notice Returns the positive percentage difference of a value to 100%\\n        @param self The number to return the percentage difference for\\n        @return uint256 The percentage difference value\\n     */\\n    function diffOneHundredPercent(uint256 self) internal pure returns (uint256) {\\n        return diff(self, ONE_HUNDRED_PERCENT());\\n    }\\n\\n    /**\\n     * @notice Returns a percentage value of a number.\\n     * @param self The number to get a percentage of.\\n     * @param percentage The percentage value to calculate with 2 decimal places (10000 = 100%).\\n     */\\n    function percent(uint256 self, uint256 percentage) internal pure returns (uint256) {\\n        return self.mul(percentage).div(ONE_HUNDRED_PERCENT());\\n    }\\n\\n    function percent(int256 self, uint256 percentage) internal pure returns (int256) {\\n        return (self * int256(percentage)) / int256(ONE_HUNDRED_PERCENT());\\n    }\\n\\n    function abs(int256 self) internal pure returns (uint256) {\\n        return self >= 0 ? uint256(self) : uint256(-1 * self);\\n    }\\n\\n    /**\\n     * @notice Returns a ratio of 2 numbers.\\n     * @param self The number to get a ratio of.\\n     * @param num The number to calculate the ratio for.\\n     * @return Ratio of 2 numbers with 2 decimal places (10000 = 100%).\\n     */\\n    function ratioOf(uint256 self, uint256 num) internal pure returns (uint256) {\\n        return self.mul(ONE_HUNDRED_PERCENT()).div(num);\\n    }\\n}\\n\",\"keccak256\":\"0xaa858071cda31070104f3ad479213c5fa4d898568823c98b18de60cb1c097c21\"},\"contracts/util/NumbersList.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"./NumbersLib.sol\\\";\\n\\n/**\\n * @dev Utility library of inline functions on NumbersList.Values\\n *\\n * @author develop@teller.finance\\n */\\nlibrary NumbersList {\\n    using SafeMath for uint256;\\n    using NumbersLib for uint256;\\n\\n    // Holds values to calculate the threshold of a list of numbers\\n    struct Values {\\n        uint256 count; // The total number of numbers added\\n        uint256 max; // The maximum number that was added\\n        uint256 min; // The minimum number that was added\\n        uint256 sum; // The total sum of the numbers that were added\\n    }\\n\\n    /**\\n     * @dev Add to the sum while keeping track of min and max values\\n     * @param self The Value this function was called on\\n     * @param newValue Number to increment sum by\\n     */\\n    function addValue(Values memory self, uint256 newValue) internal pure {\\n        if (self.max < newValue) {\\n            self.max = newValue;\\n        }\\n        if (self.min > newValue || self.count == 0) {\\n            self.min = newValue;\\n        }\\n        self.sum = self.sum.add(newValue);\\n        self.count = self.count.add(1);\\n    }\\n\\n    /**\\n     * @param self The Value this function was called on\\n     * @return the number of times the sum has updated\\n     */\\n    function valuesCount(Values memory self) internal pure returns (uint256) {\\n        return self.count;\\n    }\\n\\n    /**\\n     * @dev Checks if the sum has been changed\\n     * @param self The Value this function was called on\\n     * @return boolean\\n     */\\n    function isEmpty(Values memory self) internal pure returns (bool) {\\n        return valuesCount(self) == 0;\\n    }\\n\\n    /**\\n     * @param self The Value this function was called on\\n     * @return the average number that was used to calculate the sum\\n     */\\n    function getAverage(Values memory self) internal pure returns (uint256) {\\n        return isEmpty(self) ? 0 : self.sum.div(valuesCount(self));\\n    }\\n\\n    /**\\n     * @dev Checks if the min and max numbers are within the acceptable tolerance\\n     * @param self The Value this function was called on\\n     * @param tolerancePercentage Acceptable tolerance percentage as a whole number\\n     * The percentage should be entered with 2 decimal places. e.g. 2.5% should be entered as 250.\\n     * @return boolean\\n     */\\n    function isWithinTolerance(Values memory self, uint256 tolerancePercentage)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (isEmpty(self)) {\\n            return false;\\n        }\\n        uint256 average = getAverage(self);\\n        uint256 toleranceAmount = average.percent(tolerancePercentage);\\n\\n        uint256 minTolerance = average.sub(toleranceAmount);\\n        if (self.min < minTolerance) {\\n            return false;\\n        }\\n\\n        uint256 maxTolerance = average.add(toleranceAmount);\\n        if (self.max > maxTolerance) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x983a4fe98db91ca209b4908b7ff552f5a3ccd4e449db7b92387f5ce752908adb\"},\"contracts/util/PlatformSettingsLib.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n    @notice Utility library of inline functions on the PlatformSetting struct.\\n\\n    @author develop@teller.finance\\n */\\nlibrary PlatformSettingsLib {\\n    /**\\n        It defines a platform settings. It includes: value, min, and max values.\\n     */\\n    struct PlatformSetting {\\n        uint256 value;\\n        uint256 min;\\n        uint256 max;\\n        bool exists;\\n    }\\n\\n    /**\\n        @notice It creates a new platform setting given a name, min and max values.\\n        @param value initial value for the setting.\\n        @param min min value allowed for the setting.\\n        @param max max value allowed for the setting.\\n     */\\n    function initialize(\\n        PlatformSetting storage self,\\n        uint256 value,\\n        uint256 min,\\n        uint256 max\\n    ) internal {\\n        requireNotExists(self);\\n        require(value >= min, \\\"VALUE_MUST_BE_GTE_MIN_VALUE\\\");\\n        require(value <= max, \\\"VALUE_MUST_BE_LTE_MAX_VALUE\\\");\\n        self.value = value;\\n        self.min = min;\\n        self.max = max;\\n        self.exists = true;\\n    }\\n\\n    /**\\n        @notice Checks whether the current platform setting exists or not.\\n        @dev It throws a require error if the platform setting already exists.\\n        @param self the current platform setting.\\n     */\\n    function requireNotExists(PlatformSetting storage self) internal view {\\n        require(!self.exists, \\\"PLATFORM_SETTING_ALREADY_EXISTS\\\");\\n    }\\n\\n    /**\\n        @notice Checks whether the current platform setting exists or not.\\n        @dev It throws a require error if the current platform setting doesn't exist.\\n        @param self the current platform setting.\\n     */\\n    function requireExists(PlatformSetting storage self) internal view {\\n        require(self.exists, \\\"PLATFORM_SETTING_NOT_EXISTS\\\");\\n    }\\n\\n    /**\\n        @notice It updates a current platform setting.\\n        @dev It throws a require error if:\\n            - The new value is equal to the current value.\\n            - The new value is not lower than the max value.\\n            - The new value is not greater than the min value\\n        @param self the current platform setting.\\n        @param newValue the new value to set in the platform setting.\\n     */\\n    function update(PlatformSetting storage self, uint256 newValue)\\n        internal\\n        returns (uint256 oldValue)\\n    {\\n        requireExists(self);\\n        require(self.value != newValue, \\\"NEW_VALUE_REQUIRED\\\");\\n        require(newValue >= self.min, \\\"NEW_VALUE_MUST_BE_GTE_MIN_VALUE\\\");\\n        require(newValue <= self.max, \\\"NEW_VALUE_MUST_BE_LTE_MAX_VALUE\\\");\\n        oldValue = self.value;\\n        self.value = newValue;\\n    }\\n\\n    /**\\n        @notice It removes a current platform setting.\\n        @param self the current platform setting to remove.\\n     */\\n    function remove(PlatformSetting storage self) internal {\\n        requireExists(self);\\n        self.value = 0;\\n        self.min = 0;\\n        self.max = 0;\\n        self.exists = false;\\n    }\\n}\\n\",\"keccak256\":\"0x0a63860141bab4588a5cd4af606b9a27ddd29aa7554029cb8b89b703d444f28b\"},\"contracts/util/TellerCommon.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./NumbersList.sol\\\";\\n\\n/**\\n * @dev Library of structs common across the Teller protocol\\n *\\n * @author develop@teller.finance\\n */\\nlibrary TellerCommon {\\n    enum LoanStatus { NonExistent, TermsSet, Active, Closed }\\n\\n    /**\\n        @notice Represents a user signature\\n        @param v The recovery identifier represented by the last byte of a ECDSA signature as an int\\n        @param r The random point x-coordinate of the signature respresented by the first 32 bytes of the generated ECDSA signature\\n        @param s The signature proof represented by the second 32 bytes of the generated ECDSA signature\\n     */\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /**\\n        @notice Borrower request object to take out a loan\\n        @param borrower The wallet address of the borrower\\n        @param recipient The address where funds will be sent, only applicable in over collateralized loans\\n        @param consensusAddress The address of the Teller loan consensus contract to which the request should be sent\\n        @param requestNonce The nonce of the borrower wallet address required for authentication\\n        @param amount The amount of tokens requested by the borrower for the loan\\n        @param duration The length of time in seconds that the loan has been requested for\\n        @param requestTime The timestamp at which the loan was requested\\n     */\\n    struct LoanRequest {\\n        address payable borrower;\\n        address recipient;\\n        address consensusAddress;\\n        uint256 requestNonce;\\n        uint256 amount;\\n        uint256 duration;\\n        uint256 requestTime;\\n    }\\n\\n    /**\\n        @notice Borrower response object to take out a loan\\n        @param signer The wallet address of the signer validating the interest request of the lender\\n        @param consensusAddress The address of the Teller loan consensus contract to which the request should be sent\\n        @param responseTime The timestamp at which the response was sent\\n        @param interestRate The signed interest rate generated by the signer's Credit Risk Algorithm (CRA)\\n        @param collateralRatio The ratio of collateral to loan amount that is generated by the signer's Credit Risk Algorithm (CRA)\\n        @param maxLoanAmount The largest amount of tokens that can be taken out in the loan by the borrower\\n        @param signature The signature generated by the signer in the format of the above Signature struct\\n     */\\n    struct LoanResponse {\\n        address signer;\\n        address consensusAddress;\\n        uint256 responseTime;\\n        uint256 interestRate;\\n        uint256 collateralRatio;\\n        uint256 maxLoanAmount;\\n        Signature signature;\\n    }\\n\\n    /**\\n        @notice Represents loan terms based on consensus values\\n        @param interestRate The consensus value for the interest rate based on all the loan responses from the signers\\n        @param collateralRatio The consensus value for the ratio of collateral to loan amount required for the loan, based on all the loan responses from the signers\\n        @param maxLoanAmount The consensus value for the largest amount of tokens that can be taken out in the loan, based on all the loan responses from the signers\\n     */\\n    struct AccruedLoanTerms {\\n        NumbersList.Values interestRate;\\n        NumbersList.Values collateralRatio;\\n        NumbersList.Values maxLoanAmount;\\n    }\\n\\n    /**\\n        @notice Represents the terms of a loan based on the consensus of a LoanRequest\\n        @param borrower The wallet address of the borrower\\n        @param recipient The address where funds will be sent, only applicable in over collateralized loans\\n        @param interestRate The consensus interest rate calculated based on all signer loan responses\\n        @param collateralRatio The consensus ratio of collateral to loan amount calculated based on all signer loan responses\\n        @param maxLoanAmount The consensus largest amount of tokens that can be taken out in the loan by the borrower, calculated based on all signer loan responses\\n        @param duration The consensus length of loan time, calculated based on all signer loan responses\\n     */\\n    struct LoanTerms {\\n        address payable borrower;\\n        address recipient;\\n        uint256 interestRate;\\n        uint256 collateralRatio;\\n        uint256 maxLoanAmount;\\n        uint256 duration;\\n    }\\n\\n    /**\\n        @notice Data per borrow as struct\\n        @param id The id of the loan for internal tracking\\n        @param loanTerms The loan terms returned by the signers\\n        @param termsExpiry The timestamp at which the loan terms expire, after which if the loan is not yet active, cannot be taken out\\n        @param loanStartTime The timestamp at which the loan became active\\n        @param collateral The total amount of collateral deposited by the borrower to secure the loan\\n        @param lastCollateralIn The amount of collateral that was last deposited by the borrower to keep the loan active\\n        @param principalOwed The total amount of the loan taken out by the borrower, reduces on loan repayments\\n        @param interestOwed The total interest owed by the borrower for the loan, reduces on loan repayments\\n        @param borrowedAmount The total amount of the loan size taken out\\n        @param escrow The address of the escrow contract that holds the funds taken out in the loan on behalf of the borrower\\n        @param status The status of the loan currently based on the LoanStatus enum - NonExistent, TermsSet, Active, Closed\\n        @param liquidated Flag marking if the loan has been liquidated or not\\n     */\\n    struct Loan {\\n        uint256 id;\\n        LoanTerms loanTerms;\\n        uint256 termsExpiry;\\n        uint256 loanStartTime;\\n        uint256 collateral;\\n        uint256 lastCollateralIn;\\n        uint256 principalOwed;\\n        uint256 interestOwed;\\n        uint256 borrowedAmount;\\n        address escrow;\\n        LoanStatus status;\\n        bool liquidated;\\n    }\\n\\n    /**\\n        @notice This struct defines the dapp address and data to execute in the callDapp function.\\n        @dev It is executed using a delegatecall in the Escrow contract.\\n        @param exists Flag marking whether the dapp is a Teller registered address\\n        @param unsecured Flag marking if the loan allowed to be used in the dapp is a secured, or unsecured loan\\n     */\\n    struct Dapp {\\n        bool exists;\\n        bool unsecured;\\n    }\\n\\n    /**\\n        @notice This struct defines the dapp address and data to execute in the callDapp function.\\n        @dev It is executed using a delegatecall in the Escrow contract.\\n        @param location The proxy contract address for the dapp that will be used by the Escrow contract delegatecall\\n        @param data The encoded function signature with parameters for the dapp method in bytes that will be sent in the Escrow delegatecall\\n     */\\n    struct DappData {\\n        address location;\\n        bytes data;\\n    }\\n\\n    /**\\n        @notice This struct defines a market in the platform.\\n        @dev It is used by the MarketFactory contract.\\n        @param loans The address for the Teller LoanManager contract that is being used for a market\\n        @param lendingPool The address for the Teller Lending Pool contract that is being used for a market\\n        @param loanTermsConsensus The address for the Teller Loan Terms Consensus contract that is being used for a market\\n        @param exists Flag marking if the market is defined on the platform or not\\n     */\\n    struct Market {\\n        address loans;\\n        address lendingPool;\\n        address loanTermsConsensus;\\n        bool exists;\\n    }\\n\\n    /**\\n        @notice This struct is used to register new logic versions.\\n        @param logic The address for the new contract holding the logic.\\n        @param logicName The name for the logic to be stored as.\\n     */\\n    struct CreateLogicVersionRequest {\\n        address logic;\\n        bytes32 logicName;\\n    }\\n\\n    /**\\n        @notice This struct is used to upgrade logic versions.\\n        @param logic The new logic address to upgrade proxy to.\\n        @param logicName The name for the logic to be stored as.\\n        @param proxy The (optional) DynamicUpgradeable proxy address to attempt to directly upgrade.\\n     */\\n    struct UpgradeLogicVersionRequest {\\n        address logic;\\n        bytes32 logicName;\\n        address proxy;\\n    }\\n}\\n\",\"keccak256\":\"0x15adc0f2cf2cb637c3821da7710fa609e05ae973629bb78e3747b3814324222b\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611909806100206000396000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c80637f7c149111610097578063dbb21d4011610066578063dbb21d40146102b5578063e06174e4146102eb578063e154e9a4146102f3578063e7d535e5146102fb576100f5565b80637f7c1491146101f65780638129fc1c1461022457806392a38e5d1461022c578063a693686f1461027d576100f5565b80634f8654bc116100d35780634f8654bc1461016057806355dbd8eb1461016857806361e828061461018e57806375151b63146101bc576100f5565b806329092d0e146100fa5780632c26486d1461012257806337c3eedc1461013c575b600080fd5b6101206004803603602081101561011057600080fd5b50356001600160a01b0316610371565b005b61012a61051e565b60408051918252519081900360200190f35b610144610524565b604080516001600160a01b039092168252519081900360200190f35b610144610533565b6101206004803603602081101561017e57600080fd5b50356001600160a01b0316610547565b61012a600480360360408110156101a457600080fd5b506001600160a01b03813581169160200135166105cb565b6101e2600480360360208110156101d257600080fd5b50356001600160a01b03166105f6565b604080519115158252519081900360200190f35b6101206004803603604081101561020c57600080fd5b506001600160a01b038135811691602001351661062d565b61012061074d565b61025a6004803603604081101561024257600080fd5b506001600160a01b0381358116916020013516610758565b604080516001600160a01b03909316835290151560208301528051918290030190f35b6101206004803603606081101561029357600080fd5b506001600160a01b038135811691602081013582169160409091013516610787565b61012a600480360360608110156102cb57600080fd5b506001600160a01b03813581169160208101359091169060400135610b0f565b610144610b3a565b6101e2610b49565b6103216004803603602081101561031157600080fd5b50356001600160a01b0316610b52565b60408051602080825283518183015283519192839290830191858101910280838360005b8381101561035d578181015183820152602001610345565b505050509050019250505060405180910390f35b600480546040805163c095ea2760e01b81523393810193909352516001600160a01b039091169163c095ea27916024808301926000929190829003018186803b1580156103bd57600080fd5b505afa1580156103d1573d6000803e3d6000fd5b505050506103de81610bc8565b6001600160a01b03811660009081526010602052604081209192505b815481101561050c576000806104308585858154811061041657fe5b6000918252602090912001546001600160a01b0316610cd0565b915091508015610499576000600f600086868154811061044c57fe5b6000918252602080832091909101546001600160a01b03908116845283820194909452604092830182208a8516835290522080546001600160a01b03191692909116919091179055610502565b6001600160a01b0385166000908152600f60205260408120855482908790879081106104c157fe5b6000918252602080832091909101546001600160a01b039081168452908301939093526040909101902080546001600160a01b031916929091169190911790555b50506001016103fa565b506000610519828261182b565b505050565b60015481565b6000546001600160a01b031681565b60025461010090046001600160a01b031681565b6000546001600160a01b0316331461059f576040805162461bcd60e51b81526020600482015260166024820152754d5553545f42455f4c4f4749435f524547495354525960501b604482015290519081900360640190fd5b600280546001600160a01b0390921661010002610100600160a81b031990921691909117905543600355565b60006105d683610bc8565b92506105e182610bc8565b91506105ed8383610d5f565b90505b92915050565b600061060182610bc8565b6001600160a01b03811660009081526010602052604081209193509061062690611036565b1192915050565b600480546040805163c095ea2760e01b81523393810193909352516001600160a01b039091169163c095ea27916024808301926000929190829003018186803b15801561067957600080fd5b505afa15801561068d573d6000803e3d6000fd5b5050505061069a82610bc8565b91506106a581610bc8565b905060006106b38383610cd0565b5090506106c8816001600160a01b031661103a565b156106d35750610749565b6001600160a01b038084166000818152600f60209081526040808320948716835293815283822080546001600160a01b0319169055918152601090915220610721908363ffffffff61104716565b6001600160a01b0382166000908152601060205260409020610519908463ffffffff61104716565b5050565b61075633611074565b565b60008061076484610bc8565b935061076f83610bc8565b925061077b8484610cd0565b915091505b9250929050565b600480546040805163c095ea2760e01b81523393810193909352516001600160a01b039091169163c095ea27916024808301926000929190829003018186803b1580156107d357600080fd5b505afa1580156107e7573d6000803e3d6000fd5b505050506107f483610bc8565b92506107ff82610bc8565b9150600061080d8484610cd0565b509050610822816001600160a01b031661103a565b610873576040805162461bcd60e51b815260206004820152601d60248201527f434841494e4c494e4b5f504149525f414c52454144595f455849535453000000604482015290519081900360640190fd5b610885846001600160a01b03166110e4565b806109085750600480546040805163539a783760e11b815290516001600160a01b039092169263a734f06e928282019260209290829003018186803b1580156108cd57600080fd5b505afa1580156108e1573d6000803e3d6000fd5b505050506040513d60208110156108f757600080fd5b50516001600160a01b038581169116145b610950576040805162461bcd60e51b81526020600482015260146024820152731513d2d15397d057d393d517d0d3d395149050d560621b604482015290519081900360640190fd5b610962836001600160a01b03166110e4565b806109e55750600480546040805163539a783760e11b815290516001600160a01b039092169263a734f06e928282019260209290829003018186803b1580156109aa57600080fd5b505afa1580156109be573d6000803e3d6000fd5b505050506040513d60208110156109d457600080fd5b50516001600160a01b038481169116145b610a2d576040805162461bcd60e51b81526020600482015260146024820152731513d2d15397d097d393d517d0d3d395149050d560621b604482015290519081900360640190fd5b610a3f826001600160a01b03166110e4565b610a90576040805162461bcd60e51b815260206004820152601760248201527f41474752454741544f525f4e4f545f434f4e5452414354000000000000000000604482015290519081900360640190fd5b6001600160a01b038481166000818152600f602090815260408083208886168452825280832080546001600160a01b03191695881695909517909455918152601090915220610adf908461111d565b506001600160a01b0383166000908152601060205260409020610b08908563ffffffff61111d16565b5050505050565b6000610b1a84610bc8565b9350610b2583610bc8565b9250610b3284848461120d565b949350505050565b6004546001600160a01b031681565b60025460ff1681565b6001600160a01b038116600090815260106020908152604091829020805483518184028101840190945280845260609392830182828015610bbc57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610b9e575b50505050509050919050565b6000600460009054906101000a90046001600160a01b03166001600160a01b031663040141e56040518163ffffffff1660e01b815260040160206040518083038186803b158015610c1857600080fd5b505afa158015610c2c573d6000803e3d6000fd5b505050506040513d6020811015610c4257600080fd5b50516001600160a01b03838116911614610c5c57816105f0565b600480546040805163539a783760e11b815290516001600160a01b039092169263a734f06e928282019260209290829003018186803b158015610c9e57600080fd5b505afa158015610cb2573d6000803e3d6000fd5b505050506040513d6020811015610cc857600080fd5b505192915050565b6001600160a01b038281166000908152600f6020908152604080832085851684529091528120549091161580610d2d576001600160a01b038085166000908152600f60209081526040808320878516845290915290205416610d56565b6001600160a01b038084166000908152600f602090815260408083208885168452909152902054165b91509250929050565b6000806000610d6e8585610cd0565b915091506000610d7d85611247565b60ff169050600a81900a6001600160a01b03841615610f13576000846001600160a01b03166350d25bcd6040518163ffffffff1660e01b815260040160206040518083038186803b158015610dd157600080fd5b505afa158015610de5573d6000803e3d6000fd5b505050506040513d6020811015610dfb57600080fd5b50516040805163313ce56760e01b815290519192506000916001600160a01b0388169163313ce567916004808301926020929190829003018186803b158015610e4357600080fd5b505afa158015610e57573d6000803e3d6000fd5b505050506040513d6020811015610e6d57600080fd5b505160ff1690508415610ea057610e9d82610e8e838063ffffffff61134716565b600a0a9063ffffffff6113a116565b91505b80841115610ed257610ecb610ebb858363ffffffff61145916565b8390600a0a63ffffffff61149b16565b9150610ef8565b610ef5610ee5828663ffffffff61145916565b8390600a0a63ffffffff6113a116565b91505b6000610f038a611247565b509196506105f095505050505050565b60005b6001600160a01b038816600090815260106020526040902054811015610fef576001600160a01b0388166000908152601060205260408120805483908110610f5a57fe5b60009182526020808320909101546001600160a01b0316808352601090915260408220909250610f90908a63ffffffff61154416565b5090508015610fe5576000610fa58b84610d5f565b90506000610fb38b85610d5f565b9050610fd581610fc9848963ffffffff61149b16565b9063ffffffff6113a116565b99505050505050505050506105f0565b5050600101610f16565b506040805162461bcd60e51b815260206004820152601660248201527543414e4e4f545f43414c43554c4154455f56414c554560501b604482015290519081900360640190fd5b5490565b6001600160a01b03161590565b6000806110548484611544565b9150915081611064575050610749565b61106e848261159c565b50505050565b60408051808201909152601981527f53455454494e47535f4d5553545f42455f50524f56494445440000000000000060208201526110c2906001600160a01b0383169063ffffffff61163016565b600480546001600160a01b0319166001600160a01b0392909216919091179055565b6000813f7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470818114801590610b32575050151592915050565b60006111706040518060400160405280601981526020017f454d5054595f414444524553535f4e4f545f414c4c4f57454400000000000000815250836001600160a01b031661163090919063ffffffff16565b60008061117d8585611544565b9150915081156111c5576040805162461bcd60e51b815260206004820152600e60248201526d414444524553535f45584953545360901b604482015290519081900360640190fd5b505082546001818101855560008581526020808220840180546001600160a01b039097166001600160a01b031990971687179055948152940190925250604090912081905590565b6000610b3261121b85611247565b60ff16600a0a61123b61122e8787610d5f565b859063ffffffff6116c316565b9063ffffffff61171c16565b6000600460009054906101000a90046001600160a01b03166001600160a01b031663a734f06e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561129757600080fd5b505afa1580156112ab573d6000803e3d6000fd5b505050506040513d60208110156112c157600080fd5b50516001600160a01b0383811691161461133f57816001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561130e57600080fd5b505afa158015611322573d6000803e3d6000fd5b505050506040513d602081101561133857600080fd5b50516105f0565b506012919050565b6000828201838110156105ed576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b6000816113f5576040805162461bcd60e51b815260206004820181905260248201527f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f604482015290519081900360640190fd5b816000191480156114095750600160ff1b83145b156114455760405162461bcd60e51b815260040180806020018281038252602181526020018061186c6021913960400191505060405180910390fd5b600082848161145057fe5b05949350505050565b60006105ed83836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f77000081525061175e565b6000826114aa575060006105f0565b826000191480156114be5750600160ff1b82145b156114fa5760405162461bcd60e51b81526004018080602001828103825260278152602001806118ae6027913960400191505060405180910390fd5b8282028284828161150757fe5b05146105ed5760405162461bcd60e51b81526004018080602001828103825260278152602001806118ae6027913960400191505060405180910390fd5b815460009081901561078057506001600160a01b0382166000818152600185016020526040902054845490919085908390811061157d57fe5b6000918252602090912001546001600160a01b03161491509250929050565b815481106115a957610749565b8154600019018114611620578154829060001981019081106115c757fe5b9060005260206000200160009054906101000a90046001600160a01b03168282815481106115f157fe5b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b031602179055505b815461051983600019830161182b565b611639826117b8565b81906105195760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015611688578181015183820152602001611670565b50505050905090810190601f1680156116b55780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b6000826116d2575060006105f0565b828202828482816116df57fe5b04146105ed5760405162461bcd60e51b815260040180806020018281038252602181526020018061188d6021913960400191505060405180910390fd5b60006105ed83836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f0000000000008152506117c6565b600081848411156117b05760405162461bcd60e51b8152602060048201818152835160248401528351909283926044909101919085019080838360008315611688578181015183820152602001611670565b505050900390565b6001600160a01b0316151590565b600081836118155760405162461bcd60e51b8152602060048201818152835160248401528351909283926044909101919085019080838360008315611688578181015183820152602001611670565b50600083858161182157fe5b0495945050505050565b8154818355818111156105195760008381526020902061051991810190830161186891905b808211156118645760008155600101611850565b5090565b9056fe5369676e6564536166654d6174683a206469766973696f6e206f766572666c6f77536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f77a265627a7a72315820e52559bd8b9e04f55826d13f3da32a0fd2f2c5810082eabbaab3d4f33a0d99b364736f6c63430005110032",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100f55760003560e01c80637f7c149111610097578063dbb21d4011610066578063dbb21d40146102b5578063e06174e4146102eb578063e154e9a4146102f3578063e7d535e5146102fb576100f5565b80637f7c1491146101f65780638129fc1c1461022457806392a38e5d1461022c578063a693686f1461027d576100f5565b80634f8654bc116100d35780634f8654bc1461016057806355dbd8eb1461016857806361e828061461018e57806375151b63146101bc576100f5565b806329092d0e146100fa5780632c26486d1461012257806337c3eedc1461013c575b600080fd5b6101206004803603602081101561011057600080fd5b50356001600160a01b0316610371565b005b61012a61051e565b60408051918252519081900360200190f35b610144610524565b604080516001600160a01b039092168252519081900360200190f35b610144610533565b6101206004803603602081101561017e57600080fd5b50356001600160a01b0316610547565b61012a600480360360408110156101a457600080fd5b506001600160a01b03813581169160200135166105cb565b6101e2600480360360208110156101d257600080fd5b50356001600160a01b03166105f6565b604080519115158252519081900360200190f35b6101206004803603604081101561020c57600080fd5b506001600160a01b038135811691602001351661062d565b61012061074d565b61025a6004803603604081101561024257600080fd5b506001600160a01b0381358116916020013516610758565b604080516001600160a01b03909316835290151560208301528051918290030190f35b6101206004803603606081101561029357600080fd5b506001600160a01b038135811691602081013582169160409091013516610787565b61012a600480360360608110156102cb57600080fd5b506001600160a01b03813581169160208101359091169060400135610b0f565b610144610b3a565b6101e2610b49565b6103216004803603602081101561031157600080fd5b50356001600160a01b0316610b52565b60408051602080825283518183015283519192839290830191858101910280838360005b8381101561035d578181015183820152602001610345565b505050509050019250505060405180910390f35b600480546040805163c095ea2760e01b81523393810193909352516001600160a01b039091169163c095ea27916024808301926000929190829003018186803b1580156103bd57600080fd5b505afa1580156103d1573d6000803e3d6000fd5b505050506103de81610bc8565b6001600160a01b03811660009081526010602052604081209192505b815481101561050c576000806104308585858154811061041657fe5b6000918252602090912001546001600160a01b0316610cd0565b915091508015610499576000600f600086868154811061044c57fe5b6000918252602080832091909101546001600160a01b03908116845283820194909452604092830182208a8516835290522080546001600160a01b03191692909116919091179055610502565b6001600160a01b0385166000908152600f60205260408120855482908790879081106104c157fe5b6000918252602080832091909101546001600160a01b039081168452908301939093526040909101902080546001600160a01b031916929091169190911790555b50506001016103fa565b506000610519828261182b565b505050565b60015481565b6000546001600160a01b031681565b60025461010090046001600160a01b031681565b6000546001600160a01b0316331461059f576040805162461bcd60e51b81526020600482015260166024820152754d5553545f42455f4c4f4749435f524547495354525960501b604482015290519081900360640190fd5b600280546001600160a01b0390921661010002610100600160a81b031990921691909117905543600355565b60006105d683610bc8565b92506105e182610bc8565b91506105ed8383610d5f565b90505b92915050565b600061060182610bc8565b6001600160a01b03811660009081526010602052604081209193509061062690611036565b1192915050565b600480546040805163c095ea2760e01b81523393810193909352516001600160a01b039091169163c095ea27916024808301926000929190829003018186803b15801561067957600080fd5b505afa15801561068d573d6000803e3d6000fd5b5050505061069a82610bc8565b91506106a581610bc8565b905060006106b38383610cd0565b5090506106c8816001600160a01b031661103a565b156106d35750610749565b6001600160a01b038084166000818152600f60209081526040808320948716835293815283822080546001600160a01b0319169055918152601090915220610721908363ffffffff61104716565b6001600160a01b0382166000908152601060205260409020610519908463ffffffff61104716565b5050565b61075633611074565b565b60008061076484610bc8565b935061076f83610bc8565b925061077b8484610cd0565b915091505b9250929050565b600480546040805163c095ea2760e01b81523393810193909352516001600160a01b039091169163c095ea27916024808301926000929190829003018186803b1580156107d357600080fd5b505afa1580156107e7573d6000803e3d6000fd5b505050506107f483610bc8565b92506107ff82610bc8565b9150600061080d8484610cd0565b509050610822816001600160a01b031661103a565b610873576040805162461bcd60e51b815260206004820152601d60248201527f434841494e4c494e4b5f504149525f414c52454144595f455849535453000000604482015290519081900360640190fd5b610885846001600160a01b03166110e4565b806109085750600480546040805163539a783760e11b815290516001600160a01b039092169263a734f06e928282019260209290829003018186803b1580156108cd57600080fd5b505afa1580156108e1573d6000803e3d6000fd5b505050506040513d60208110156108f757600080fd5b50516001600160a01b038581169116145b610950576040805162461bcd60e51b81526020600482015260146024820152731513d2d15397d057d393d517d0d3d395149050d560621b604482015290519081900360640190fd5b610962836001600160a01b03166110e4565b806109e55750600480546040805163539a783760e11b815290516001600160a01b039092169263a734f06e928282019260209290829003018186803b1580156109aa57600080fd5b505afa1580156109be573d6000803e3d6000fd5b505050506040513d60208110156109d457600080fd5b50516001600160a01b038481169116145b610a2d576040805162461bcd60e51b81526020600482015260146024820152731513d2d15397d097d393d517d0d3d395149050d560621b604482015290519081900360640190fd5b610a3f826001600160a01b03166110e4565b610a90576040805162461bcd60e51b815260206004820152601760248201527f41474752454741544f525f4e4f545f434f4e5452414354000000000000000000604482015290519081900360640190fd5b6001600160a01b038481166000818152600f602090815260408083208886168452825280832080546001600160a01b03191695881695909517909455918152601090915220610adf908461111d565b506001600160a01b0383166000908152601060205260409020610b08908563ffffffff61111d16565b5050505050565b6000610b1a84610bc8565b9350610b2583610bc8565b9250610b3284848461120d565b949350505050565b6004546001600160a01b031681565b60025460ff1681565b6001600160a01b038116600090815260106020908152604091829020805483518184028101840190945280845260609392830182828015610bbc57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610b9e575b50505050509050919050565b6000600460009054906101000a90046001600160a01b03166001600160a01b031663040141e56040518163ffffffff1660e01b815260040160206040518083038186803b158015610c1857600080fd5b505afa158015610c2c573d6000803e3d6000fd5b505050506040513d6020811015610c4257600080fd5b50516001600160a01b03838116911614610c5c57816105f0565b600480546040805163539a783760e11b815290516001600160a01b039092169263a734f06e928282019260209290829003018186803b158015610c9e57600080fd5b505afa158015610cb2573d6000803e3d6000fd5b505050506040513d6020811015610cc857600080fd5b505192915050565b6001600160a01b038281166000908152600f6020908152604080832085851684529091528120549091161580610d2d576001600160a01b038085166000908152600f60209081526040808320878516845290915290205416610d56565b6001600160a01b038084166000908152600f602090815260408083208885168452909152902054165b91509250929050565b6000806000610d6e8585610cd0565b915091506000610d7d85611247565b60ff169050600a81900a6001600160a01b03841615610f13576000846001600160a01b03166350d25bcd6040518163ffffffff1660e01b815260040160206040518083038186803b158015610dd157600080fd5b505afa158015610de5573d6000803e3d6000fd5b505050506040513d6020811015610dfb57600080fd5b50516040805163313ce56760e01b815290519192506000916001600160a01b0388169163313ce567916004808301926020929190829003018186803b158015610e4357600080fd5b505afa158015610e57573d6000803e3d6000fd5b505050506040513d6020811015610e6d57600080fd5b505160ff1690508415610ea057610e9d82610e8e838063ffffffff61134716565b600a0a9063ffffffff6113a116565b91505b80841115610ed257610ecb610ebb858363ffffffff61145916565b8390600a0a63ffffffff61149b16565b9150610ef8565b610ef5610ee5828663ffffffff61145916565b8390600a0a63ffffffff6113a116565b91505b6000610f038a611247565b509196506105f095505050505050565b60005b6001600160a01b038816600090815260106020526040902054811015610fef576001600160a01b0388166000908152601060205260408120805483908110610f5a57fe5b60009182526020808320909101546001600160a01b0316808352601090915260408220909250610f90908a63ffffffff61154416565b5090508015610fe5576000610fa58b84610d5f565b90506000610fb38b85610d5f565b9050610fd581610fc9848963ffffffff61149b16565b9063ffffffff6113a116565b99505050505050505050506105f0565b5050600101610f16565b506040805162461bcd60e51b815260206004820152601660248201527543414e4e4f545f43414c43554c4154455f56414c554560501b604482015290519081900360640190fd5b5490565b6001600160a01b03161590565b6000806110548484611544565b9150915081611064575050610749565b61106e848261159c565b50505050565b60408051808201909152601981527f53455454494e47535f4d5553545f42455f50524f56494445440000000000000060208201526110c2906001600160a01b0383169063ffffffff61163016565b600480546001600160a01b0319166001600160a01b0392909216919091179055565b6000813f7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470818114801590610b32575050151592915050565b60006111706040518060400160405280601981526020017f454d5054595f414444524553535f4e4f545f414c4c4f57454400000000000000815250836001600160a01b031661163090919063ffffffff16565b60008061117d8585611544565b9150915081156111c5576040805162461bcd60e51b815260206004820152600e60248201526d414444524553535f45584953545360901b604482015290519081900360640190fd5b505082546001818101855560008581526020808220840180546001600160a01b039097166001600160a01b031990971687179055948152940190925250604090912081905590565b6000610b3261121b85611247565b60ff16600a0a61123b61122e8787610d5f565b859063ffffffff6116c316565b9063ffffffff61171c16565b6000600460009054906101000a90046001600160a01b03166001600160a01b031663a734f06e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561129757600080fd5b505afa1580156112ab573d6000803e3d6000fd5b505050506040513d60208110156112c157600080fd5b50516001600160a01b0383811691161461133f57816001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561130e57600080fd5b505afa158015611322573d6000803e3d6000fd5b505050506040513d602081101561133857600080fd5b50516105f0565b506012919050565b6000828201838110156105ed576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b6000816113f5576040805162461bcd60e51b815260206004820181905260248201527f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f604482015290519081900360640190fd5b816000191480156114095750600160ff1b83145b156114455760405162461bcd60e51b815260040180806020018281038252602181526020018061186c6021913960400191505060405180910390fd5b600082848161145057fe5b05949350505050565b60006105ed83836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f77000081525061175e565b6000826114aa575060006105f0565b826000191480156114be5750600160ff1b82145b156114fa5760405162461bcd60e51b81526004018080602001828103825260278152602001806118ae6027913960400191505060405180910390fd5b8282028284828161150757fe5b05146105ed5760405162461bcd60e51b81526004018080602001828103825260278152602001806118ae6027913960400191505060405180910390fd5b815460009081901561078057506001600160a01b0382166000818152600185016020526040902054845490919085908390811061157d57fe5b6000918252602090912001546001600160a01b03161491509250929050565b815481106115a957610749565b8154600019018114611620578154829060001981019081106115c757fe5b9060005260206000200160009054906101000a90046001600160a01b03168282815481106115f157fe5b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b031602179055505b815461051983600019830161182b565b611639826117b8565b81906105195760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015611688578181015183820152602001611670565b50505050905090810190601f1680156116b55780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b6000826116d2575060006105f0565b828202828482816116df57fe5b04146105ed5760405162461bcd60e51b815260040180806020018281038252602181526020018061188d6021913960400191505060405180910390fd5b60006105ed83836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f0000000000008152506117c6565b600081848411156117b05760405162461bcd60e51b8152602060048201818152835160248401528351909283926044909101919085019080838360008315611688578181015183820152602001611670565b505050900390565b6001600160a01b0316151590565b600081836118155760405162461bcd60e51b8152602060048201818152835160248401528351909283926044909101919085019080838360008315611688578181015183820152602001611670565b50600083858161182157fe5b0495945050505050565b8154818355818111156105195760008381526020902061051991810190830161186891905b808211156118645760008155600101611850565b5090565b9056fe5369676e6564536166654d6174683a206469766973696f6e206f766572666c6f77536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f77a265627a7a72315820e52559bd8b9e04f55826d13f3da32a0fd2f2c5810082eabbaab3d4f33a0d99b364736f6c63430005110032",
  "devdoc": {
    "author": "develop@teller.finance",
    "details": "It tries to find an aggregator using the token addresses supplied. If unable, it uses ETH as a pass through asset to construct a path conversion.",
    "methods": {
      "add(address,address,address)": {
        "params": {
          "aggregator": "Price aggregator address.",
          "dst": "Destination token address.",
          "src": "Source token address."
        }
      },
      "aggregatorFor(address,address)": {
        "params": {
          "dst": "Destination token address.",
          "src": "Source token address."
        },
        "return": "AggregatorV2V3Interface The Chainlink Aggregator address.bool whether or not the values from the Aggregator should be considered inverted."
      },
      "isTokenSupported(address)": {
        "params": {
          "tokenAddress": "Token address to check support for."
        },
        "return": "bool whether or not the token is supported."
      },
      "latestAnswerFor(address,address)": {
        "details": "It tries to use ETH as a pass through asset if the direct pair is not supported.",
        "params": {
          "dst": "Destination token address.",
          "src": "Source token address."
        },
        "return": "int256 The latest answer as given from Chainlink."
      },
      "remove(address)": {
        "params": {
          "tokenAddress": "Token to remove all markets for."
        }
      },
      "remove(address,address)": {
        "params": {
          "dst": "Destination token address.",
          "src": "Source token address."
        }
      },
      "valueFor(address,address,uint256)": {
        "params": {
          "dst": "Destination token address.",
          "src": "Source token address.",
          "srcAmount": "Amount of the source token to convert into the destination token."
        },
        "return": "uint256 Value of the source token amount in destination tokens."
      }
    }
  },
  "userdoc": {
    "methods": {
      "add(address,address,address)": {
        "notice": "It allows for additional Chainlink Aggregators to be supported."
      },
      "aggregatorFor(address,address)": {
        "notice": "It grabs the Chainlink Aggregator contract address for the token pair if it is supported."
      },
      "initialize()": {
        "notice": "It initializes this ChainlinkAggregator instance."
      },
      "isTokenSupported(address)": {
        "notice": "It checks if the token is supported."
      },
      "latestAnswerFor(address,address)": {
        "notice": "It returns the price of the token pair as given from the Chainlink Aggregator."
      },
      "remove(address)": {
        "notice": "It removes support for a Chainlink Aggregator."
      },
      "remove(address,address)": {
        "notice": "It removes support for a Chainlink Aggregator pair."
      },
      "valueFor(address,address,uint256)": {
        "notice": "It calculates the value of a token amount into another."
      }
    },
    "notice": "This contract is used to fetch and calculate prices and values from one token to another through Chainlink Aggregators."
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11226,
        "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
        "label": "logicRegistry",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(LogicVersionsRegistryInterface)11867"
      },
      {
        "astId": 11228,
        "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
        "label": "logicName",
        "offset": 0,
        "slot": "1",
        "type": "t_bytes32"
      },
      {
        "astId": 11230,
        "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
        "label": "strictDynamic",
        "offset": 0,
        "slot": "2",
        "type": "t_bool"
      },
      {
        "astId": 11232,
        "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
        "label": "implementationStored",
        "offset": 1,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 11234,
        "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
        "label": "_implementationBlockUpdated",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 1762,
        "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
        "label": "settings",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(SettingsInterface)12172"
      },
      {
        "astId": 1766,
        "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
        "label": "__gap",
        "offset": 0,
        "slot": "5",
        "type": "t_array(t_uint256)10_storage"
      },
      {
        "astId": 12972,
        "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
        "label": "aggregators",
        "offset": 0,
        "slot": "15",
        "type": "t_mapping(t_address,t_mapping(t_address,t_address))"
      },
      {
        "astId": 12976,
        "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
        "label": "supportedTokens",
        "offset": 0,
        "slot": "16",
        "type": "t_mapping(t_address,t_struct(AddressArray)14159_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)10_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[10]",
        "numberOfBytes": "320"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(LogicVersionsRegistryInterface)11867": {
        "encoding": "inplace",
        "label": "contract LogicVersionsRegistryInterface",
        "numberOfBytes": "20"
      },
      "t_contract(SettingsInterface)12172": {
        "encoding": "inplace",
        "label": "contract SettingsInterface",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_mapping(t_address,t_address))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_address)"
      },
      "t_mapping(t_address,t_struct(AddressArray)14159_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct AddressArrayLib.AddressArray)",
        "numberOfBytes": "32",
        "value": "t_struct(AddressArray)14159_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(AddressArray)14159_storage": {
        "encoding": "inplace",
        "label": "struct AddressArrayLib.AddressArray",
        "members": [
          {
            "astId": 14154,
            "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
            "label": "array",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 14158,
            "contract": "contracts/providers/chainlink/ChainlinkAggregator.sol:ChainlinkAggregator",
            "label": "indices",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_uint256)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}
