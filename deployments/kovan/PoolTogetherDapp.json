{
  "address": "0x3b5A764c1220BeFeb193564f5DCfeE8868701429",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "logicRegistryAddress",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "aLogicName",
          "type": "bytes32"
        },
        {
          "internalType": "bool",
          "name": "isStrictDynamic",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "_updateImplementationStored",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "implementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "implementationStored",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "logicName",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "logicRegistry",
      "outputs": [
        {
          "internalType": "contract LogicVersionsRegistryInterface",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "strictDynamic",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "upgradeProxyTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x11dbe7572c7baa9543cef1327a34d6c1696a25173c33ccb5f113a3df3f76170d",
  "receipt": {
    "to": null,
    "from": "0xAFe87013dc96edE1E116a288D80FcaA0eFFE5fe5",
    "contractAddress": "0x3b5A764c1220BeFeb193564f5DCfeE8868701429",
    "transactionIndex": 0,
    "gasUsed": "466378",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc3d0f8559088b38777bb2559bf796861cd9d99b30c25b67e7f335c53fdc0833a",
    "transactionHash": "0x11dbe7572c7baa9543cef1327a34d6c1696a25173c33ccb5f113a3df3f76170d",
    "logs": [],
    "blockNumber": 24117049,
    "cumulativeGasUsed": "466378",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x15FAaA69f9E4cCEDC38EFf6F1358a8208DbbFDa6",
    "0xb9acdc78d83e2ccba862e252a2ff8178ac2791d9cfa1bbb55cbf6a505e48a04c",
    false
  ],
  "solcInputHash": "0c80e7fb8aff27a671cb2892ea4bafd6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.3+commit.8d00100c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"logicRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"aLogicName\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isStrictDynamic\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_updateImplementationStored\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementationStored\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logicName\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logicRegistry\",\"outputs\":[{\"internalType\":\"contract LogicVersionsRegistryInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strictDynamic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeProxyTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"author\":\"develop@teller.finance\",\"kind\":\"dev\",\"methods\":{\"_updateImplementationStored()\":{\"details\":\"It uses the LogicVersionsRegistry contract to get the logic address or the cached address if valid.It caches the current logic address for the proxy to reduce gas on subsequent calls within the same block.\"},\"constructor\":{\"params\":{\"aLogicName\":\"the settings contract address.\",\"isStrictDynamic\":\"Boolean indicating if the proxy must check the registry for a new implementation.\",\"logicRegistryAddress\":\"the settings contract address.\"}},\"implementation()\":{\"returns\":{\"_0\":\"Address of the current implementation\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"_updateImplementationStored()\":{\"notice\":\"Updates the current implementation logic address for the stored logic name.\"},\"constructor\":{\"notice\":\"It creates a new dynamic proxy given a logic registry contract and a logic name.\"},\"implementation()\":{\"notice\":\"Returns the current implementation.\"},\"implementationStored()\":{\"notice\":\"It stores the last known logic address locally to reduce gas costs.\"},\"logicName()\":{\"notice\":\"It represent the logic name (key) used for this proxy.\"},\"logicRegistry()\":{\"notice\":\"It returns the logic registry that is used to determine the implementation logic for this proxy.\"},\"strictDynamic()\":{\"notice\":\"Boolean indicating if the proxy must check the registry for a new implementation.\"},\"upgradeProxyTo(address)\":{\"notice\":\"It updates a proxy's cached implementation address.It must only be called by the LogicVersionsRegistry for non strict DynamicProxy\"}},\"notice\":\"It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.It extends BaseUpgradeable to get access to the settings.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/base/proxies/DynamicProxy.sol\":\"DynamicProxy\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\",\"keccak256\":\"0xc706395df88dc1d459f21e51c57ab8820af80d1e8c3c14933a651794d78a429f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x069b2631bb5b5193a58ccf7a06266c7361bd2c20095667af4402817605627f45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2526b7c6a366fc211bbc176078ab02b83833e7682abcc5b3bed9d700b34e2a3e\",\"license\":\"MIT\"},\"contracts/base/proxies/BaseDynamicProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"./BaseProxy.sol\\\";\\nimport \\\"../upgradeable/DynamicUpgradeable.sol\\\";\\n\\n/**\\n    @notice It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.\\n    @notice It extends BaseUpgradeable to get access to the settings.\\n\\n    @author develop@teller.finance\\n */\\nabstract contract BaseDynamicProxy is BaseProxy, DynamicUpgradeable {\\n    function _implementation()\\n        internal\\n        view\\n        virtual\\n        override(DynamicUpgradeable, Proxy)\\n        returns (address)\\n    {\\n        return DynamicUpgradeable._implementation();\\n    }\\n\\n    /**\\n     * @notice It is called by the OZ proxy contract before calling the internal _implementation() function.\\n     */\\n    function _beforeFallback() internal override {\\n        if (strictDynamic && _implementationBlockUpdated + 50 <= block.number) {\\n            address(this).delegatecall(\\n                abi.encodeWithSignature(\\\"_updateImplementationStored()\\\")\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2df52440edf97dd9fb3e60220e6fa64446ba3b07cfa1b822bb5f42f69a538965\",\"license\":\"MIT\"},\"contracts/base/proxies/BaseProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Interfaces\\nimport \\\"../../interfaces/IBaseProxy.sol\\\";\\n\\n// Contracts\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\n\\n/**\\n    @notice It is the base Proxy contract for all other Proxy contracts.\\n    @dev It makes the current logic implementation address publicly available.\\n\\n    @author develop@teller.finance\\n */\\nabstract contract BaseProxy is IBaseProxy, Proxy {\\n    /**\\n        @notice Returns the current implementation.\\n        @return Address of the current implementation\\n     */\\n    function implementation() external view override returns (address) {\\n        return _implementation();\\n    }\\n}\\n\",\"keccak256\":\"0xffd928e3bea6e29964581b553e5566049086e9faed792cc264197ca7644fac5c\",\"license\":\"MIT\"},\"contracts/base/proxies/DynamicProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"./BaseDynamicProxy.sol\\\";\\n\\n/**\\n    @notice It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.\\n    @notice It extends BaseUpgradeable to get access to the settings.\\n\\n    @author develop@teller.finance\\n */\\ncontract DynamicProxy is BaseDynamicProxy {\\n    /**\\n        @notice It creates a new dynamic proxy given a logic registry contract and a logic name.\\n        @param logicRegistryAddress the settings contract address.\\n        @param aLogicName the settings contract address.\\n        @param isStrictDynamic Boolean indicating if the proxy must check the registry for a new implementation.\\n     */\\n    constructor(\\n        address logicRegistryAddress,\\n        bytes32 aLogicName,\\n        bool isStrictDynamic\\n    ) {\\n        logicRegistry = LogicVersionsRegistryInterface(logicRegistryAddress);\\n        logicName = aLogicName;\\n        strictDynamic = isStrictDynamic;\\n        _updateImplementationStored();\\n    }\\n}\\n\",\"keccak256\":\"0xb2f133f644ed91e9b8487381f941d4a92eb79de6971c651261f7956f723c7f1c\",\"license\":\"MIT\"},\"contracts/base/upgradeable/DynamicUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"./DynamicUpgradeableStorage.sol\\\";\\n\\n/*****************************************************************************************************/\\n/**                                             WARNING                                             **/\\n/**                              THIS CONTRACT IS AN UPGRADEABLE FACET!                             **/\\n/**  ---------------------------------------------------------------------------------------------  **/\\n/**  Do NOT place ANY storage/state variables directly in this contract! If you wish to make        **/\\n/**  make changes to the state variables used by this contract, do so in its defined Storage        **/\\n/**  contract that this contract inherits from                                                      **/\\n/**                                                                                                 **/\\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\\n/**  more information.                                                                              **/\\n/*****************************************************************************************************/\\n/**\\n * @notice This contract is used define the DynamicUpgradeable contracts logic.\\n *\\n * @author develop@teller.finance\\n */\\ncontract DynamicUpgradeable is DynamicUpgradeableStorage {\\n    /* Modifiers */\\n\\n    /**\\n     * @notice It checks if the proxy's implementation cache is invalidated and should be updated.\\n     * @dev Any external, non-view function should use this modifier.\\n     * @dev This modifier should be the very FIRST modifier for functions.\\n     */\\n    modifier updateImpIfNeeded() {\\n        if (_cacheInvalidated()) {\\n            _updateImplementationStored();\\n        }\\n        _;\\n    }\\n\\n    /* External Functions */\\n\\n    /**\\n     * @notice It updates a proxy's cached implementation address.\\n     * @notice It must only be called by the LogicVersionsRegistry for non strict DynamicProxy\\n     */\\n    function upgradeProxyTo(address newImplementation) public {\\n        require(msg.sender == address(logicRegistry), \\\"MUST_BE_LOGIC_REGISTRY\\\");\\n        implementationStored = newImplementation;\\n        _implementationBlockUpdated = block.number;\\n    }\\n\\n    /* Internal Functions **/\\n\\n    /**\\n     * @notice Returns the current implementation used by the proxy to delegate a call to.\\n     * @return address of the current implementation\\n     */\\n    function _implementation() internal view virtual returns (address) {\\n        if (_cacheInvalidated()) {\\n            (, , address currentLogic) =\\n                logicRegistry.getLogicVersion(logicName);\\n            return currentLogic;\\n        }\\n        return implementationStored;\\n    }\\n\\n    /**\\n     * @notice Updates the current implementation logic address for the stored logic name.\\n     * @dev It uses the LogicVersionsRegistry contract to get the logic address or the cached address if valid.\\n     * @dev It caches the current logic address for the proxy to reduce gas on subsequent calls within the same block.\\n     */\\n    function _updateImplementationStored() public {\\n        (, , address currentLogic) = logicRegistry.getLogicVersion(logicName);\\n\\n        if (implementationStored != currentLogic) {\\n            implementationStored = currentLogic;\\n        }\\n        _implementationBlockUpdated = block.number;\\n    }\\n\\n    /**\\n     * @notice It checks if the current cached address implementation is marked as invalidated.\\n     * @notice It is marked invalidated if the proxy is strict dynamic and last update was >= 50 blocks ago.\\n     * @return bool True if the cached implementation address is invalid.\\n     */\\n    function _cacheInvalidated() internal view returns (bool) {\\n        return strictDynamic && _implementationBlockUpdated + 1 <= block.number;\\n    }\\n}\\n\",\"keccak256\":\"0x1f81daf5440455fdbf9b4396f9bbf30107cd4aa20bdff11ac1d4ed9c01ff4dee\",\"license\":\"MIT\"},\"contracts/base/upgradeable/DynamicUpgradeableStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Interfaces\\nimport \\\"../../interfaces/LogicVersionsRegistryInterface.sol\\\";\\n\\n/*****************************************************************************************************/\\n/**                                             WARNING                                             **/\\n/**                        THIS CONTRACT IS A NON UPGRADEABLE STORAGE CONTRACT!                     **/\\n/**  ---------------------------------------------------------------------------------------------  **/\\n/**  Do NOT change the order of, PREPEND, or APPEND any storage variables to this or new versions   **/\\n/**  of this contract as this will cause a ripple affect to the storage slots of all child          **/\\n/**  contracts that inherit from this contract to be overwritten on the deployed proxy contract!!   **/\\n/**                                                                                                 **/\\n/**  Visit https://docs.openzeppelin.com/upgrades/2.6/proxies#upgrading-via-the-proxy-pattern for   **/\\n/**  more information.                                                                              **/\\n/*****************************************************************************************************/\\n/**\\n    @notice This contract is used define the storage variables for all DynamicUpgradeable contracts.\\n\\n    @author develop@teller.finance\\n */\\nabstract contract DynamicUpgradeableStorage {\\n    /**\\n     * @notice It returns the logic registry that is used to determine the implementation logic for this proxy.\\n     * @dev See LogicVersionsRegistry contract.\\n     * @return LogicVersionsRegistryInterface\\n     */\\n    LogicVersionsRegistryInterface public logicRegistry;\\n\\n    /**\\n     * @notice It represent the logic name (key) used for this proxy.\\n     * @dev It is used by LogicVersionsRegistry to get the logic address for the given logic name.\\n     * @dev It must NOT change over time.\\n     * @return bytes32 the logic name.\\n     */\\n    bytes32 public logicName;\\n\\n    /**\\n     * @notice Boolean indicating if the proxy must check the registry for a new implementation.\\n     */\\n    bool public strictDynamic;\\n\\n    /**\\n     * @notice It stores the last known logic address locally to reduce gas costs.\\n     */\\n    address public implementationStored;\\n\\n    /**\\n     * @dev It is the block number which the last time the proxy implementation was checked.\\n     */\\n    uint256 internal _implementationBlockUpdated;\\n}\\n\",\"keccak256\":\"0x9ec01157f5e16d63bff28a18fb5da1d103c307320ac3057eea7a9e7b68e5318c\",\"license\":\"MIT\"},\"contracts/interfaces/IBaseProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IBaseProxy {\\n    /**\\n        @notice Returns the current implementation.\\n        @return Address of the current implementation\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x53f172ad960a20215939523ffaf5aaebe27150373d4fd77de296212f7299ec95\",\"license\":\"MIT\"},\"contracts/interfaces/LogicVersionsRegistryInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Commons\\nimport \\\"../util/LogicVersionLib.sol\\\";\\nimport \\\"../util/TellerCommon.sol\\\";\\n\\n/**\\n    @notice It defines all the functions to manage the logic contract versions.\\n\\n    @author develop@teller.finance\\n */\\ninterface LogicVersionsRegistryInterface {\\n    /**\\n        @notice This event is emitted when a new logic version is created.\\n        @param logicName new logic name.\\n        @param logic address where the logic is.\\n        @param version initial version for the logic address.\\n     */\\n    event LogicVersionCreated(\\n        bytes32 indexed logicName,\\n        address indexed logic,\\n        uint256 version\\n    );\\n\\n    /**\\n        @notice This event is emitted when a logic version is rollbacked.\\n        @param logicName the logic name.\\n        @param oldLogic the old logic address.\\n        @param newLogic the new (or previous) logic address.\\n        @param oldVersion the old version.\\n        @param newVersion the new (previous) version.\\n     */\\n    event LogicVersionRollbacked(\\n        bytes32 indexed logicName,\\n        address oldLogic,\\n        address newLogic,\\n        uint256 oldVersion,\\n        uint256 newVersion\\n    );\\n\\n    /**\\n        @notice This event is emitted when a new logic version is upgraded.\\n        @param logicName new logic name.\\n        @param oldLogic the old logic address.\\n        @param newLogic the new logic address.\\n        @param oldVersion the old version.\\n        @param newVersion the new version.\\n     */\\n    event LogicVersionUpgraded(\\n        bytes32 indexed logicName,\\n        address oldLogic,\\n        address newLogic,\\n        uint256 oldVersion,\\n        uint256 newVersion\\n    );\\n\\n    /** External Functions */\\n\\n    /**\\n        @notice It creates multiple logic versions.\\n        @param newLogicVersions lists of the new logic versions to create.\\n     */\\n    function createLogicVersions(\\n        TellerCommon.CreateLogicVersionRequest[] calldata newLogicVersions\\n    ) external;\\n\\n    /**\\n        @notice It upgrades multiple logic addresses.\\n        @param newLogicVersions lists of the new logic versions to create.\\n     */\\n    function upgradeLogicVersions(\\n        TellerCommon.UpgradeLogicVersionRequest[] calldata newLogicVersions\\n    ) external;\\n\\n    /**\\n        @notice It upgrades a logic version given a logic name.\\n        @param logicName logic name to upgrade.\\n        @param newLogic the new logic address to set.\\n        @param proxy The (optional) DynamicUpgradeable proxy address to attempt to directly upgrade.\\n     */\\n    function upgradeLogicVersion(\\n        bytes32 logicName,\\n        address newLogic,\\n        address proxy\\n    ) external;\\n\\n    /**\\n        @notice It rollbacks a logic to a previous version.\\n        @param logicName logic name to rollback.\\n        @param previousVersion the previous version to be used.\\n     */\\n    function rollbackLogicVersion(bytes32 logicName, uint256 previousVersion)\\n        external;\\n\\n    /**\\n        @notice It gets the current logic version for a given logic name.\\n        @param logicName to get.\\n        @return currentVersion the current logic version number.\\n        @return latestVersion the latest version number (higher than current if rolled back).\\n        @return logic the address of the current logic version\\n     */\\n    function getLogicVersion(bytes32 logicName)\\n        external\\n        view\\n        returns (\\n            uint256 currentVersion,\\n            uint256 latestVersion,\\n            address logic\\n        );\\n\\n    /**\\n        @notice It tests whether a logic name is already configured.\\n        @param logicName logic name to test.\\n        @return true if the logic version is already configured. Otherwise it returns false.\\n     */\\n    function hasLogicVersion(bytes32 logicName) external view returns (bool);\\n\\n    /**\\n        @notice It initializes this logic versions registry contract instance.\\n        @param aOwner address of the owner of the registry.\\n        @param initialLogicVersions lists of the new logic versions to create.\\n     */\\n    function initialize(\\n        address aOwner,\\n        TellerCommon.CreateLogicVersionRequest[] calldata initialLogicVersions\\n    ) external;\\n}\\n\",\"keccak256\":\"0xcc4e9941221f7142f8cd1b7d800e825be3f42192ea0e5044dd965366d49c58b2\",\"license\":\"MIT\"},\"contracts/util/LogicVersionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n    @notice This library manages the functions for the logic version struct.\\n\\n    @author develop@teller.finance\\n */\\nlibrary LogicVersionLib {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    /**\\n        @notice It stores all the versions for a given logic.\\n        @param currentVersion the current version.\\n        @param latestVersion the latest version.\\n        @param versions mapping version to logic address.\\n        @param exists boolean to test whether this logic version exists or not.\\n     */\\n    struct LogicVersion {\\n        uint256 currentVersion;\\n        uint256 latestVersion;\\n        mapping(uint256 => address) versions;\\n        bool exists;\\n    }\\n\\n    /**\\n        @notice It creates a new logic version.\\n        @param self the current logic version instance.\\n        @param logic initial logic address.\\n     */\\n    function initialize(LogicVersion storage self, address logic) internal {\\n        requireNotExists(self);\\n        require(logic.isContract(), \\\"LOGIC_MUST_BE_CONTRACT\\\");\\n        self.currentVersion = 0;\\n        self.latestVersion = 0;\\n        self.versions[self.currentVersion] = logic;\\n        self.exists = true;\\n    }\\n\\n    /**\\n        @notice It rollbacks a logic to a previous version.\\n        @param self the current logic version instance.\\n        @param previousVersion the previous version to be used.\\n     */\\n    function rollback(LogicVersion storage self, uint256 previousVersion)\\n        internal\\n        returns (\\n            uint256 currentVersion,\\n            address previousLogic,\\n            address newLogic\\n        )\\n    {\\n        requireExists(self);\\n        require(\\n            self.currentVersion != previousVersion,\\n            \\\"CURRENT_VERSION_MUST_BE_DIFF\\\"\\n        );\\n        require(\\n            self.latestVersion >= previousVersion,\\n            \\\"VERSION_MUST_BE_LTE_LATEST\\\"\\n        );\\n        currentVersion = self.currentVersion;\\n        previousLogic = self.versions[self.currentVersion];\\n        newLogic = self.versions[previousVersion];\\n\\n        self.currentVersion = previousVersion;\\n    }\\n\\n    /**\\n        @notice Checks whether the current logic version exists or not.\\n        @dev It throws a require error if the logic version already exists.\\n        @param self the current logic version.\\n     */\\n    function requireNotExists(LogicVersion storage self) internal view {\\n        require(!self.exists, \\\"LOGIC_ALREADY_EXISTS\\\");\\n    }\\n\\n    /**\\n        @notice Checks whether the current logic version exists or not.\\n        @dev It throws a require error if the current logic version doesn't exist.\\n        @param self the current logic version.\\n     */\\n    function requireExists(LogicVersion storage self) internal view {\\n        require(self.exists, \\\"LOGIC_NOT_EXISTS\\\");\\n    }\\n\\n    /**\\n        @notice It upgrades a logic version.\\n        @dev It throws a require error if:\\n            - The new logic is equal to the current logic.\\n        @param self the current logic version.\\n        @param newLogic the new logic to set in the logic version.\\n        @return oldLogic the old logic address.\\n        @return oldVersion the old version.\\n        @return newVersion the new version.\\n     */\\n    function upgrade(LogicVersion storage self, address newLogic)\\n        internal\\n        returns (\\n            address oldLogic,\\n            uint256 oldVersion,\\n            uint256 newVersion\\n        )\\n    {\\n        requireExists(self);\\n        require(\\n            self.versions[self.currentVersion] != newLogic,\\n            \\\"NEW_LOGIC_REQUIRED\\\"\\n        );\\n        require(newLogic.isContract(), \\\"LOGIC_MUST_BE_CONTRACT\\\");\\n        oldLogic = self.versions[self.currentVersion];\\n        oldVersion = self.currentVersion;\\n        newVersion = self.latestVersion.add(1);\\n\\n        self.currentVersion = newVersion;\\n        self.latestVersion = newVersion;\\n        self.versions[newVersion] = newLogic;\\n    }\\n}\\n\",\"keccak256\":\"0x1d3ce95637a20616ce867dc76775063e12781aac5a00fd51a752b8621c36a167\",\"license\":\"MIT\"},\"contracts/util/NumbersLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Utility library for uint256 numbers\\n *\\n * @author develop@teller.finance\\n */\\nlibrary NumbersLib {\\n    using SafeMath for uint256;\\n\\n    /**\\n        @dev It represents 100% with 2 decimal places.\\n     */\\n    function ONE_HUNDRED_PERCENT() internal pure returns (uint256) {\\n        return 10000;\\n    }\\n\\n    /**\\n        @notice Returns the positive difference value of a number to another number\\n        @param self The number to return the difference value for\\n        @param other The other number to calucualte the difference against\\n        @return uint256 The difference value\\n     */\\n    function diff(uint256 self, uint256 other) internal pure returns (uint256) {\\n        return other > self ? other.sub(self) : self.sub(other);\\n    }\\n\\n    /**\\n        @notice Returns the positive percentage difference of a value to 100%\\n        @param self The number to return the percentage difference for\\n        @return uint256 The percentage difference value\\n     */\\n    function diffOneHundredPercent(uint256 self)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return diff(self, ONE_HUNDRED_PERCENT());\\n    }\\n\\n    /**\\n     * @notice Returns a percentage value of a number.\\n     * @param self The number to get a percentage of.\\n     * @param percentage The percentage value to calculate with 2 decimal places (10000 = 100%).\\n     */\\n    function percent(uint256 self, uint256 percentage)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self.mul(percentage).div(ONE_HUNDRED_PERCENT());\\n    }\\n\\n    function percent(int256 self, uint256 percentage)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return (self * int256(percentage)) / int256(ONE_HUNDRED_PERCENT());\\n    }\\n\\n    function abs(int256 self) internal pure returns (uint256) {\\n        return self >= 0 ? uint256(self) : uint256(-1 * self);\\n    }\\n\\n    /**\\n     * @notice Returns a ratio of 2 numbers.\\n     * @param self The number to get a ratio of.\\n     * @param num The number to calculate the ratio for.\\n     * @return Ratio of 2 numbers with 2 decimal places (10000 = 100%).\\n     */\\n    function ratioOf(uint256 self, uint256 num)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self.mul(ONE_HUNDRED_PERCENT()).div(num);\\n    }\\n}\\n\",\"keccak256\":\"0x310fd069f9f886c2f66bb134c98f2dee97c6c03d22f6468661e6d896a7fee4a4\",\"license\":\"MIT\"},\"contracts/util/NumbersList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./NumbersLib.sol\\\";\\n\\n/**\\n * @dev Utility library of inline functions on NumbersList.Values\\n *\\n * @author develop@teller.finance\\n */\\nlibrary NumbersList {\\n    using SafeMath for uint256;\\n    using NumbersLib for uint256;\\n\\n    // Holds values to calculate the threshold of a list of numbers\\n    struct Values {\\n        uint256 count; // The total number of numbers added\\n        uint256 max; // The maximum number that was added\\n        uint256 min; // The minimum number that was added\\n        uint256 sum; // The total sum of the numbers that were added\\n    }\\n\\n    /**\\n     * @dev Add to the sum while keeping track of min and max values\\n     * @param self The Value this function was called on\\n     * @param newValue Number to increment sum by\\n     */\\n    function addValue(Values memory self, uint256 newValue) internal pure {\\n        if (self.max < newValue) {\\n            self.max = newValue;\\n        }\\n        if (self.min > newValue || self.count == 0) {\\n            self.min = newValue;\\n        }\\n        self.sum = self.sum.add(newValue);\\n        self.count = self.count.add(1);\\n    }\\n\\n    /**\\n     * @param self The Value this function was called on\\n     * @return the number of times the sum has updated\\n     */\\n    function valuesCount(Values memory self) internal pure returns (uint256) {\\n        return self.count;\\n    }\\n\\n    /**\\n     * @dev Checks if the sum has been changed\\n     * @param self The Value this function was called on\\n     * @return boolean\\n     */\\n    function isEmpty(Values memory self) internal pure returns (bool) {\\n        return valuesCount(self) == 0;\\n    }\\n\\n    /**\\n     * @param self The Value this function was called on\\n     * @return the average number that was used to calculate the sum\\n     */\\n    function getAverage(Values memory self) internal pure returns (uint256) {\\n        return isEmpty(self) ? 0 : self.sum.div(valuesCount(self));\\n    }\\n\\n    /**\\n     * @dev Checks if the min and max numbers are within the acceptable tolerance\\n     * @param self The Value this function was called on\\n     * @param tolerancePercentage Acceptable tolerance percentage as a whole number\\n     * The percentage should be entered with 2 decimal places. e.g. 2.5% should be entered as 250.\\n     * @return boolean\\n     */\\n    function isWithinTolerance(Values memory self, uint256 tolerancePercentage)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (isEmpty(self)) {\\n            return false;\\n        }\\n        uint256 average = getAverage(self);\\n        uint256 toleranceAmount = average.percent(tolerancePercentage);\\n\\n        uint256 minTolerance = average.sub(toleranceAmount);\\n        if (self.min < minTolerance) {\\n            return false;\\n        }\\n\\n        uint256 maxTolerance = average.add(toleranceAmount);\\n        if (self.max > maxTolerance) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0xb724bee2331e49b0b74ad98d05c37c043f39e7abfe72a31d905fb0b548eaff05\",\"license\":\"MIT\"},\"contracts/util/TellerCommon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./NumbersList.sol\\\";\\n\\n/**\\n * @dev Library of structs common across the Teller protocol\\n *\\n * @author develop@teller.finance\\n */\\nlibrary TellerCommon {\\n    enum LoanStatus { NonExistent, TermsSet, Active, Closed }\\n\\n    /**\\n        @notice Represents a user signature\\n        @param v The recovery identifier represented by the last byte of a ECDSA signature as an int\\n        @param r The random point x-coordinate of the signature respresented by the first 32 bytes of the generated ECDSA signature\\n        @param s The signature proof represented by the second 32 bytes of the generated ECDSA signature\\n     */\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /**\\n        @notice Borrower request object to take out a loan\\n        @param borrower The wallet address of the borrower\\n        @param recipient The address where funds will be sent, only applicable in over collateralized loans\\n        @param consensusAddress The address of the Teller loan consensus contract to which the request should be sent\\n        @param requestNonce The nonce of the borrower wallet address required for authentication\\n        @param amount The amount of tokens requested by the borrower for the loan\\n        @param duration The length of time in seconds that the loan has been requested for\\n        @param requestTime The timestamp at which the loan was requested\\n     */\\n    struct LoanRequest {\\n        address payable borrower;\\n        address recipient;\\n        address consensusAddress;\\n        uint256 requestNonce;\\n        uint256 amount;\\n        uint256 duration;\\n        uint256 requestTime;\\n    }\\n\\n    /**\\n        @notice Borrower response object to take out a loan\\n        @param signer The wallet address of the signer validating the interest request of the lender\\n        @param consensusAddress The address of the Teller loan consensus contract to which the request should be sent\\n        @param responseTime The timestamp at which the response was sent\\n        @param interestRate The signed interest rate generated by the signer's Credit Risk Algorithm (CRA)\\n        @param collateralRatio The ratio of collateral to loan amount that is generated by the signer's Credit Risk Algorithm (CRA)\\n        @param maxLoanAmount The largest amount of tokens that can be taken out in the loan by the borrower\\n        @param signature The signature generated by the signer in the format of the above Signature struct\\n     */\\n    struct LoanResponse {\\n        address signer;\\n        address consensusAddress;\\n        uint256 responseTime;\\n        uint256 interestRate;\\n        uint256 collateralRatio;\\n        uint256 maxLoanAmount;\\n        Signature signature;\\n    }\\n\\n    /**\\n        @notice Represents loan terms based on consensus values\\n        @param interestRate The consensus value for the interest rate based on all the loan responses from the signers\\n        @param collateralRatio The consensus value for the ratio of collateral to loan amount required for the loan, based on all the loan responses from the signers\\n        @param maxLoanAmount The consensus value for the largest amount of tokens that can be taken out in the loan, based on all the loan responses from the signers\\n     */\\n    struct AccruedLoanTerms {\\n        NumbersList.Values interestRate;\\n        NumbersList.Values collateralRatio;\\n        NumbersList.Values maxLoanAmount;\\n    }\\n\\n    /**\\n        @notice Represents the terms of a loan based on the consensus of a LoanRequest\\n        @param borrower The wallet address of the borrower\\n        @param recipient The address where funds will be sent, only applicable in over collateralized loans\\n        @param interestRate The consensus interest rate calculated based on all signer loan responses\\n        @param collateralRatio The consensus ratio of collateral to loan amount calculated based on all signer loan responses\\n        @param maxLoanAmount The consensus largest amount of tokens that can be taken out in the loan by the borrower, calculated based on all signer loan responses\\n        @param duration The consensus length of loan time, calculated based on all signer loan responses\\n     */\\n    struct LoanTerms {\\n        address payable borrower;\\n        address recipient;\\n        uint256 interestRate;\\n        uint256 collateralRatio;\\n        uint256 maxLoanAmount;\\n        uint256 duration;\\n    }\\n\\n    /**\\n        @notice Data per borrow as struct\\n        @param id The id of the loan for internal tracking\\n        @param loanTerms The loan terms returned by the signers\\n        @param termsExpiry The timestamp at which the loan terms expire, after which if the loan is not yet active, cannot be taken out\\n        @param loanStartTime The timestamp at which the loan became active\\n        @param collateral The total amount of collateral deposited by the borrower to secure the loan\\n        @param lastCollateralIn The amount of collateral that was last deposited by the borrower to keep the loan active\\n        @param principalOwed The total amount of the loan taken out by the borrower, reduces on loan repayments\\n        @param interestOwed The total interest owed by the borrower for the loan, reduces on loan repayments\\n        @param borrowedAmount The total amount of the loan size taken out\\n        @param escrow The address of the escrow contract that holds the funds taken out in the loan on behalf of the borrower\\n        @param status The status of the loan currently based on the LoanStatus enum - NonExistent, TermsSet, Active, Closed\\n        @param liquidated Flag marking if the loan has been liquidated or not\\n     */\\n    struct Loan {\\n        uint256 id;\\n        LoanTerms loanTerms;\\n        uint256 termsExpiry;\\n        uint256 loanStartTime;\\n        uint256 collateral;\\n        uint256 lastCollateralIn;\\n        uint256 principalOwed;\\n        uint256 interestOwed;\\n        uint256 borrowedAmount;\\n        address escrow;\\n        LoanStatus status;\\n        bool liquidated;\\n    }\\n\\n    /**\\n        @notice This struct defines the dapp address and data to execute in the callDapp function.\\n        @dev It is executed using a delegatecall in the Escrow contract.\\n        @param exists Flag marking whether the dapp is a Teller registered address\\n        @param unsecured Flag marking if the loan allowed to be used in the dapp is a secured, or unsecured loan\\n     */\\n    struct Dapp {\\n        bool exists;\\n        bool unsecured;\\n    }\\n\\n    /**\\n        @notice This struct defines the dapp address and data to execute in the callDapp function.\\n        @dev It is executed using a delegatecall in the Escrow contract.\\n        @param location The proxy contract address for the dapp that will be used by the Escrow contract delegatecall\\n        @param data The encoded function signature with parameters for the dapp method in bytes that will be sent in the Escrow delegatecall\\n     */\\n    struct DappData {\\n        address location;\\n        bytes data;\\n    }\\n\\n    /**\\n        @notice This struct defines a market in the platform.\\n        @dev It is used by the MarketFactory contract.\\n        @param loans The address for the Teller LoanManager contract that is being used for a market\\n        @param lendingPool The address for the Teller Lending Pool contract that is being used for a market\\n        @param loanTermsConsensus The address for the Teller Loan Terms Consensus contract that is being used for a market\\n        @param exists Flag marking if the market is defined on the platform or not\\n     */\\n    struct Market {\\n        address loans;\\n        address lendingPool;\\n        address loanTermsConsensus;\\n        bool exists;\\n    }\\n\\n    /**\\n        @notice This struct is used to register new logic versions.\\n        @param logic The address for the new contract holding the logic.\\n        @param logicName The name for the logic to be stored as.\\n     */\\n    struct CreateLogicVersionRequest {\\n        address logic;\\n        bytes32 logicName;\\n    }\\n\\n    /**\\n        @notice This struct is used to upgrade logic versions.\\n        @param logic The new logic address to upgrade proxy to.\\n        @param logicName The name for the logic to be stored as.\\n        @param proxy The (optional) DynamicUpgradeable proxy address to attempt to directly upgrade.\\n     */\\n    struct UpgradeLogicVersionRequest {\\n        address logic;\\n        bytes32 logicName;\\n        address proxy;\\n    }\\n}\\n\",\"keccak256\":\"0xa90e2a78f0d767c9cea8ce6b0f0a1a359fcaebb63e7fc6393c7dceb443ccc791\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5060405161078e38038061078e83398101604081905261002f91610158565b600080546001600160a01b0319166001600160a01b03851617905560018290556002805460ff191682151517905561006561006d565b5050506101cf565b60008054600154604051638b51f58b60e01b81526001600160a01b0390921691638b51f58b916100a39160040190815260200190565b60606040518083038186803b1580156100bb57600080fd5b505afa1580156100cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100f3919061019b565b6002549093506001600160a01b038085166101009092041614915061013590505760028054610100600160a81b0319166101006001600160a01b038416021790555b5043600355565b80516001600160a01b038116811461015357600080fd5b919050565b60008060006060848603121561016c578283fd5b6101758461013c565b92506020840151915060408401518015158114610190578182fd5b809150509250925092565b6000806000606084860312156101af578283fd5b83519250602084015191506101c66040850161013c565b90509250925092565b6105b0806101de6000396000f3fe6080604052600436106100745760003560e01c80634f8654bc1161004e5780634f8654bc1461010157806355dbd8eb146101265780635c60da1b14610146578063e154e9a41461015b57610083565b80631eb83d541461008b5780632c26486d146100a057806337c3eedc146100c957610083565b3661008357610081610185565b005b610081610185565b34801561009757600080fd5b5061008161019f565b3480156100ac57600080fd5b506100b660015481565b6040519081526020015b60405180910390f35b3480156100d557600080fd5b506000546100e9906001600160a01b031681565b6040516001600160a01b0390911681526020016100c0565b34801561010d57600080fd5b506002546100e99061010090046001600160a01b031681565b34801561013257600080fd5b506100816101413660046104aa565b61026e565b34801561015257600080fd5b506100e96102f1565b34801561016757600080fd5b506002546101759060ff1681565b60405190151581526020016100c0565b61018d610301565b61019d6101986103a0565b6103aa565b565b60008054600154604051638b51f58b60e01b81526001600160a01b0390921691638b51f58b916101d59160040190815260200190565b60606040518083038186803b1580156101ed57600080fd5b505afa158015610201573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061022591906104cd565b6002549093506001600160a01b038085166101009092041614915061026790505760028054610100600160a81b0319166101006001600160a01b038416021790555b5043600355565b6000546001600160a01b031633146102c55760405162461bcd60e51b81526020600482015260166024820152754d5553545f42455f4c4f4749435f524547495354525960501b604482015260640160405180910390fd5b600280546001600160a01b0390921661010002610100600160a81b031990921691909117905543600355565b60006102fb6103a0565b90505b90565b60025460ff168015610321575043600354603261031e919061053e565b11155b1561019d5760408051600481526024810182526020810180516001600160e01b03166307ae0f5560e21b1790529051309161035b91610505565b600060405180830381855af49150503d8060008114610396576040519150601f19603f3d011682016040523d82523d6000602084013e61039b565b606091505b505050565b60006102fb6103ce565b3660008037600080366000845af43d6000803e8080156103c9573d6000f35b3d6000fd5b60006103d8610483565b1561046e5760008054600154604051638b51f58b60e01b81526001600160a01b0390921691638b51f58b916104139160040190815260200190565b60606040518083038186803b15801561042b57600080fd5b505afa15801561043f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061046391906104cd565b93506102fe92505050565b5060025461010090046001600160a01b031690565b60025460009060ff1680156102fb57504360035460016104a3919061053e565b1115905090565b6000602082840312156104bb578081fd5b81356104c681610562565b9392505050565b6000806000606084860312156104e1578182fd5b835192506020840151915060408401516104fa81610562565b809150509250925092565b60008251815b81811015610525576020818601810151858301520161050b565b818111156105335782828501525b509190910192915050565b6000821982111561055d57634e487b7160e01b81526011600452602481fd5b500190565b6001600160a01b038116811461057757600080fd5b5056fea26469706673582212207ff1d0929e57747d245d639f2e6e5e26d9a130b74b7265f006299f8354d13edd64736f6c63430008030033",
  "deployedBytecode": "0x6080604052600436106100745760003560e01c80634f8654bc1161004e5780634f8654bc1461010157806355dbd8eb146101265780635c60da1b14610146578063e154e9a41461015b57610083565b80631eb83d541461008b5780632c26486d146100a057806337c3eedc146100c957610083565b3661008357610081610185565b005b610081610185565b34801561009757600080fd5b5061008161019f565b3480156100ac57600080fd5b506100b660015481565b6040519081526020015b60405180910390f35b3480156100d557600080fd5b506000546100e9906001600160a01b031681565b6040516001600160a01b0390911681526020016100c0565b34801561010d57600080fd5b506002546100e99061010090046001600160a01b031681565b34801561013257600080fd5b506100816101413660046104aa565b61026e565b34801561015257600080fd5b506100e96102f1565b34801561016757600080fd5b506002546101759060ff1681565b60405190151581526020016100c0565b61018d610301565b61019d6101986103a0565b6103aa565b565b60008054600154604051638b51f58b60e01b81526001600160a01b0390921691638b51f58b916101d59160040190815260200190565b60606040518083038186803b1580156101ed57600080fd5b505afa158015610201573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061022591906104cd565b6002549093506001600160a01b038085166101009092041614915061026790505760028054610100600160a81b0319166101006001600160a01b038416021790555b5043600355565b6000546001600160a01b031633146102c55760405162461bcd60e51b81526020600482015260166024820152754d5553545f42455f4c4f4749435f524547495354525960501b604482015260640160405180910390fd5b600280546001600160a01b0390921661010002610100600160a81b031990921691909117905543600355565b60006102fb6103a0565b90505b90565b60025460ff168015610321575043600354603261031e919061053e565b11155b1561019d5760408051600481526024810182526020810180516001600160e01b03166307ae0f5560e21b1790529051309161035b91610505565b600060405180830381855af49150503d8060008114610396576040519150601f19603f3d011682016040523d82523d6000602084013e61039b565b606091505b505050565b60006102fb6103ce565b3660008037600080366000845af43d6000803e8080156103c9573d6000f35b3d6000fd5b60006103d8610483565b1561046e5760008054600154604051638b51f58b60e01b81526001600160a01b0390921691638b51f58b916104139160040190815260200190565b60606040518083038186803b15801561042b57600080fd5b505afa15801561043f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061046391906104cd565b93506102fe92505050565b5060025461010090046001600160a01b031690565b60025460009060ff1680156102fb57504360035460016104a3919061053e565b1115905090565b6000602082840312156104bb578081fd5b81356104c681610562565b9392505050565b6000806000606084860312156104e1578182fd5b835192506020840151915060408401516104fa81610562565b809150509250925092565b60008251815b81811015610525576020818601810151858301520161050b565b818111156105335782828501525b509190910192915050565b6000821982111561055d57634e487b7160e01b81526011600452602481fd5b500190565b6001600160a01b038116811461057757600080fd5b5056fea26469706673582212207ff1d0929e57747d245d639f2e6e5e26d9a130b74b7265f006299f8354d13edd64736f6c63430008030033",
  "devdoc": {
    "author": "develop@teller.finance",
    "kind": "dev",
    "methods": {
      "_updateImplementationStored()": {
        "details": "It uses the LogicVersionsRegistry contract to get the logic address or the cached address if valid.It caches the current logic address for the proxy to reduce gas on subsequent calls within the same block."
      },
      "constructor": {
        "params": {
          "aLogicName": "the settings contract address.",
          "isStrictDynamic": "Boolean indicating if the proxy must check the registry for a new implementation.",
          "logicRegistryAddress": "the settings contract address."
        }
      },
      "implementation()": {
        "returns": {
          "_0": "Address of the current implementation"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "_updateImplementationStored()": {
        "notice": "Updates the current implementation logic address for the stored logic name."
      },
      "constructor": {
        "notice": "It creates a new dynamic proxy given a logic registry contract and a logic name."
      },
      "implementation()": {
        "notice": "Returns the current implementation."
      },
      "implementationStored()": {
        "notice": "It stores the last known logic address locally to reduce gas costs."
      },
      "logicName()": {
        "notice": "It represent the logic name (key) used for this proxy."
      },
      "logicRegistry()": {
        "notice": "It returns the logic registry that is used to determine the implementation logic for this proxy."
      },
      "strictDynamic()": {
        "notice": "Boolean indicating if the proxy must check the registry for a new implementation."
      },
      "upgradeProxyTo(address)": {
        "notice": "It updates a proxy's cached implementation address.It must only be called by the LogicVersionsRegistry for non strict DynamicProxy"
      }
    },
    "notice": "It is a dynamic proxy contract for any contract. It uses the logic versions registry to get a logic contract address.It extends BaseUpgradeable to get access to the settings.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 13960,
        "contract": "contracts/base/proxies/DynamicProxy.sol:DynamicProxy",
        "label": "logicRegistry",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(LogicVersionsRegistryInterface)14789"
      },
      {
        "astId": 13963,
        "contract": "contracts/base/proxies/DynamicProxy.sol:DynamicProxy",
        "label": "logicName",
        "offset": 0,
        "slot": "1",
        "type": "t_bytes32"
      },
      {
        "astId": 13966,
        "contract": "contracts/base/proxies/DynamicProxy.sol:DynamicProxy",
        "label": "strictDynamic",
        "offset": 0,
        "slot": "2",
        "type": "t_bool"
      },
      {
        "astId": 13969,
        "contract": "contracts/base/proxies/DynamicProxy.sol:DynamicProxy",
        "label": "implementationStored",
        "offset": 1,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 13972,
        "contract": "contracts/base/proxies/DynamicProxy.sol:DynamicProxy",
        "label": "_implementationBlockUpdated",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(LogicVersionsRegistryInterface)14789": {
        "encoding": "inplace",
        "label": "contract LogicVersionsRegistryInterface",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}
